From d1de491cbaa36ad006786110e2365871f3307301 Mon Sep 17 00:00:00 2001
From: Amit Prakash Ambasta <amit.prakash.ambasta@gmail.com>
Date: Sat, 10 Jul 2021 22:56:04 +0530
Subject: [PATCH] Latest placebo

---
 DOCS/contribute.md                          |    2 +-
 DOCS/edl-mpv.rst                            |   20 +
 DOCS/interface-changes.rst                  |   14 +
 DOCS/man/ao.rst                             |   13 +-
 DOCS/man/console.rst                        |    4 +-
 DOCS/man/input.rst                          |   71 +-
 DOCS/man/javascript.rst                     |   10 +-
 DOCS/man/libmpv.rst                         |    4 +-
 DOCS/man/lua.rst                            |   12 +-
 DOCS/man/mpv.rst                            |   29 +-
 DOCS/man/options.rst                        |  256 ++-
 DOCS/man/osc.rst                            |   21 +-
 DOCS/man/vf.rst                             |    2 +-
 DOCS/man/vo.rst                             |   30 +-
 README.md                                   |   12 +-
 RELEASE_NOTES                               |   18 +-
 TOOLS/appveyor-install.sh                   |   22 +-
 TOOLS/lua/autoload.lua                      |    8 +-
 TOOLS/matroska.py                           |    8 +-
 TOOLS/osxbundle/mpv.app/Contents/Info.plist |    5 +
 TOOLS/travis-rebuild-website                |    2 +-
 TOOLS/umpv                                  |    4 +-
 VERSION                                     |    2 +-
 appveyor.yml                                |   16 +-
 audio/aframe.c                              |   18 +-
 audio/decode/ad_lavc.c                      |    2 +-
 audio/decode/ad_spdif.c                     |    2 +-
 audio/filter/af_lavcac3enc.c                |    2 +-
 audio/filter/af_scaletempo2_internals.c     |   97 +-
 audio/out/ao.c                              |    4 +
 audio/out/ao_oss.c                          |  410 ++++
 audio/out/ao_pulse.c                        |   25 +-
 bootstrap.py                                |   11 +-
 common/av_common.c                          |   23 +-
 common/encode_lavc.c                        |    6 +-
 common/encode_lavc.h                        |    4 +-
 common/msg.c                                |    4 +-
 common/recorder.c                           |   69 +-
 common/recorder.h                           |    5 +-
 demux/demux.c                               |   43 +-
 demux/demux.h                               |    4 +-
 demux/demux_edl.c                           |   17 +-
 demux/demux_lavf.c                          |    6 +-
 demux/demux_mf.c                            |    2 +
 etc/_mpv.zsh                                |    8 +-
 etc/input.conf                              |    1 +
 filters/f_auto_filters.c                    |    4 +-
 filters/f_auto_filters.h                    |    2 +-
 filters/f_decoder_wrapper.c                 |   19 +-
 input/cmd.c                                 |   13 +
 options/m_option.c                          |   32 +-
 options/m_option.h                          |   40 +-
 options/options.c                           |   23 +-
 options/options.h                           |    5 +
 osdep/macos/libmpv_helper.swift             |   68 +-
 osdep/macos/mpv_helper.swift                |   36 +-
 osdep/macos/swift_compat.swift              |   27 -
 osdep/macosx_application.h                  |    6 +
 osdep/macosx_application.m                  |    2 +
 osdep/macosx_menubar.m                      |    7 +
 osdep/macosx_touchbar.h                     |    1 +
 osdep/macosx_touchbar.m                     |  248 ++-
 osdep/terminal-unix.c                       |   10 +-
 player/audio.c                              |   12 +-
 player/command.c                            |  129 +-
 player/configfiles.c                        |    2 +-
 player/core.h                               |    6 +-
 player/external_files.c                     |   23 +-
 player/javascript.c                         |   30 +-
 player/javascript/defaults.js               |    5 +-
 player/loadfile.c                           |   45 +-
 player/lua.c                                |    8 -
 player/lua/auto_profiles.lua                |   16 +-
 player/lua/console.lua                      |   12 +-
 player/lua/defaults.lua                     |   28 +-
 player/lua/osc.lua                          |   92 +-
 player/lua/stats.lua                        |   11 +
 player/lua/ytdl_hook.lua                    |   53 +-
 player/main.c                               |    8 -
 player/scripting.c                          |    5 +-
 player/sub.c                                |    5 +-
 stream/stream.h                             |    2 +-
 stream/stream_concat.c                      |    2 +-
 stream/stream_file.c                        |   13 +-
 stream/stream_lavf.c                        |   14 +-
 stream/stream_memory.c                      |    2 +-
 stream/stream_mf.c                          |    1 +
 stream/stream_slice.c                       |    7 +-
 sub/dec_sub.c                               |    5 +
 sub/dec_sub.h                               |    2 +-
 sub/lavc_conv.c                             |    2 +-
 sub/osd.c                                   |    5 +-
 sub/sd_lavc.c                               |    2 +-
 video/csputils.c                            |   11 +-
 video/csputils.h                            |    1 +
 video/decode/vd_lavc.c                      |   48 +-
 video/filter/vf_sub.c                       |    9 +
 video/image_writer.c                        |    6 +-
 video/out/cocoa_cb_common.swift             |    7 +-
 video/out/d3d11/context.c                   |    7 +-
 video/out/drm_common.c                      |   49 +-
 video/out/filter_kernels.c                  |    2 +-
 video/out/gpu/context.c                     |   42 +-
 video/out/gpu/context.h                     |    8 +-
 video/out/gpu/hwdec.c                       |    3 +-
 video/out/gpu/hwdec.h                       |    2 +-
 video/out/gpu/lcms.c                        |   84 +-
 video/out/gpu/shader_cache.c                |   22 +-
 video/out/gpu/shader_cache.h                |    4 +
 video/out/gpu/video.c                       |   56 +-
 video/out/gpu/video_shaders.c               |   88 +-
 video/out/hwdec/hwdec_vaapi.c               |    2 +-
 video/out/hwdec/hwdec_vaapi.h               |    2 +-
 video/out/hwdec/hwdec_vaapi_gl.c            |    2 +-
 video/out/hwdec/hwdec_vaapi_vk.c            |    9 +-
 video/out/mac/common.swift                  |  127 +-
 video/out/mac/title_bar.swift               |    4 +-
 video/out/mac/window.swift                  |   49 +-
 video/out/opengl/context_drm_egl.c          |    5 +
 video/out/opengl/context_wayland.c          |   95 +-
 video/out/placebo/ra_pl.c                   |   87 +-
 video/out/vo.h                              |    1 +
 video/out/vo_drm.c                          |    5 +
 video/out/vo_gpu.c                          |   12 +-
 video/out/vo_rpi.c                          |    4 +
 video/out/vo_sixel.c                        |  215 ++-
 video/out/vo_tct.c                          |   10 +-
 video/out/vo_wlshm.c                        |   46 +-
 video/out/vulkan/context.c                  |   17 +-
 video/out/vulkan/context.h                  |    3 +
 video/out/vulkan/context_display.c          |  395 ++++
 video/out/vulkan/context_wayland.c          |   90 +-
 video/out/w32_common.c                      |   76 +-
 video/out/wayland_common.c                  | 1935 +++++++++++--------
 video/out/wayland_common.h                  |  135 +-
 video/out/x11_common.c                      |   48 +-
 video/out/x11_common.h                      |    4 +
 video/zimg.c                                |    1 +
 waftools/checks/custom.py                   |   24 +-
 wscript                                     |   23 +-
 wscript_build.py                            |    2 +
 141 files changed, 4106 insertions(+), 2209 deletions(-)
 create mode 100644 audio/out/ao_oss.c
 create mode 100644 video/out/vulkan/context_display.c

diff --git a/DOCS/contribute.md b/DOCS/contribute.md
index cc30978..48307d9 100644
--- a/DOCS/contribute.md
+++ b/DOCS/contribute.md
@@ -5,7 +5,7 @@ General
 -------
 
 The main contact for mpv development is IRC, specifically #mpv
-and #mpv-devel on Freenode. Github is used for code review and
+and #mpv-devel on Libera.chat. Github is used for code review and
 long term discussions.
 
 Sending patches
diff --git a/DOCS/edl-mpv.rst b/DOCS/edl-mpv.rst
index 78da44a..0e4d2b4 100644
--- a/DOCS/edl-mpv.rst
+++ b/DOCS/edl-mpv.rst
@@ -239,6 +239,26 @@ title. The subtitle stream will use ``ducks`` as title.
 The ``track_meta`` header is not part of the core EDL format. It may be changed
 or removed at any time, depending on mpv's internal requirements.
 
+Global metadata
+===============
+
+The special ``global_tags`` header can set metadata fields (aka tags) of the EDL
+file. This metadata is supposed to be informational, much like for example ID3
+tags in audio files. Due to lack of separation of different kinds of metadata it
+is unspecified what names are allowed, how they are interpreted, and whether
+some of them affect playback functionally. (Much of this is unfortunately
+inherited from FFmpeg. Another consequence of this is that FFmpeg "normalized"
+tags are recognized, or stuff like replaygain tags.)
+
+Example::
+
+    !global_tags,title=bla,something_arbitrary=even_more_arbitrary
+
+Any parameter names are allowed. Repeated use of this adds to the tag list. If
+``!new_stream`` is used, the location doesn't matter.
+
+May possibly be ignored in some cases, such as delayed media opening.
+
 Delayed media opening
 =====================
 
diff --git a/DOCS/interface-changes.rst b/DOCS/interface-changes.rst
index 16f570a..a3539c1 100644
--- a/DOCS/interface-changes.rst
+++ b/DOCS/interface-changes.rst
@@ -26,6 +26,20 @@ Interface changes
 
 ::
 
+ --- mpv 0.34.0 ---
+    - add `--screen-name` and `--fs-screen-name` flags to allow selecting the
+      screen by its name instead of the index
+    - add `--macos-geometry-calculation` to change the rectangle used for screen
+      position and size calculation. the old behavior used the whole screen,
+      which didn't take the menu bar and Dock into account. The new default
+      behaviour includes both. To revert to the old behavior set this to
+      `whole`.
+    - add an additional optional `albumart` argument to the `video-add` command,
+      which tells mpv to load the given video as album art.
+    - undeprecate `--cache-secs` option
+    - remove `--icc-contrast` and introduce `--icc-force-contrast`. The latter
+      defaults to the equivalent of the old `--icc-contrast=inf`, and can
+      instead be used to specifically set the contrast to any value.
  --- mpv 0.33.0 ---
     - add `--d3d11-exclusive-fs` flag to enable D3D11 exclusive fullscreen mode
       when the player enters fullscreen.
diff --git a/DOCS/man/ao.rst b/DOCS/man/ao.rst
index cc42ec2..1c0b9e1 100644
--- a/DOCS/man/ao.rst
+++ b/DOCS/man/ao.rst
@@ -14,7 +14,7 @@ in the list.
 
     See ``--ao=help`` for a list of compiled-in audio output drivers. The
     driver ``--ao=alsa`` is preferred. ``--ao=pulse`` is preferred on systems
-    where PulseAudio is used.
+    where PulseAudio is used. On BSD systems, ``--ao=oss`` is preferred.
 
 Available audio output drivers are:
 
@@ -35,6 +35,9 @@ Available audio output drivers are:
         with automatic upmixing with shared access, so playing stereo
         and multichannel audio at the same time will work as expected.
 
+``oss``
+    OSS audio output driver
+
 ``jack``
     JACK (Jack Audio Connection Kit) audio output driver.
 
@@ -65,8 +68,8 @@ Available audio output drivers are:
         mode is probably not very useful, other than for debugging or when used
         with fixed setups.
 
-``coreaudio`` (Mac OS X only)
-    Native Mac OS X audio output driver using AudioUnits and the CoreAudio
+``coreaudio`` (macOS only)
+    Native macOS audio output driver using AudioUnits and the CoreAudio
     sound server.
 
     Automatically redirects to ``coreaudio_exclusive`` when playing compressed
@@ -92,8 +95,8 @@ Available audio output drivers are:
         extreme care.
 
 
-``coreaudio_exclusive`` (Mac OS X only)
-    Native Mac OS X audio output driver using direct device access and
+``coreaudio_exclusive`` (macOS only)
+    Native macOS audio output driver using direct device access and
     exclusive mode (bypasses the sound server).
 
 ``openal``
diff --git a/DOCS/man/console.rst b/DOCS/man/console.rst
index e9a829c..22725a3 100644
--- a/DOCS/man/console.rst
+++ b/DOCS/man/console.rst
@@ -36,7 +36,7 @@ INSERT
     Toggle insert mode.
 
 Shift+INSERT
-    Paste text (uses the primary selection on X11).
+    Paste text (uses the primary selection on X11 and Wayland).
 
 TAB
     Complete the command or property name at the cursor.
@@ -54,7 +54,7 @@ Ctrl+U
     Delete text from the cursor to the beginning of the line.
 
 Ctrl+V
-    Paste text (uses the clipboard on X11).
+    Paste text (uses the clipboard on X11 and Wayland).
 
 Ctrl+W
     Delete text from the cursor to the beginning of the current word.
diff --git a/DOCS/man/input.rst b/DOCS/man/input.rst
index 1bcae75..66f7dbd 100644
--- a/DOCS/man/input.rst
+++ b/DOCS/man/input.rst
@@ -62,8 +62,8 @@ character), or a symbolic name (as printed by ``--input-keylist``).
 command.
 
 ``<command>`` is the command itself. It consists of the command name and
-multiple (or none) commands, all separated by whitespace. String arguments
-need to be quoted with ``"``. Details see ``Flat command syntax``.
+multiple (or none) arguments, all separated by whitespace. String arguments
+should be quoted, typically with ``"``. See ``Flat command syntax``.
 
 You can bind multiple commands to one key. For example:
 
@@ -162,18 +162,28 @@ a number of other places.
 
 |
 | ``<command>  ::= [<prefixes>] <command_name> (<argument>)*``
-| ``<argument> ::= (<string> | " <quoted_string> ")``
+| ``<argument> ::= (<unquoted> | " <double_quoted> " | !X <custom_quoted> X!)``
 
 ``command_name`` is an unquoted string with the command name itself. See
 `List of Input Commands`_ for a list.
 
-Arguments are separated by whitespace. This applies even to string arguments.
-For this reason, string arguments should be quoted with ``"``. If a string
-argument contains spaces or certain special characters, quoting and possibly
-escaping is mandatory, or the command cannot be parsed correctly.
+Arguments are separated by whitespaces even if the command expects only one
+argument. Arguments with whitespaces or other special characters must be quoted,
+or the command cannot be parsed correctly.
 
-Inside quotes, C-style escaping can be used. JSON escapes according to RFC 8259,
-minus surrogate pair escapes, should be a safe subset that can be used.
+Double quoted arguments start and end with ``"``. Custom quotes start with ``!``
+(exclamation mark) followed by any ASCII character, and end in the same pair in
+reverse order, e.g. ``!'foo'!`` or ``!-bar-!``. The final pair sequence is not
+allowed inside the string - in these examples ``'!`` and ``-!`` respectively.
+
+Custom quotes take their content literally, while inside double quotes
+JSON/C-style escaping can be used. JSON escapes according to RFC 8259, minus
+surrogate pair escapes, should be a safe subset that can be used.
+
+Note that argument parsing and property expansion happen at different stages.
+First, arguments are determined as described above, and then, where applicable,
+properties are expanded - regardless of argument quoting. However, expansion
+can still be prevented with ``$>``. See `Property Expansion`_.
 
 Commands specified as arrays
 ----------------------------
@@ -440,6 +450,10 @@ Remember to quote string arguments in input.conf (see `Flat command syntax`_).
         Stop playback and replace the internal playlist with the new one.
     <append>
         Append the new playlist at the end of the current internal playlist.
+    <append-play>
+        Append the new playlist, and if nothing is currently playing, start
+        playback. (Always starts with the new playlist, even if the internal
+        playlist was not empty before running this command.)
 
 ``playlist-clear``
     Clear the playlist, except the currently played file.
@@ -791,8 +805,11 @@ Remember to quote string arguments in input.conf (see `Flat command syntax`_).
 ``audio-reload [<id>]``
     Reload the given audio tracks. See ``sub-reload`` command.
 
-``video-add <url> [<flags> [<title> [<lang>]]]``
-    Load the given video file. See ``sub-add`` command.
+``video-add <url> [<flags> [<title> [<lang> [<albumart>]]]]``
+    Load the given video file. See ``sub-add`` command for common options.
+
+    ``albumart`` (``MPV_FORMAT_FLAG``)
+        If enabled, mpv will load the given video as album art.
 
 ``video-remove [<id>]``
     Remove the given video track. See ``sub-remove`` command.
@@ -801,9 +818,9 @@ Remember to quote string arguments in input.conf (see `Flat command syntax`_).
     Reload the given video tracks. See ``sub-reload`` command.
 
 ``rescan-external-files [<mode>]``
-    Rescan external files according to the current ``--sub-auto`` and
-    ``--audio-file-auto`` settings. This can be used to auto-load external
-    files *after* the file was loaded.
+    Rescan external files according to the current ``--sub-auto``,
+    ``--audio-file-auto`` and ``--cover-art-auto`` settings. This can be used
+    to auto-load external files *after* the file was loaded.
 
     The ``mode`` argument is one of the following:
 
@@ -1161,7 +1178,8 @@ Input Commands that are Possibly Subject to Change
 ``script-message-to <target> [<arg1> [<arg2> [...]]]``
     Same as ``script-message``, but send it only to the client named
     ``<target>``. Each client (scripts etc.) has a unique name. For example,
-    Lua scripts can get their name via ``mp.get_script_name()``.
+    Lua scripts can get their name via ``mp.get_script_name()``. Note that
+    client names only consist of alphanumeric characters and ``_``.
 
     This command has a variable number of arguments, and cannot be used with
     named arguments.
@@ -1173,7 +1191,8 @@ Input Commands that are Possibly Subject to Change
     The argument is the name of the binding.
 
     It can optionally be prefixed with the name of the script, using ``/`` as
-    separator, e.g. ``script-binding scriptname/bindingname``.
+    separator, e.g. ``script-binding scriptname/bindingname``. Note that script
+    names only consist of alphanumeric characters and ``_``.
 
     For completeness, here is how this command works internally. The details
     could change any time. On any matching key event, ``script-message-to``
@@ -1806,6 +1825,9 @@ Property list
     .. note:: This is only an estimate. (It's computed from two unreliable
               quantities: fps and possibly rounded timestamps.)
 
+``pid``
+    Process-id of mpv.
+
 ``path``
     Full path of the currently played file. Usually this is exactly the same
     string you pass on the mpv command line or the ``loadfile`` command, even
@@ -2484,8 +2506,7 @@ Property list
     ways. The property is unavailable if no video is active.
 
 ``focused``
-    Whether the window has focus. Currently works only on X11, Wayland and
-    macOS.
+    Whether the window has focus. Might not be supported by all VOs.
 
 ``display-names``
     Names of the displays that the mpv window covers. On X11, these
@@ -2516,6 +2537,11 @@ Property list
 ``vsync-jitter``
     Estimated deviation factor of the vsync duration.
 
+``display-width``, ``display-height``
+    The current display's horizontal and vertical resolution in pixels. Whether
+    or not these values update as the mpv window changes displays depends on
+    the windowing backend. It may not be available on all platforms.
+
 ``display-hidpi-scale``
     The HiDPI scale factor as reported by the windowing backend. If no VO is
     active, or if the VO does not report a value, this property is unavailable.
@@ -2531,8 +2557,8 @@ Property list
 
 ``osd-width``, ``osd-height``
     Last known OSD width (can be 0). This is needed if you want to use the
-    ``overlay-add`` command. It gives you the actual OSD size, which can be
-    different from the window size in some cases.
+    ``overlay-add`` command. It gives you the actual OSD/window size (not
+    including decorations drawn by the OS window manager).
 
     Alias to ``osd-dimensions/w`` and ``osd-dimensions/h``.
 
@@ -2602,6 +2628,9 @@ Property list
 
     This property is experimental and might be removed in the future.
 
+``secondary-sub-text``
+    Same as ``sub-text``, but for the secondary subtitles.
+
 ``sub-start``
     The current subtitle start time (in seconds). If there's multiple current
     subtitles, returns the first start time. If no current subtitle is present
@@ -3353,7 +3382,7 @@ You can access (almost) all options as properties, though there are some
 caveats with some properties (due to historical reasons):
 
 ``vid``, ``aid``, ``sid``
-    While playback is active, these result the actually active tracks. For
+    While playback is active, these return the actually active tracks. For
     example, if you set ``aid=5``, and the currently played file contains no
     audio track with ID 5, the ``aid`` property will return ``no``.
 
diff --git a/DOCS/man/javascript.rst b/DOCS/man/javascript.rst
index 1e5ce99..0cd4fb8 100644
--- a/DOCS/man/javascript.rst
+++ b/DOCS/man/javascript.rst
@@ -221,7 +221,8 @@ Additional utilities
 
 ``mp.utils.get_user_path(path)``
     Expands (mpv) meta paths like ``~/x``, ``~~/y``, ``~~desktop/z`` etc.
-    ``read_file``, ``write_file`` and ``require`` already use this internaly.
+    ``read_file``, ``write_file``, ``append_file`` and ``require`` already use
+    this internaly.
 
 ``mp.utils.read_file(fname [,max])``
     Returns the content of file ``fname`` as string. If ``max`` is provided and
@@ -232,7 +233,12 @@ Additional utilities
     prefixed with ``file://`` as simple protection against accidental arguments
     switch, e.g. ``mp.utils.write_file("file://~/abc.txt", "hello world")``.
 
-Note: ``read_file`` and ``write_file`` throw on errors, allow text content only.
+``mp.utils.append_file(fname, str)``
+    Same as ``mp.utils.write_file`` if the file ``fname`` does not exist. If it
+    does exist then append instead of overwrite.
+
+Note: ``read_file``, ``write_file`` and ``append_file`` throw on errors, allow
+text content only.
 
 ``mp.get_time_ms()``
     Same as ``mp.get_time()`` but in ms instead of seconds.
diff --git a/DOCS/man/libmpv.rst b/DOCS/man/libmpv.rst
index 909a2bb..7f5d2f5 100644
--- a/DOCS/man/libmpv.rst
+++ b/DOCS/man/libmpv.rst
@@ -21,8 +21,8 @@ C PLUGINS
 You can write C plugins for mpv. These use the libmpv API, although they do not
 use the libmpv library itself.
 
-Currently, they must be explicitly enabled at build time with
-``--enable-cplugins``. They are available on Linux/BSD platforms only.
+They are available on Linux/BSD platforms only and enabled by default if the
+compiler supports linking with the ``-rdynamic`` flag.
 
 C plugins location
 ------------------
diff --git a/DOCS/man/lua.rst b/DOCS/man/lua.rst
index 3fdb0b2..4395404 100644
--- a/DOCS/man/lua.rst
+++ b/DOCS/man/lua.rst
@@ -37,6 +37,12 @@ scripting backend to use for it. For Lua, it is ``.lua``. If the extension is
 not recognized, an error is printed. (If an error happens, the extension is
 either mistyped, or the backend was not compiled into your mpv binary.)
 
+mpv internally loads the script's name by stripping the ``.lua`` extension and
+replacing all nonalphanumeric characters with ``_``. E.g., ``my-tools.lua``
+becomes ``my_tools``. If there are several scripts with the same name, it is
+made unique by appending a number. This is the name returned by
+``mp.get_script_name()``.
+
 Entries with ``.disable`` extension are always ignored.
 
 If a script is a directory (either if a directory is passed to ``--script``,
@@ -500,11 +506,11 @@ The ``mp`` module is preloaded, although it can be loaded manually with
     Return the name of the current script. The name is usually made of the
     filename of the script, with directory and file extension removed. If
     there are several scripts which would have the same name, it's made unique
-    by appending a number.
+    by appending a number. Any nonalphanumeric characters are replaced with ``_``.
 
     .. admonition:: Example
 
-        The script ``/path/to/fooscript.lua`` becomes ``fooscript``.
+        The script ``/path/to/foo-script.lua`` becomes ``foo_script``.
 
 ``mp.get_script_directory()``
     Return the directory if this is a script packaged as directory (see
@@ -763,7 +769,7 @@ strictly part of the guaranteed API.
         ``mtime``
             time of last modification
         ``ctime``
-            time of last metadata change (Linux) / time of creation (Windows)
+            time of last metadata change
         ``is_file``
             Whether ``path`` is a regular file (boolean)
         ``is_dir``
diff --git a/DOCS/man/mpv.rst b/DOCS/man/mpv.rst
index be29a97..e0ac72c 100644
--- a/DOCS/man/mpv.rst
+++ b/DOCS/man/mpv.rst
@@ -247,16 +247,16 @@ corresponding adjustment.)
 7 and 8
     Adjust saturation.
 
-Alt+0 (and command+0 on OSX)
+Alt+0 (and command+0 on macOS)
     Resize video window to half its original size.
 
-Alt+1 (and command+1 on OSX)
+Alt+1 (and command+1 on macOS)
     Resize video window to its original size.
 
-Alt+2 (and command+2 on OSX)
+Alt+2 (and command+2 on macOS)
     Resize video window to double its original size.
 
-command + f (OSX only)
+command + f (macOS only)
     Toggle fullscreen (see also ``--fs``).
 
 (The following keys are valid if you have a keyboard with multimedia keys.)
@@ -390,6 +390,9 @@ It is started with ``%`` and has the following format::
 
     ``mpv --vf=foo:option1=%`expr length "$NAME"`%"$NAME" test.avi``
 
+Note: where applicable with JSON-IPC, ``%n%`` is the length in UTF-8 bytes,
+after decoding the JSON data.
+
 Suboptions passed to the client API are also subject to escaping. Using
 ``mpv_set_option_string()`` is exactly like passing ``--name=data`` to the
 command line (but without shell processing of the string). Some options
@@ -439,8 +442,8 @@ Name             Meaning
 ``~/``           user home directory root (similar to shell, ``$HOME``)
 ``~~home/``      same as ``~~/``
 ``~~global/``    the global config path, if available (not on win32)
-``~~osxbundle/`` the OSX bundle resource path (OSX only)
-``~~desktop/``   the path to the desktop (win32, OSX)
+``~~osxbundle/`` the macOS bundle resource path (macOS only)
+``~~desktop/``   the path to the desktop (win32, macOS)
 ``~~exe_dir``    win32 only: the path to the directory containing the exe (for
                  config file purposes; ``$MPV_HOME`` overrides it)
 ``~~old_home``   do not use
@@ -511,7 +514,7 @@ They support the following operations:
 ============= ===============================================
 Suffix        Meaning
 ============= ===============================================
--set          Set a list of items (using the list separator, interprets escapes)
+-set          Set a list of items (using the list separator, escaped with backslash)
 -append       Append single item (does not interpret escapes)
 -add          Append 1 or more items (same syntax as -set)
 -pre          Prepend 1 or more items (same syntax as -set)
@@ -781,9 +784,11 @@ ignored. This Lua code execution is not sandboxed.
 
 Any variables in condition expressions can reference properties. If an
 identifier is not already defined by Lua or mpv, it is interpreted as property.
-For example, ``pause`` would return the current pause status. If the variable
-name contains any ``_`` characters, they are turned into ``-``. For example,
-``playback_time`` would return the property ``playback-time``.
+For example, ``pause`` would return the current pause status. You cannot
+reference properties with ``-`` this way since that would denote a subtraction,
+but if the variable name contains any ``_`` characters, they are turned into
+``-``. For example, ``playback_time`` would return the property
+``playback-time``.
 
 A more robust way to access properties is using ``p.property_name`` or
 ``get("property-name", default_value)``. The automatic variable to property
@@ -1260,7 +1265,7 @@ Currently this happens only in the following cases:
   or file associations provided by desktop environments)
 - if started from explorer.exe on Windows (technically, if it was started on
   Windows, and all of the stdout/stderr/stdin handles are unset)
-- started out of the bundle on OSX
+- started out of the bundle on macOS
 - if you manually use ``--player-operation-mode=pseudo-gui`` on the command line
 
 This mode applies options from the builtin profile ``builtin-pseudo-gui``, but
@@ -1298,7 +1303,7 @@ Linux desktop issues
 ====================
 
 This subsection describes common problems on the Linux desktop. None of these
-problems exist on systems like Windows or OSX.
+problems exist on systems like Windows or macOS.
 
 Disabling Screensaver
 ---------------------
diff --git a/DOCS/man/options.rst b/DOCS/man/options.rst
index 50ff3ec..712af52 100644
--- a/DOCS/man/options.rst
+++ b/DOCS/man/options.rst
@@ -56,7 +56,7 @@ Track Selection
         behavior tends to change around with each mpv release.
 
         The track selection properties will return the option value outside of
-        playback (as expected), but during playbac, the affective track
+        playback (as expected), but during playback, the affective track
         selection is returned. For example, with ``--aid=auto``, the ``aid``
         property will suddenly return ``2`` after playback initialization
         (assuming the file has at least 2 audio tracks, and the second is the
@@ -213,7 +213,7 @@ Playback Control
     Slow down or speed up playback by the factor given as parameter.
 
     If ``--audio-pitch-correction`` (on by default) is used, playing with a
-    speed higher than normal automatically inserts the ``scaletempo`` audio
+    speed higher than normal automatically inserts the ``scaletempo2`` audio
     filter.
 
 ``--pause``
@@ -392,6 +392,13 @@ Playback Control
     difference between the two option is that this option performs a seek on
     loop, instead of reloading the file.
 
+    .. note::
+
+        ``--loop-file`` counts the number of times it causes the player to
+        seek to the beginning of the file, not the number of full playthroughs. This
+        means ``--loop-file=1`` will end up playing the file twice. Contrast with
+        ``--loop-playlist``, which counts the number of full playthroughs.
+
     ``--loop`` is an alias for this option.
 
 ``--ab-loop-a=<time>``, ``--ab-loop-b=<time>``
@@ -1196,9 +1203,9 @@ Video
     :vdpau-copy: copies video back into system RAM (Linux with some GPUs only)
     :vaapi:     requires ``--vo=gpu`` or ``--vo=vaapi`` (Linux only)
     :vaapi-copy: copies video back into system RAM (Linux with some GPUs only)
-    :videotoolbox: requires ``--vo=gpu`` (OS X 10.8 and up),
+    :videotoolbox: requires ``--vo=gpu`` (macOS 10.8 and up),
                    or ``--vo=libmpv`` (iOS 9.0 and up)
-    :videotoolbox-copy: copies video back into system RAM (OS X 10.8 or iOS 9.0 and up)
+    :videotoolbox-copy: copies video back into system RAM (macOS 10.8 or iOS 9.0 and up)
     :dxva2:     requires ``--vo=gpu`` with ``--gpu-context=d3d11``,
                 ``--gpu-context=angle`` or ``--gpu-context=dxinterop``
                 (Windows only)
@@ -1477,11 +1484,14 @@ Video
     This option is disabled if the ``--no-keepaspect`` option is used.
 
 ``--video-rotate=<0-359|no>``
-    Rotate the video clockwise, in degrees. Currently supports 90° steps only.
-    If ``no`` is given, the video is never rotated, even if the file has
-    rotation metadata. (The rotation value is added to the rotation metadata,
-    which means the value ``0`` would rotate the video according to the
-    rotation metadata.)
+    Rotate the video clockwise, in degrees. If ``no`` is given, the video is
+    never rotated, even if the file has rotation metadata. (The rotation value
+    is added to the rotation metadata, which means the value ``0`` would rotate
+    the video according to the rotation metadata.)
+
+    When using hardware decoding without copy-back, only 90° steps work, while
+    software decoding and hardware decoding methods that copy the video back to
+    system memory support all values between 0 and 359.
 
 ``--video-zoom=<value>``
     Adjust the video display scale factor by the given value. The parameter is
@@ -1606,7 +1616,7 @@ Video
     You can get the list of allowed codecs with ``mpv --vd=help``. Remove the
     prefix, e.g. instead of ``lavc:h264`` use ``h264``.
 
-    By default, this is set to ``h264,vc1,hevc,vp9,av1``. Note that
+    By default, this is set to ``h264,vc1,hevc,vp8,vp9,av1``. Note that
     the hardware acceleration special codecs like ``h264_vdpau`` are not
     relevant anymore, and in fact have been removed from Libav in this form.
 
@@ -1739,7 +1749,7 @@ Audio
 
 ``--audio-pitch-correction=<yes|no>``
     If this is enabled (default), playing with a speed different from normal
-    automatically inserts the ``scaletempo`` audio filter. For details, see
+    automatically inserts the ``scaletempo2`` audio filter. For details, see
     audio filter section.
 
 ``--audio-device=<name>``
@@ -2091,7 +2101,7 @@ Audio
 
     :no:    Don't automatically load external audio files (default).
     :exact: Load the media filename with audio file extension.
-    :fuzzy: Load all audio files containing media filename.
+    :fuzzy: Load all audio files containing the media filename.
     :all:   Load all audio files in the current and ``--audio-file-paths``
             directories.
 
@@ -2471,7 +2481,7 @@ Subtitles
     :no:    Don't automatically load external subtitle files.
     :exact: Load the media filename with subtitle file extension and possibly
             language suffixes (default).
-    :fuzzy: Load all subs containing media filename.
+    :fuzzy: Load all subs containing the media filename.
     :all:   Load all subs in the current and ``--sub-file-paths`` directories.
 
 ``--sub-codepage=<codepage>``
@@ -2587,6 +2597,13 @@ Subtitles
     This works for ``dvb_teletext`` subtitle streams, and if FFmpeg has been
     compiled with support for it.
 
+``--sub-past-video-end``
+    After the last frame of video, if this option is enabled, subtitles will
+    continue to update based on audio timestamps. Otherwise, the subtitles
+    for the last video frame will stay onscreen.
+
+    Default: disabled
+
 ``--sub-font=<name>``
     Specify font to use for subtitles that do not themselves
     specify a particular font. The default is ``sans-serif``.
@@ -2799,7 +2816,7 @@ Subtitles
 ``--sub-font-provider=<auto|none|fontconfig>``
     Which libass font provider backend to use (default: auto). ``auto`` will
     attempt to use the native font provider: fontconfig on Linux, CoreText on
-    OSX, DirectWrite on Windows. ``fontconfig`` forces fontconfig, if libass
+    macOS, DirectWrite on Windows. ``fontconfig`` forces fontconfig, if libass
     was built with support (if not, it behaves like ``none``).
 
     The ``none`` font provider effectively disables system fonts. It will still
@@ -2839,6 +2856,12 @@ Window
 
     See also ``--fs-screen``.
 
+``--screen-name=<string>``
+    In multi-monitor configurations, this option tells mpv which screen to
+    display the video on based on the screen name from the video backend. The
+    same caveats in the ``--screen`` option also apply here. This option is
+    ignored and does nothing if ``--screen`` is explicitly set.
+
 ``--fullscreen``, ``--fs``
     Fullscreen playback.
 
@@ -2853,12 +2876,18 @@ Window
         This option works properly only with window managers which
         understand the EWMH ``_NET_WM_FULLSCREEN_MONITORS`` hint.
 
-    .. admonition:: Note (OS X)
+    .. admonition:: Note (macOS)
 
-        ``all`` does not work on OS X and will behave like ``current``.
+        ``all`` does not work on macOS and will behave like ``current``.
 
     See also ``--screen``.
 
+``--fs-screen-name=<string>``
+    In multi-monitor configurations, this option tells mpv which screen to go
+    fullscreen to based on the screen name from the video backend. The same
+    caveats in the ``--fs-screen`` option also apply here. This option is
+    ignored and does nothing if ``--fs-screen`` is explicitly set.
+
 ``--keep-open=<yes|no|always>``
     Do not terminate when playing or seeking beyond the end of the file, and
     there is not next file to be played (and ``--loop`` is not used).
@@ -2956,7 +2985,7 @@ Window
     Manager.
 
 ``--ontop-level=<window|system|desktop|level>``
-    (OS X only)
+    (macOS only)
     Sets the level of an ontop window (default: window).
 
     :window:  On top of all other windows.
@@ -2973,14 +3002,8 @@ Window
     Play video with window border and decorations. Since this is on by
     default, use ``--no-border`` to disable the standard window decorations.
 
-``--fit-border``, ``--no-fit-border``
-    (Windows only) Fit the whole window with border and decorations on the
-    screen. Since this is on by default, use ``--no-fit-border`` to make mpv
-    try to only fit client area with video on the screen. This behavior only
-    applied to window/video with size exceeding size of the screen.
-
 ``--on-all-workspaces``
-    (X11 only)
+    (X11 and macOS only)
     Show the video window on all virtual desktops.
 
 ``--geometry=<[W[xH]][+-x+-y][/WS]>``, ``--geometry=<x:y>``
@@ -3006,9 +3029,9 @@ Window
 
         Generally only supported by GUI VOs. Ignored for encoding.
 
-    .. admonition: Note (OS X)
+    .. admonition: Note (macOS)
 
-        On Mac OS X the origin of the screen coordinate system is located on the
+        On macOS, the origin of the screen coordinate system is located on the
         bottom-left corner. For instance, ``0:0`` will place the window at the
         bottom-left of the screen.
 
@@ -3176,14 +3199,14 @@ Window
         - ``--monitoraspect=16:9`` or ``--monitoraspect=1.7777``
 
 ``--hidpi-window-scale``, ``--no-hidpi-window-scale``
-    (OS X, Windows, X11, and Wayland only)
+    (macOS, Windows, X11, and Wayland only)
     Scale the window size according to the backing scale factor (default: yes).
     On regular HiDPI resolutions the window opens with double the size but appears
-    as having the same size as on non-HiDPI resolutions. This is the default OS X
-    behavior.
+    as having the same size as on non-HiDPI resolutions. This is enabled by
+    default on macOS.
 
 ``--native-fs``, ``--no-native-fs``
-    (OS X only)
+    (macOS only)
     Uses the native fullscreen mechanism of the OS (default: yes).
 
 ``--monitorpixelaspect=<ratio>``
@@ -3216,8 +3239,8 @@ Window
     ``intptr_t``. mpv will create its own window, and set the wid window as
     parent, like with X11.
 
-    On OSX/Cocoa, the ID is interpreted as ``NSView*``. Pass it as value cast
-    to ``intptr_t``. mpv will create its own sub-view. Because OSX does not
+    On macOS/Cocoa, the ID is interpreted as ``NSView*``. Pass it as value cast
+    to ``intptr_t``. mpv will create its own sub-view. Because macOS does not
     support window embedding of foreign processes, this works only with libmpv,
     and will crash when used from the command line.
 
@@ -3699,15 +3722,17 @@ Demuxer
 
 ``--prefetch-playlist=<yes|no>``
     Prefetch next playlist entry while playback of the current entry is ending
-    (default: no). This merely opens the URL of the next playlist entry as soon
-    as the current URL is fully read.
+    (default: no).
+
+    This does not prefill the cache with the video data of the next URL.
+    Prefetching video data is supported only for the current playlist entry,
+    and depends on the demuxer cache settings (on by default). This merely
+    opens the URL of the next playlist entry as soon the current URL is fully
+    read.
 
     This does **not** work with URLs resolved by the ``youtube-dl`` wrapper,
     and it won't.
 
-    This does not affect HLS (``.m3u8`` URLs) - HLS prefetching depends on the
-    demuxer cache settings and is on by default.
-
     This can give subtly wrong results if per-file options are used, or if
     options are changed in the time window between prefetching start and next
     file played.
@@ -3764,7 +3789,10 @@ Input
     configuration directory (usually ``~/.config/mpv/input.conf``).
 
 ``--no-input-default-bindings``
-    Disable mpv default (built-in) key bindings.
+    Disable mpv default (built-in) key bindings. Currently this includes all
+    key bindings which ``input.conf`` can override, like those added by scripts
+    using ``mp.add_key_binding`` (but not ``mp.add_forced_key_binding``).
+    This might change in the future to exclude ``mp.add_key_binding``.
 
 ``--input-cmdlist``
     Prints all commands that can be bound to keys.
@@ -3852,7 +3880,7 @@ Input
     Support depends on the VO in use.
 
 ``--input-media-keys=<yes|no>``
-    (OS X and Windows only)
+    (macOS and Windows only)
     Enable/disable media keys support. Enabled by default (except for libmpv).
 
 ``--input-right-alt-gr``, ``--no-input-right-alt-gr``
@@ -4555,12 +4583,6 @@ Cache
     Turn off input stream caching. See ``--cache``.
 
 ``--cache-secs=<seconds>``
-    Deprecated. Once this option is removed, there will be no way to limit the
-    cache size by time (only by size with ``--demuxer-max-bytes``). This option
-    is considered useless, since there is no good reason to limit the cache by
-    time, and the default value of this option is already something very high.
-    The interaction with the other cache options is also confusing.
-
     How many seconds of audio/video to prefetch if the cache is active. This
     overrides the ``--demuxer-readahead-secs`` option if and only if the cache
     is enabled and the value is larger. The default value is set to something
@@ -5159,18 +5181,29 @@ The following video options are currently all specific to ``--vo=gpu`` and
 
 ``--interpolation-threshold=<0..1,-1>``
     Threshold below which frame ratio interpolation gets disabled (default:
-    ``0.0001``). This is calculated as ``abs(disphz/vfps - 1) < threshold``,
+    ``0.01``). This is calculated as ``abs(disphz/vfps - 1) < threshold``,
     where ``vfps`` is the speed-adjusted video FPS, and ``disphz`` the
     display refresh rate. (The speed-adjusted video FPS is roughly equal to
     the normal video FPS, but with slowdown and speedup applied. This matters
     if you use ``--video-sync=display-resample`` to make video run synchronously
     to the display FPS, or if you change the ``speed`` property.)
 
-    The default is intended to almost always enable interpolation if the
-    playback rate is even slightly different from the display refresh rate. But
-    note that if you use e.g. ``--video-sync=display-vdrop``, small deviations
-    in the rate can disable interpolation and introduce a discontinuity every
-    other minute.
+    The default is intended to enable interpolation in scenarios where
+    retiming with the ``--video-sync=display-*`` cannot adjust the speed of
+    the video sufficiently for smooth playback. For example if a video is
+    60.00 FPS and your display refresh rate is 59.94 Hz, interpolation will
+    never be activated, since the mismatch is within 1% of the refresh
+    rate. The default also handles the scenario when mpv cannot determine the
+    container FPS, such as during certain live streams, and may dynamically
+    toggle interpolation on and off. In this scenario, the default would be to
+    not use interpolation but rather to allow ``--video-sync=display-*`` to
+    retime the video to match display refresh rate. See
+    ``--video-sync-max-video-change`` for more information about how mpv
+    will retime video.
+
+    Also note that if you use e.g. ``--video-sync=display-vdrop``, small
+    deviations in the rate can disable interpolation and introduce a
+    discontinuity every other minute.
 
     Set this to ``-1`` to disable this logic.
 
@@ -5263,6 +5296,12 @@ The following video options are currently all specific to ``--vo=gpu`` and
     results, as can missing or incorrect display FPS information (see
     ``--override-display-fps``).
 
+``--vulkan-device=<device name>``
+    The name of the Vulkan device to use for rendering and presentation. Use
+    ``--vulkan-device=help`` to see the list of available devices and their
+    names. If left unspecified, the first enumerated hardware Vulkan device will
+    be used.
+
 ``--vulkan-swap-mode=<mode>``
     Controls the presentation mode of the vulkan swapchain. This is similar
     to the ``--opengl-swapinterval`` option.
@@ -5307,6 +5346,25 @@ The following video options are currently all specific to ``--vo=gpu`` and
     with some older drivers / vulkan portability layers that don't provide
     working VkEvent support.
 
+``--vulkan-display-display=<n>``
+    The index of the display, on the selected Vulkan device, to present on when
+    using the ``displayvk`` GPU context. Use ``--vulkan-display-display=help``
+    to see the list of available displays. If left unspecified, the first
+    enumerated display will be used.
+
+
+``--vulkan-display-mode=<n>``
+    The index of the display mode, of the selected Vulkan display, to use when
+    using the ``displayvk`` GPU context. Use ``--vulkan-display-mode=help``
+    to see the list of available modes. If left unspecified, the first
+    enumerated mode will be used.
+
+``--vulkan-display-plane=<n>``
+    The index of the plane, on the selected Vulkan device, to present on when
+    using the ``displayvk`` GPU context. Use ``--vulkan-display-plane=help``
+    to see the list of available planes. If left unspecified, the first
+    enumerated plane will be used.
+
 ``--d3d11-exclusive-fs=<yes|no>``
     Switches the D3D11 swap chain fullscreen state to 'fullscreen' when
     fullscreen video is requested. Also known as "exclusive fullscreen" or
@@ -5388,8 +5446,7 @@ The following video options are currently all specific to ``--vo=gpu`` and
     Currently only relevant for ``--gpu-api=d3d11``.
 
 ``--wayland-app-id=<string>``
-    Set the client app id for Wayland-based video output methods. By default, "mpv"
-    is used.
+    Set the client app id for Wayland-based video output methods (default: ``mpv``).
 
 ``--wayland-disable-vsync=<yes|no>``
     Disable vsync for the wayland contexts (default: no). Useful for benchmarking
@@ -5684,7 +5741,7 @@ The following video options are currently all specific to ``--vo=gpu`` and
 ``--deband-threshold=<0..4096>``
     The debanding filter's cut-off threshold. Higher numbers increase the
     debanding strength dramatically but progressively diminish image details.
-    (Default 64)
+    (Default 32)
 
 ``--deband-range=<1..64>``
     The debanding filter's initial radius. The radius increases linearly for
@@ -5794,7 +5851,7 @@ The following video options are currently all specific to ``--vo=gpu`` and
     Deactivates the automatic graphics switching and forces the dedicated GPU.
     (default: no)
 
-    OS X only.
+    macOS only.
 
 ``--cocoa-cb-sw-renderer=<yes|no|auto>``
     Use the Apple Software Renderer when using cocoa-cb (default: auto). If set
@@ -5803,14 +5860,14 @@ The following video options are currently all specific to ``--vo=gpu`` and
     software renderer, and ``auto`` only falls back to the software renderer
     when the usual pixel format couldn't be created.
 
-    OS X only.
+    macOS only.
 
 ``--cocoa-cb-10bit-context=<yes|no>``
     Creates a 10bit capable pixel format for the context creation (default: yes).
     Instead of 8bit integer framebuffer a 16bit half-float framebuffer is
     requested.
 
-    OS X only.
+    macOS only.
 
 ``--macos-title-bar-appearance=<appearance>``
     Sets the appearance of the title bar (default: auto). Not all combinations
@@ -5891,7 +5948,7 @@ The following video options are currently all specific to ``--vo=gpu`` and
     1000ms since it's possible that Apple or the user changes the system
     defaults. Anything higher than 1000ms though seems too long and shouldn't be
     set anyway.
-    OS X and cocoa-cb only
+    (macOS and cocoa-cb only)
 
 
 ``--macos-app-activation-policy=<regular|accessory|prohibited>``
@@ -5900,6 +5957,16 @@ The following video options are currently all specific to ``--vo=gpu`` and
 
     macOS only.
 
+``--macos-geometry-calculation=<visible|whole>``
+    This changes the rectangle which is used to calculate the screen position
+    and size of the window (default: visible). ``visible`` takes the the menu
+    bar and Dock into account and the window is only positioned/sized within the
+    visible screen frame rectangle, ``whole`` takes the whole screen frame
+    rectangle and ignores the menu bar and Dock. Other previous restrictions
+    still apply, like the window can't be placed on top of the menu bar etc.
+
+    macOS only.
+
 ``--android-surface-size=<WxH>``
     Set dimensions of the rendering surface used by the Android gpu context.
     Needs to be set by the embedding application if the dimensions change during
@@ -5918,7 +5985,7 @@ The following video options are currently all specific to ``--vo=gpu`` and
     auto
         auto-select (default)
     cocoa
-        Cocoa/OS X (deprecated, use --vo=libmpv instead)
+        Cocoa/macOS (deprecated, use --vo=libmpv instead)
     win
         Win32/WGL
     winvk
@@ -5943,6 +6010,10 @@ The following video options are currently all specific to ``--vo=gpu`` and
         VK_KHR_wayland_surface
     drm
         DRM/EGL
+    displayvk
+        VK_KHR_display. This backend is roughly the Vukan equivalent of
+        DRM/EGL, allowing for direct rendering via Vulkan without a display
+        manager.
     x11egl
         X11/EGL
     android
@@ -6013,7 +6084,7 @@ The following video options are currently all specific to ``--vo=gpu`` and
     With ambient illuminance of 16 lux, mpv will pick the 1.0 gamma value (no
     boost), and slightly increase the boost up until 1.2 for 256 lux.
 
-    NOTE: Only implemented on OS X.
+    NOTE: Only implemented on macOS.
 
 ``--target-prim=<value>``
     Specifies the primaries of the display. Video colors will be adapted to
@@ -6322,14 +6393,15 @@ The following video options are currently all specific to ``--vo=gpu`` and
     Size of the 3D LUT generated from the ICC profile in each dimension.
     Default is 64x64x64. Sizes may range from 2 to 512.
 
-``--icc-contrast=<0-1000000|inf>``
-    Specifies an upper limit on the target device's contrast ratio. This is
-    detected automatically from the profile if possible, but for some profiles
-    it might be missing, causing the contrast to be assumed as infinite. As a
-    result, video may appear darker than intended. This only affects BT.1886
-    content. The default of 0 means no limit if the detected contrast is less
-    than 100000, and limits to 1000 otherwise. Use ``--icc-contrast=inf`` to
-    preserve the infinite contrast (most likely when using OLED displays).
+``--icc-force-contrast=<no|0-1000000|inf>``
+    Override the target device's detected contrast ratio by a specific value.
+    This is detected automatically from the profile if possible, but for some
+    profiles it might be missing, causing the contrast to be assumed as
+    infinite. As a result, video may appear darker than intended. If this is
+    the case, setting this option might help. This only affects BT.1886
+    content. The default of ``no`` means to use the profile values. The special
+    value ``inf`` causes the BT.1886 curve to be treated as a pure power gamma
+    2.4 function.
 
 ``--blend-subtitles=<yes|video|no>``
     Blend subtitles directly onto upscaled video frames, before interpolation
@@ -6362,13 +6434,13 @@ The following video options are currently all specific to ``--vo=gpu`` and
         black).
     yes
         Try to create a framebuffer with alpha component. This only makes sense
-        if the video contains alpha information (which is extremely rare). May
-        not be supported on all platforms. If alpha framebuffers are
-        unavailable, it silently falls back on a normal framebuffer. Note that
-        if you set the ``--fbo-format`` option to a non-default value, a
-        format with alpha must be specified, or this won't work.
-        Whether this really works depends on the windowing system and desktop
-        environment.
+        if the video contains alpha information (which is extremely rare) or if
+        you make the background color transparent. May not be supported on all
+        platforms. If alpha framebuffers are unavailable, it silently falls
+        back on a normal framebuffer. Note that if you set the ``--fbo-format``
+        option to a non-default value, a format with alpha must be specified,
+        or this won't work. Whether this really works depends on the windowing
+        system and desktop environment.
     no
         Ignore alpha component.
 
@@ -6395,7 +6467,7 @@ The following video options are currently all specific to ``--vo=gpu`` and
     flipping GL front and backbuffers immediately (i.e. it doesn't call it
     in display-sync mode).
 
-    On OSX this is always deactivated because it only causes performance
+    On macOS this is always deactivated because it only causes performance
     problems and other regressions.
 
 ``--gpu-dumb-mode=<yes|no|auto>``
@@ -6530,11 +6602,10 @@ Miscellaneous
                         video. (Although it should have the same effects as
                         ``audio``, the implementation is very different.)
     :display-adrop:     Drop or repeat audio data to compensate desyncing
-                        video. See ``--video-sync-adrop-size``. This mode will
-                        cause severe audio artifacts if the real monitor
-                        refresh rate is too different from the reported or
-                        forced rate. Since mpv 0.33.0, this acts on entire audio
-                        frames, instead of single samples.
+                        video. This mode will cause severe audio artifacts if
+                        the real monitor refresh rate is too different from
+                        the reported or forced rate. Since mpv 0.33.0, this
+                        acts on entire audio frames, instead of single samples.
     :display-desync:    Sync video to display, and let audio play on its own.
     :desync:            Sync video according to system clock, and let audio play
                         on its own.
@@ -6547,6 +6618,9 @@ Miscellaneous
     multiple of the display FPS, as long as the speed change does not exceed
     the value set by ``--video-sync-max-video-change``.
 
+    See ``--interpolation-threshold`` for how this option affects
+    interpolation.
+
     This is mostly for testing, and the option may be randomly changed in the
     future without notice.
 
@@ -6655,12 +6729,15 @@ Miscellaneous
     option will add a new external file.
 
 ``--cover-art-auto=<no|fuzzy>``
-    Whether to load _external_ cover art automatically (default: fuzzy). Similar
-    to ``--sub-auto`` and ``--audio-file-auto``. However, it's currently limited
-    to picking up a whitelist of "album art" filenames (such as ``cover.jpg``),
-    so currently only the ``fuzzy`` choice is available. In addition, if a video
-    already has tracks (which are not marked as cover art), external cover art
-    will not be loaded.
+    Whether to load _external_ cover art automatically. Similar to
+    ``--sub-auto`` and ``--audio-file-auto``. If a video already has tracks
+    (which are not marked as cover art), external cover art will not be loaded.
+
+    :no:    Don't automatically load cover art.
+    :exact: Load the media filename with an image file extension.
+    :fuzzy: Load all cover art containing the media filename and filenames
+            in an internal whitelist, such as ``cover.jpg`` (default).
+    :all:   Load all images in the current directory.
 
     See ``--cover-art-files`` for details about what constitutes cover art.
 
@@ -6671,8 +6748,9 @@ Miscellaneous
     Automatically load/select external files (default: yes).
 
     If set to ``no``, then do not automatically load external files as specified
-    by ``--sub-auto`` and ``--audio-file-auto``. If external files are forcibly
-    added (like with ``--sub-files``), they will not be auto-selected.
+    by ``--sub-auto``, ``--audio-file-auto`` and ``--cover-art-auto``. If
+    external files are forcibly added (like with ``--sub-files``), they will
+    not be auto-selected.
 
     This does not affect playlist expansion, redirection, or other loading of
     referenced files like with ordered chapters.
diff --git a/DOCS/man/osc.rst b/DOCS/man/osc.rst
index eabc230..71af9d2 100644
--- a/DOCS/man/osc.rst
+++ b/DOCS/man/osc.rst
@@ -43,7 +43,8 @@ pl next
     =============   ================================================
 
 title
-    | Displays current media-title, filename, or custom title
+    | Displays current media-title, filename, custom title, or target chapter
+      name while hovering the seekbar.
 
     =============   ================================================
     left-click      show playlist position and length and full title
@@ -179,12 +180,12 @@ Configurable Options
 ``seekbarkeyframes``
     Default: yes
 
-    Controls the mode used to seek when dragging the seekbar (default: true). If
-    set to true, default seeking mode is used (usually keyframes, but player
-    defaults and heuristics can change it to exact). If set to false, exact
-    seeking on mouse drags will be used instead. Keyframes are preferred, but
-    exact seeks may be useful in cases where keyframes cannot be found. Note
-    that using exact seeks can potentially make mouse dragging much slower.
+    Controls the mode used to seek when dragging the seekbar. If set to ``yes``,
+    default seeking mode is used (usually keyframes, but player defaults and
+    heuristics can change it to exact). If set to ``no``, exact seeking on
+    mouse drags will be used instead. Keyframes are preferred, but exact seeks
+    may be useful in cases where keyframes cannot be found. Note that using
+    exact seeks can potentially make mouse dragging much slower.
 
 ``seekrangestyle``
     Default: inverted
@@ -375,6 +376,12 @@ Configurable Options
 
     Set to ``yes`` to reduce festivity (i.e. disable santa hat in December.)
 
+``livemarkers``
+    Default: yes
+
+    Update chapter markers positions on duration changes, e.g. live streams.
+    The updates are unoptimized - consider disabling it on very low-end systems.
+
 Script Commands
 ~~~~~~~~~~~~~~~
 
diff --git a/DOCS/man/vf.rst b/DOCS/man/vf.rst
index 3797ad2..e07360b 100644
--- a/DOCS/man/vf.rst
+++ b/DOCS/man/vf.rst
@@ -310,7 +310,7 @@ Available mpv-only filters are:
 
     ``<stereo-in>``
         Set the stereo mode the video is assumed to be encoded in. Use
-        ``--vf format:stereo-in=help`` to list all available modes. Check with
+        ``--vf=format:stereo-in=help`` to list all available modes. Check with
         the ``stereo3d`` filter documentation to see what the names mean.
 
     ``<stereo-out>``
diff --git a/DOCS/man/vo.rst b/DOCS/man/vo.rst
index 833fbdd..d8aefd8 100644
--- a/DOCS/man/vo.rst
+++ b/DOCS/man/vo.rst
@@ -253,7 +253,7 @@ Available video output drivers are:
     quality or performance by changing the ``--fbo-format`` option to
     ``rgb16f``, ``rgb32f`` or ``rgb``. Known problems include Mesa/Intel not
     accepting ``rgb16``, Mesa sometimes not being compiled with float texture
-    support, and some OS X setups being very slow with ``rgb16`` but fast
+    support, and some macOS setups being very slow with ``rgb16`` but fast
     with ``rgb32f``. If you have problems, you can also try enabling the
     ``--gpu-dumb-mode=yes`` option.
 
@@ -413,18 +413,22 @@ Available video output drivers are:
         to take into account padding at the report - this only works correctly
         when the overall padding per axis is smaller than the number of cells.
 
+    ``--vo-sixel-exit-clear=<yes|no>`` (default: yes)
+        Whether or not to clear the terminal on quit. When set to no - the last
+        sixel image stays on screen after quit, with the cursor following it.
+
     Sixel image quality options:
 
     ``--vo-sixel-dither=<algo>``
         Selects the dither algorithm which libsixel should apply.
         Can be one of the below list as per libsixel's documentation.
 
-        auto
-            Choose diffuse type automatically
+        auto (Default)
+            Let libsixel choose the dithering method.
         none
             Don't diffuse
         atkinson
-            Diffuse with Bill Atkinson's method. (Default)
+            Diffuse with Bill Atkinson's method.
         fs
             Diffuse with Floyd-Steinberg method
         jajuni
@@ -444,20 +448,18 @@ Available video output drivers are:
         using ``no`` (at the time of writing) will slow down ``xterm``.
 
     ``--vo-sixel-reqcolors=<colors>`` (default: 256)
-        Set up libsixel to use required number of colors for dynamic palette.
-        This value depends on the terminal emulator as well. Xterm supports
-        256 colors.  Can set this to a lower value for faster performance.
-        This option has no effect if fixed palette is used.
+        Has no effect with fixed palette. Set up libsixel to use required
+        number of colors for dynamic palette. This value depends on the
+        terminal emulator as well. Xterm supports 256 colors. Can set this to
+        a lower value for faster performance.
 
     ``--vo-sixel-threshold=<threshold>`` (default: -1)
-        When using a dynamic palette, defines the threshold to change the
+        Has no effect with fixed palette. Defines the threshold to change the
         palette - as percentage of the number of colors, e.g. 20 will change
         the palette when the number of colors changed by 20%. It's a simple
         measure to reduce the number of palette changes, because it can be slow
-        in some terminals (``xterm``), however, it seems that in ``mlterm`` it
-        causes image corruption. The default (-1) will change the palette
-        on every frame and will have better quality, and no corruption in
-        ``mlterm``.
+        in some terminals (``xterm``). The default (-1) will choose a palette
+        on every frame and will have better quality.
 
 ``image``
     Output each frame into an image file in the current directory. Each file
@@ -496,7 +498,7 @@ Available video output drivers are:
         Specify the directory to save the image files to (default: ``./``).
 
 ``libmpv``
-    For use with libmpv direct embedding. As a special case, on OS X it
+    For use with libmpv direct embedding. As a special case, on macOS it
     is used like a normal VO within mpv (cocoa-cb). Otherwise useless in any
     other contexts.
     (See ``<mpv/render.h>``.)
diff --git a/README.md b/README.md
index 8cc3dc3..6625c33 100644
--- a/README.md
+++ b/README.md
@@ -121,9 +121,9 @@ Libass dependencies (when building libass):
 
 - gcc or clang, yasm on x86 and x86_64
 - fribidi, freetype, fontconfig development headers (for libass)
-- harfbuzz (optional, required for correct rendering of combining characters,
-  particularly for correct rendering of non-English text on OSX, and
-  Arabic/Indic scripts on any platform)
+- harfbuzz (required for correct rendering of combining characters, particularly
+  for correct rendering of non-English text on OSX, and Arabic/Indic scripts on
+  any platform)
 
 FFmpeg dependencies (when building FFmpeg):
 
@@ -181,7 +181,7 @@ changes come and talk to us on IRC before you start working on them. It will
 make code review easier for both parties later on.
 
 You can check [the wiki](https://github.com/mpv-player/mpv/wiki/Stuff-to-do)
-or the [issue tracker](https://github.com/mpv-player/mpv/issues?q=is%3Aopen+is%3Aissue+label%3A%22feature+request%22)
+or the [issue tracker](https://github.com/mpv-player/mpv/issues?q=is%3Aopen+is%3Aissue+label%3Ameta%3Afeature-request)
 for ideas on what you could contribute with.
 
 ## License
@@ -201,8 +201,8 @@ see the [FAQ][FAQ].
 Most activity happens on the IRC channel and the github issue tracker.
 
 - **GitHub issue tracker**: [issue tracker][issue-tracker] (report bugs here)
-- **User IRC Channel**: `#mpv` on `irc.freenode.net`
-- **Developer IRC Channel**: `#mpv-devel` on `irc.freenode.net`
+- **User IRC Channel**: `#mpv` on `irc.libera.chat`
+- **Developer IRC Channel**: `#mpv-devel` on `irc.libera.chat`
 
 [FAQ]: https://github.com/mpv-player/mpv/wiki/FAQ
 [releases]: https://github.com/mpv-player/mpv/releases
diff --git a/RELEASE_NOTES b/RELEASE_NOTES
index 6c1d643..b006055 100644
--- a/RELEASE_NOTES
+++ b/RELEASE_NOTES
@@ -1,15 +1,3 @@
-Release 0.33.1
-==============
-
-Security fix release for the 0.30 branch. Users are advised to upgrade immediately.
-
-
-Fixes and Minor Enhancements
-----------------------------
-
-- demux_mf: improve format string processing
-
-
 Release 0.33.0
 ==============
 
@@ -164,7 +152,7 @@ This listing is not complete. Check DOCS/client-api-changes.rst for a history
 of changes to the client API, and DOCS/interface-changes.rst for a history
 of changes to other user-visible interfaces.
 
-A complete changelog can be seen by running `git log v0.32.0..v0.33.1`
+A complete changelog can be seen by running `git log v0.32.0..v0.33.0`
 in the git repository or by visiting either
-https://github.com/mpv-player/mpv/compare/v0.32.0...v0.33.1 or
-https://git.srsfckn.biz/mpv/log/?qt=range&q=v0.32.0..v0.33.1
+https://github.com/mpv-player/mpv/compare/v0.32.0...v0.33.0 or
+https://git.srsfckn.biz/mpv/log/?qt=range&q=v0.32.0..v0.33.0
diff --git a/TOOLS/appveyor-install.sh b/TOOLS/appveyor-install.sh
index 7b2473f..95e4f7b 100755
--- a/TOOLS/appveyor-install.sh
+++ b/TOOLS/appveyor-install.sh
@@ -23,6 +23,8 @@ pacman -S --noconfirm --needed \
     $MINGW_PACKAGE_PREFIX-lua51 \
     $MINGW_PACKAGE_PREFIX-ninja \
     $MINGW_PACKAGE_PREFIX-rubberband \
+    $MINGW_PACKAGE_PREFIX-shaderc \
+    $MINGW_PACKAGE_PREFIX-spirv-cross \
     $MINGW_PACKAGE_PREFIX-uchardet \
     $MINGW_PACKAGE_PREFIX-vulkan
 
@@ -50,23 +52,3 @@ pacman -Sc --noconfirm
         --enable-schannel
     make -j4 install
 )
-
-# Compile shaderc
-(
-    git clone --depth=1 https://github.com/google/shaderc && cd shaderc
-    "$PYTHON" utils/git-sync-deps
-
-    mkdir build && cd build
-    cmake -GNinja -DCMAKE_BUILD_TYPE=Release -DSHADERC_SKIP_TESTS=ON \
-          -DCMAKE_INSTALL_PREFIX=$MINGW_PREFIX ..
-    ninja install
-)
-
-# Compile SPIRV-Cross
-(
-    git clone --depth=1 https://github.com/KhronosGroup/SPIRV-Cross && cd SPIRV-Cross
-
-    mkdir build && cd build
-    cmake -GNinja -DSPIRV_CROSS_SHARED=ON -DCMAKE_INSTALL_PREFIX=$MINGW_PREFIX ..
-    ninja install
-)
diff --git a/TOOLS/lua/autoload.lua b/TOOLS/lua/autoload.lua
index 7150abb..aa7e46d 100644
--- a/TOOLS/lua/autoload.lua
+++ b/TOOLS/lua/autoload.lua
@@ -16,6 +16,7 @@ disabled=no
 images=no
 videos=yes
 audio=yes
+ignore_hidden=yes
 
 --]]
 
@@ -29,7 +30,8 @@ o = {
     disabled = false,
     images = true,
     videos = true,
-    audio = true
+    audio = true,
+    ignore_hidden = true
 }
 options.read_options(o)
 
@@ -155,7 +157,9 @@ function find_and_add_entries()
         return
     end
     table.filter(files, function (v, k)
-        if string.match(v, "^%.") then
+        -- The current file could be a hidden file, ignoring it doesn't load other
+        -- files from the current directory.
+        if (o.ignore_hidden and not (v == filename) and string.match(v, "^%.")) then
             return false
         end
         local ext = get_extension(v)
diff --git a/TOOLS/matroska.py b/TOOLS/matroska.py
index 2c1b751..d75c45a 100755
--- a/TOOLS/matroska.py
+++ b/TOOLS/matroska.py
@@ -21,8 +21,6 @@ Can also be used to directly parse Matroska files and display their contents.
 # License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-# for compatibility with Python 2.x
-from __future__ import print_function
 
 elements_ebml = (
     'EBML, 1a45dfa3, sub', (
@@ -300,8 +298,8 @@ parse_elems(elements_ebml, 'EBML')
 parse_elems(elements_matroska, 'MATROSKA')
 
 def printf(out, *args):
-    out.write(u' '.join([str(x) for x in args]))
-    out.write(u'\n')
+    out.write(' '.join(str(x) for x in args))
+    out.write('\n')
 
 def generate_C_header(out):
     printf(out, '// Generated by TOOLS/matroska.py, do not edit manually')
@@ -466,8 +464,6 @@ if __name__ == "__main__":
     elif sys.argv[1] == '--generate-definitions':
         generate_C_definitions(sys.stdout)
     else:
-        if sys.version_info.major < 3:
-            raise Exception("Dumping requires Python 3.")
         s = open(sys.argv[1], "rb")
         while 1:
             start = s.tell()
diff --git a/TOOLS/osxbundle/mpv.app/Contents/Info.plist b/TOOLS/osxbundle/mpv.app/Contents/Info.plist
index 8635a87..5fde0ac 100644
--- a/TOOLS/osxbundle/mpv.app/Contents/Info.plist
+++ b/TOOLS/osxbundle/mpv.app/Contents/Info.plist
@@ -188,6 +188,11 @@
     <string>${VERSION}</string>
     <key>NSHighResolutionCapable</key>
     <true/>
+    <key>LSEnvironment</key>
+    <dict>
+      <key>MallocNanoZone</key>
+      <string>0</string>
+    </dict>
     <key>CFBundleURLTypes</key>
     <array>
       <dict>
diff --git a/TOOLS/travis-rebuild-website b/TOOLS/travis-rebuild-website
index ecf3dae..802dded 100755
--- a/TOOLS/travis-rebuild-website
+++ b/TOOLS/travis-rebuild-website
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-if [ "x$TARGET" != "xx86_64-w64-mingw32" ]; then
+if [ "$TRAVIS_OS_NAME" != "linux" ] || [ "$CC" != "clang" ]; then
   # trigger build only on one of the matrix nodes
   exit;
 fi
diff --git a/TOOLS/umpv b/TOOLS/umpv
index 762e73a..2044e3e 100755
--- a/TOOLS/umpv
+++ b/TOOLS/umpv
@@ -31,8 +31,6 @@ import os
 import socket
 import errno
 import subprocess
-import fcntl
-import stat
 import string
 
 files = sys.argv[1:]
@@ -52,7 +50,7 @@ def make_abs(filename):
     if not is_url(filename):
         return os.path.abspath(filename)
     return filename
-files = [make_abs(f) for f in files]
+files = (make_abs(f) for f in files)
 
 SOCK = os.path.join(os.getenv("HOME"), ".umpv_socket")
 
diff --git a/VERSION b/VERSION
index 8df3f45..17d545a 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-0.33.1
+0.33.0-UNKNOWN
diff --git a/appveyor.yml b/appveyor.yml
index 92f229a..a385ac0 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -1,3 +1,5 @@
+image: Visual Studio 2019
+
 branches:
   only:
     - master
@@ -15,18 +17,8 @@ shallow_clone: true
 test: off
 
 install:
-  # Work around age/brokenness of Appveyor's msys2 by adding the new
-  # maintainer's keyring.
-  - bash -lc "curl -O http://repo.msys2.org/msys/x86_64/msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz"
-  - bash -lc "curl -O http://repo.msys2.org/msys/x86_64/msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz.sig"
-  - bash -lc "pacman-key --verify msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz.sig"
-  - bash -lc "pacman -U --noconfirm msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz"
-  # Support for Ada and Objective-C was removed from MSYS2. GCC won't update if
-  # these packages are installed.
-  - >-
-    C:\msys64\usr\bin\pacman -R --noconfirm --noprogressbar
-    mingw-w64-i686-gcc-ada mingw-w64-i686-gcc-objc mingw-w64-x86_64-gcc-ada
-    mingw-w64-x86_64-gcc-objc
+  # Disable checking disk space to speed up install time
+  - C:\msys64\usr\bin\sed -i 's/^CheckSpace/#CheckSpace/g' /etc/pacman.conf
   # Update core packages
   - C:\msys64\usr\bin\pacman -Syyuu --noconfirm --noprogressbar --ask=20
   # Explicitly kill any remaining msys2 processes after core update
diff --git a/audio/aframe.c b/audio/aframe.c
index fc5d73b..c2c0df7 100644
--- a/audio/aframe.c
+++ b/audio/aframe.c
@@ -635,18 +635,24 @@ int mp_aframe_pool_allocate(struct mp_aframe_pool *pool, struct mp_aframe *frame
     AVFrame *av_frame = frame->av_frame;
     if (av_frame->extended_data != av_frame->data)
         av_freep(&av_frame->extended_data); // sigh
-    av_frame->extended_data =
-        av_mallocz_array(planes, sizeof(av_frame->extended_data[0]));
-    if (!av_frame->extended_data)
-        abort();
+    if (planes > AV_NUM_DATA_POINTERS) {
+        av_frame->extended_data =
+            av_mallocz_array(planes, sizeof(av_frame->extended_data[0]));
+        if (!av_frame->extended_data)
+            abort();
+    } else {
+        av_frame->extended_data = av_frame->data;
+    }
     av_frame->buf[0] = av_buffer_pool_get(pool->avpool);
     if (!av_frame->buf[0])
         return -1;
     av_frame->linesize[0] = samples * sstride;
     for (int n = 0; n < planes; n++)
         av_frame->extended_data[n] = av_frame->buf[0]->data + n * plane_size;
-    for (int n = 0; n < MPMIN(planes, AV_NUM_DATA_POINTERS); n++)
-        av_frame->data[n] = av_frame->extended_data[n];
+    if (planes > AV_NUM_DATA_POINTERS) {
+        for (int n = 0; n < AV_NUM_DATA_POINTERS; n++)
+            av_frame->data[n] = av_frame->extended_data[n];
+    }
     av_frame->nb_samples = samples;
 
     return 0;
diff --git a/audio/decode/ad_lavc.c b/audio/decode/ad_lavc.c
index eaaf072..228054e 100644
--- a/audio/decode/ad_lavc.c
+++ b/audio/decode/ad_lavc.c
@@ -85,7 +85,7 @@ static bool init(struct mp_filter *da, struct mp_codec_params *codec,
     struct ad_lavc_params *opts =
         mp_get_config_group(ctx, da->global, &ad_lavc_conf);
     AVCodecContext *lavc_context;
-    AVCodec *lavc_codec;
+    const AVCodec *lavc_codec;
 
     ctx->codec_timebase = mp_get_codec_timebase(codec);
 
diff --git a/audio/decode/ad_spdif.c b/audio/decode/ad_spdif.c
index 0b19777..520803c 100644
--- a/audio/decode/ad_spdif.c
+++ b/audio/decode/ad_spdif.c
@@ -116,7 +116,7 @@ static void determine_codec_params(struct mp_filter *da, AVPacket *pkt,
     if (profile != FF_PROFILE_UNKNOWN || spdif_ctx->codec_id != AV_CODEC_ID_DTS)
         return;
 
-    AVCodec *codec = avcodec_find_decoder(spdif_ctx->codec_id);
+    const AVCodec *codec = avcodec_find_decoder(spdif_ctx->codec_id);
     if (!codec)
         goto done;
 
diff --git a/audio/filter/af_lavcac3enc.c b/audio/filter/af_lavcac3enc.c
index 38f93a1..45e0aa6 100644
--- a/audio/filter/af_lavcac3enc.c
+++ b/audio/filter/af_lavcac3enc.c
@@ -68,7 +68,7 @@ struct priv {
     struct mp_aframe *in_frame;
     struct mp_aframe_pool *out_pool;
 
-    struct AVCodec        *lavc_acodec;
+    const struct AVCodec  *lavc_acodec;
     struct AVCodecContext *lavc_actx;
     int bit_rate;
     int out_samples;    // upper bound on encoded output per AC3 frame
diff --git a/audio/filter/af_scaletempo2_internals.c b/audio/filter/af_scaletempo2_internals.c
index e348cb3..1cee7e4 100644
--- a/audio/filter/af_scaletempo2_internals.c
+++ b/audio/filter/af_scaletempo2_internals.c
@@ -4,6 +4,8 @@
 #include "audio/chmap.h"
 #include "audio/filter/af_scaletempo2_internals.h"
 
+#include "config.h"
+
 // Algorithm overview (from chromium):
 // Waveform Similarity Overlap-and-add (WSOLA).
 //
@@ -104,6 +106,10 @@ static float multi_channel_similarity_measure(
     return similarity_measure;
 }
 
+#if HAVE_VECTOR
+
+typedef float v8sf __attribute__ ((vector_size (32), aligned (1)));
+
 // Dot-product of channels of two AudioBus. For each AudioBus an offset is
 // given. |dot_product[k]| is the dot-product of channel |k|. The caller should
 // allocate sufficient space for |dot_product|.
@@ -116,16 +122,79 @@ static void multi_channel_dot_product(
     assert(frame_offset_a >= 0);
     assert(frame_offset_b >= 0);
 
-    memset(dot_product, 0, sizeof(*dot_product) * channels);
     for (int k = 0; k < channels; ++k) {
         const float* ch_a = a[k] + frame_offset_a;
         const float* ch_b = b[k] + frame_offset_b;
-        for (int n = 0; n < num_frames; ++n) {
-            dot_product[k] += *ch_a++ * *ch_b++;
+        float sum = 0.0;
+        if (num_frames < 32)
+            goto rest;
+
+        const v8sf *va = (const v8sf *) ch_a;
+        const v8sf *vb = (const v8sf *) ch_b;
+        v8sf vsum[4] = {
+            // Initialize to product of first 32 floats
+            va[0] * vb[0],
+            va[1] * vb[1],
+            va[2] * vb[2],
+            va[3] * vb[3],
+        };
+        va += 4;
+        vb += 4;
+
+        // Process `va` and `vb` across four vertical stripes
+        for (int n = 1; n < num_frames / 32; n++) {
+            vsum[0] += va[0] * vb[0];
+            vsum[1] += va[1] * vb[1];
+            vsum[2] += va[2] * vb[2];
+            vsum[3] += va[3] * vb[3];
+            va += 4;
+            vb += 4;
         }
+
+        // Vertical sum across `vsum` entries
+        vsum[0] += vsum[1];
+        vsum[2] += vsum[3];
+        vsum[0] += vsum[2];
+
+        // Horizontal sum across `vsum[0]`, could probably be done better but
+        // this section is not super performance critical
+        float *vf = (float *) &vsum[0];
+        sum = vf[0] + vf[1] + vf[2] + vf[3] + vf[4] + vf[5] + vf[6] + vf[7];
+        ch_a = (const float *) va;
+        ch_b = (const float *) vb;
+
+rest:
+        // Process the remainder
+        for (int n = 0; n < num_frames % 32; n++)
+            sum += *ch_a++ * *ch_b++;
+
+        dot_product[k] = sum;
+    }
+}
+
+#else // !HAVE_VECTOR
+
+static void multi_channel_dot_product(
+    float **a, int frame_offset_a,
+    float **b, int frame_offset_b,
+    int channels,
+    int num_frames, float *dot_product)
+{
+    assert(frame_offset_a >= 0);
+    assert(frame_offset_b >= 0);
+
+    for (int k = 0; k < channels; ++k) {
+        const float* ch_a = a[k] + frame_offset_a;
+        const float* ch_b = b[k] + frame_offset_b;
+        float sum = 0.0;
+        for (int n = 0; n < num_frames; n++)
+            sum += *ch_a++ * *ch_b++;
+        dot_product[k] = sum;
     }
 }
 
+#endif // HAVE_VECTOR
+
 // Fit the curve f(x) = a * x^2 + b * x + c such that
 //   f(-1) = y[0]
 //   f(0) = y[1]
@@ -389,10 +458,8 @@ static int write_completed_frames_to(struct mp_scaletempo2 *p,
 
 static bool can_perform_wsola(struct mp_scaletempo2 *p)
 {
-    const int search_block_size = p->num_candidate_blocks
-        + (p->ola_window_size - 1);
     return p->target_block_index + p->ola_window_size <= p->input_buffer_frames
-        && p->search_block_index + search_block_size <= p->input_buffer_frames;
+        && p->search_block_index + p->search_block_size <= p->input_buffer_frames;
 }
 
 // number of frames needed until a wsola iteration can be performed
@@ -403,6 +470,14 @@ static int frames_needed(struct mp_scaletempo2 *p)
         p->search_block_index + p->search_block_size - p->input_buffer_frames));
 }
 
+static void resize_input_buffer(struct mp_scaletempo2 *p, int size)
+{
+    if (size > p->input_buffer_size) {
+        p->input_buffer_size = size;
+        p->input_buffer = realloc_2d(p->input_buffer, p->channels, size);
+    }
+}
+
 int mp_scaletempo2_fill_input_buffer(struct mp_scaletempo2 *p,
     uint8_t **planes, int frame_size, bool final)
 {
@@ -411,7 +486,8 @@ int mp_scaletempo2_fill_input_buffer(struct mp_scaletempo2 *p,
     int total_fill = final ? needed : read;
     if (total_fill == 0) return 0;
 
-    assert(total_fill + p->input_buffer_frames <= p->input_buffer_size);
+    int required_size = total_fill + p->input_buffer_frames;
+    resize_input_buffer(p, required_size);
 
     for (int i = 0; i < p->channels; ++i) {
         memcpy(p->input_buffer[i] + p->input_buffer_frames,
@@ -427,11 +503,9 @@ int mp_scaletempo2_fill_input_buffer(struct mp_scaletempo2 *p,
 
 static bool target_is_within_search_region(struct mp_scaletempo2 *p)
 {
-    const int search_block_size = p->num_candidate_blocks + (p->ola_window_size - 1);
-
     return p->target_block_index >= p->search_block_index
         && p->target_block_index + p->ola_window_size
-            <= p->search_block_index + search_block_size;
+            <= p->search_block_index + p->search_block_size;
 }
 
 
@@ -715,8 +789,7 @@ void mp_scaletempo2_init(struct mp_scaletempo2 *p, int channels, int rate)
     p->search_block = realloc_2d(p->search_block, p->channels, p->search_block_size);
     p->target_block = realloc_2d(p->target_block, p->channels, p->ola_window_size);
 
-    p->input_buffer_size = 4 * MPMAX(p->ola_window_size, p->search_block_size);
-    p->input_buffer = realloc_2d(p->input_buffer, p->channels, p->input_buffer_size);
+    resize_input_buffer(p, 4 * MPMAX(p->ola_window_size, p->search_block_size));
     p->input_buffer_frames = 0;
 
     p->energy_candidate_blocks = realloc(p->energy_candidate_blocks,
diff --git a/audio/out/ao.c b/audio/out/ao.c
index 52a38b6..7c347cb 100644
--- a/audio/out/ao.c
+++ b/audio/out/ao.c
@@ -35,6 +35,7 @@
 #include "common/common.h"
 #include "common/global.h"
 
+extern const struct ao_driver audio_out_oss;
 extern const struct ao_driver audio_out_audiotrack;
 extern const struct ao_driver audio_out_audiounit;
 extern const struct ao_driver audio_out_coreaudio;
@@ -70,6 +71,9 @@ static const struct ao_driver * const audio_out_drivers[] = {
 #endif
 #if HAVE_WASAPI
     &audio_out_wasapi,
+#endif
+#if HAVE_OSS_AUDIO
+    &audio_out_oss,
 #endif
     // wrappers:
 #if HAVE_JACK
diff --git a/audio/out/ao_oss.c b/audio/out/ao_oss.c
new file mode 100644
index 0000000..11b182e
--- /dev/null
+++ b/audio/out/ao_oss.c
@@ -0,0 +1,410 @@
+/*
+ * OSS audio output driver
+ *
+ * Original author: A'rpi
+ * Support for >2 output channels added 2001-11-25
+ * - Steve Davies <steve@daviesfam.org>
+ * Rozhuk Ivan <rozhuk.im@gmail.com> 2020
+ *
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <sys/ioctl.h>
+#include <sys/soundcard.h>
+#include <sys/stat.h>
+#if defined(__DragonFly__) || defined(__FreeBSD__)
+#include <sys/sysctl.h>
+#endif
+#include <sys/types.h>
+
+#include "config.h"
+#include "audio/format.h"
+#include "common/msg.h"
+#include "options/options.h"
+#include "osdep/endian.h"
+#include "osdep/io.h"
+#include "ao.h"
+#include "internal.h"
+
+#ifndef AFMT_AC3
+#define AFMT_AC3 -1
+#endif
+
+#define PATH_DEV_DSP "/dev/dsp"
+
+struct priv {
+    int dsp_fd;
+    bool playing;
+    double bps; /* Bytes per second. */
+};
+
+/* like alsa except for 6.1 and 7.1, from pcm/matrix_map.h */
+static const struct mp_chmap oss_layouts[MP_NUM_CHANNELS + 1] = {
+    {0},                                        /* empty */
+    MP_CHMAP_INIT_MONO,                         /* mono */
+    MP_CHMAP2(FL, FR),                          /* stereo */
+    MP_CHMAP3(FL, FR, LFE),                     /* 2.1 */
+    MP_CHMAP4(FL, FR, BL, BR),                  /* 4.0 */
+    MP_CHMAP5(FL, FR, BL, BR, FC),              /* 5.0 */
+    MP_CHMAP6(FL, FR, BL, BR, FC, LFE),         /* 5.1 */
+    MP_CHMAP7(FL, FR, BL, BR, FC, LFE, BC),     /* 6.1 */
+    MP_CHMAP8(FL, FR, BL, BR, FC, LFE, SL, SR), /* 7.1 */
+};
+
+#if !defined(AFMT_S32_NE) && defined(AFMT_S32_LE) && defined(AFMT_S32_BE)
+#define AFMT_S32_NE AFMT_S32MP_SELECT_LE_BE(AFMT_S32_LE, AFMT_S32_BE)
+#endif
+
+static const int format_table[][2] = {
+    {AFMT_U8,           AF_FORMAT_U8},
+    {AFMT_S16_NE,       AF_FORMAT_S16},
+#ifdef AFMT_S32_NE
+    {AFMT_S32_NE,       AF_FORMAT_S32},
+#endif
+#ifdef AFMT_FLOAT
+    {AFMT_FLOAT,        AF_FORMAT_FLOAT},
+#endif
+#ifdef AFMT_MPEG
+    {AFMT_MPEG,         AF_FORMAT_S_MP3},
+#endif
+    {-1, -1}
+};
+
+#define MP_WARN_IOCTL_ERR(__ao) \
+    MP_WARN((__ao), "%s: ioctl() fail, err = %i: %s\n", \
+        __FUNCTION__, errno, strerror(errno))
+
+
+static void uninit(struct ao *ao);
+
+
+static void device_descr_get(size_t dev_idx, char *buf, size_t buf_size)
+{
+#if defined(__DragonFly__) || defined(__FreeBSD__)
+    char dev_path[32];
+    size_t tmp = (buf_size - 1);
+
+    snprintf(dev_path, sizeof(dev_path), "dev.pcm.%zu.%%desc", dev_idx);
+    if (sysctlbyname(dev_path, buf, &tmp, NULL, 0) != 0) {
+        tmp = 0;
+    }
+    buf[tmp] = 0x00;
+#elif defined(SOUND_MIXER_INFO)
+    size_t tmp = 0;
+    char dev_path[32];
+    mixer_info mi;
+
+    snprintf(dev_path, sizeof(dev_path), PATH_DEV_MIXER"%zu", dev_idx);
+    int fd = open(dev_path, O_RDONLY);
+    if (ioctl(fd, SOUND_MIXER_INFO, &mi) == 0) {
+        strncpy(buf, mi.name, buf_size);
+        tmp = (buf_size - 1);
+    }
+    close(fd);
+    buf[tmp] = 0x00;
+#else
+    buf[0] = 0x00;
+#endif
+}
+
+static int format2oss(int format)
+{
+    for (size_t i = 0; format_table[i][0] != -1; i++) {
+        if (format_table[i][1] == format)
+            return format_table[i][0];
+    }
+    return -1;
+}
+
+static bool try_format(struct ao *ao, int *format)
+{
+    struct priv *p = ao->priv;
+    int oss_format = format2oss(*format);
+
+    if (oss_format == -1 && af_fmt_is_spdif(*format))
+        oss_format = AFMT_AC3;
+
+    if (oss_format == -1) {
+        MP_VERBOSE(ao, "Unknown/not supported internal format: %s\n",
+            af_fmt_to_str(*format));
+        *format = 0;
+        return false;
+    }
+
+    return (ioctl(p->dsp_fd, SNDCTL_DSP_SETFMT, &oss_format) != -1);
+}
+
+static int init(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+    struct mp_chmap channels = ao->channels;
+    audio_buf_info info;
+    size_t i;
+    int format, samplerate, nchannels, reqchannels, trig = 0;
+    int best_sample_formats[AF_FORMAT_COUNT + 1];
+    const char *device = ((ao->device) ? ao->device : PATH_DEV_DSP);
+
+    /* Opening device. */
+    MP_VERBOSE(ao, "Using '%s' audio device.\n", device);
+    p->dsp_fd = open(device, (O_WRONLY | O_CLOEXEC));
+    if (p->dsp_fd < 0) {
+        MP_ERR(ao, "Can't open audio device %s: %s.\n",
+            device, mp_strerror(errno));
+        goto err_out;
+    }
+
+    /* Selecting sound format. */
+    format = af_fmt_from_planar(ao->format);
+    af_get_best_sample_formats(format, best_sample_formats);
+    for (i = 0; best_sample_formats[i]; i++) {
+        format = best_sample_formats[i];
+        if (try_format(ao, &format))
+            break;
+    }
+    if (!format) {
+        MP_ERR(ao, "Can't set sample format.\n");
+        goto err_out;
+    }
+    MP_VERBOSE(ao, "Sample format: %s\n", af_fmt_to_str(format));
+
+    /* Channels count. */
+    if (af_fmt_is_spdif(format)) {
+        /* Probably could be fixed by setting number of channels;
+         * needs testing. */
+        if (channels.num != 2) {
+            MP_ERR(ao, "Format %s not implemented.\n", af_fmt_to_str(format));
+            goto err_out;
+        }
+    } else {
+        struct mp_chmap_sel sel = {0};
+        for (i = 0; i < MP_ARRAY_SIZE(oss_layouts); i++) {
+            mp_chmap_sel_add_map(&sel, &oss_layouts[i]);
+        }
+        if (!ao_chmap_sel_adjust(ao, &sel, &channels))
+            goto err_out;
+        nchannels = reqchannels = channels.num;
+        if (ioctl(p->dsp_fd, SNDCTL_DSP_CHANNELS, &nchannels) == -1) {
+            MP_ERR(ao, "Failed to set audio device to %d channels.\n",
+                reqchannels);
+            goto err_out_ioctl;
+        }
+        if (nchannels != reqchannels) {
+            /* Update number of channels to OSS suggested value. */
+            if (!ao_chmap_sel_get_def(ao, &sel, &channels, nchannels))
+                goto err_out;
+        }
+        MP_VERBOSE(ao, "Using %d channels (requested: %d).\n",
+            channels.num, reqchannels);
+    }
+
+    /* Sample rate. */
+    samplerate = ao->samplerate;
+    if (ioctl(p->dsp_fd, SNDCTL_DSP_SPEED, &samplerate) == -1)
+        goto err_out_ioctl;
+    MP_VERBOSE(ao, "Using %d Hz samplerate.\n", samplerate);
+
+    /* Get buffer size. */
+    if (ioctl(p->dsp_fd, SNDCTL_DSP_GETOSPACE, &info) == -1)
+        goto err_out_ioctl;
+    /* See ao.c ao->sstride initializations and get_state(). */
+    ao->device_buffer = ((info.fragstotal * info.fragsize) /
+        af_fmt_to_bytes(format));
+    if (!af_fmt_is_planar(format)) {
+        ao->device_buffer /= channels.num;
+    }
+
+    /* Do not start playback after data written. */
+    if (ioctl(p->dsp_fd, SNDCTL_DSP_SETTRIGGER, &trig) == -1)
+        goto err_out_ioctl;
+
+    /* Update sound params. */
+    ao->format = format;
+    ao->samplerate = samplerate;
+    ao->channels = channels;
+    p->bps = (channels.num * samplerate * af_fmt_to_bytes(format));
+    p->playing = false;
+
+    return 0;
+
+err_out_ioctl:
+    MP_WARN_IOCTL_ERR(ao);
+err_out:
+    uninit(ao);
+    return -1;
+}
+
+static void uninit(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+
+    if (p->dsp_fd == -1)
+        return;
+    ioctl(p->dsp_fd, SNDCTL_DSP_HALT, NULL);
+    close(p->dsp_fd);
+    p->dsp_fd = -1;
+    p->playing = false;
+}
+
+static int control(struct ao *ao, enum aocontrol cmd, void *arg)
+{
+    struct priv *p = ao->priv;
+    ao_control_vol_t *vol = (ao_control_vol_t *)arg;
+    int v;
+
+    if (p->dsp_fd < 0)
+        return CONTROL_ERROR;
+
+    switch (cmd) {
+    case AOCONTROL_GET_VOLUME:
+        if (ioctl(p->dsp_fd, SNDCTL_DSP_GETPLAYVOL, &v) == -1) {
+            MP_WARN_IOCTL_ERR(ao);
+            return CONTROL_ERROR;
+        }
+        vol->right = ((v & 0xff00) >> 8);
+        vol->left = (v & 0x00ff);
+        return CONTROL_OK;
+    case AOCONTROL_SET_VOLUME:
+        v = ((int)vol->right << 8) | (int)vol->left;
+        if (ioctl(p->dsp_fd, SNDCTL_DSP_SETPLAYVOL, &v) == -1) {
+            MP_WARN_IOCTL_ERR(ao);
+            return CONTROL_ERROR;
+        }
+        return CONTROL_OK;
+    }
+
+    return CONTROL_UNKNOWN;
+}
+
+static void reset(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+    int trig = 0;
+
+    /* Clear buf and do not start playback after data written. */
+    p->playing = false;
+    if (ioctl(p->dsp_fd, SNDCTL_DSP_HALT, NULL) == -1 ||
+        ioctl(p->dsp_fd, SNDCTL_DSP_SETTRIGGER, &trig) == -1)
+    {
+        MP_WARN_IOCTL_ERR(ao);
+        MP_WARN(ao, "Force reinitialize audio device.\n");
+        uninit(ao);
+        init(ao);
+    }
+}
+
+static void start(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+    int trig = PCM_ENABLE_OUTPUT;
+
+    if (ioctl(p->dsp_fd, SNDCTL_DSP_SETTRIGGER, &trig) == -1) {
+        MP_WARN_IOCTL_ERR(ao);
+        return;
+    }
+    p->playing = true;
+}
+
+static bool audio_write(struct ao *ao, void **data, int samples)
+{
+    struct priv *p = ao->priv;
+    ssize_t rc;
+    const size_t size = (samples * ao->sstride);
+
+    if (size == 0)
+        return true;
+
+    while ((rc = write(p->dsp_fd, data[0], size)) == -1) {
+        if (errno == EINTR)
+			continue;
+        MP_WARN(ao, "audio_write: write() fail, err = %i: %s.\n",
+            errno, strerror(errno));
+        p->playing = false;
+        return false;
+    }
+    if ((size_t)rc != size) {
+        MP_WARN(ao, "audio_write: unexpected partial write: required: %zu, written: %zu.\n",
+            size, (size_t)rc);
+        p->playing = false;
+        return false;
+    }
+
+    return true;
+}
+
+static void get_state(struct ao *ao, struct mp_pcm_state *state)
+{
+    struct priv *p = ao->priv;
+    audio_buf_info info;
+    int odelay;
+
+    if (ioctl(p->dsp_fd, SNDCTL_DSP_GETOSPACE, &info) == -1 ||
+        ioctl(p->dsp_fd, SNDCTL_DSP_GETODELAY, &odelay) == -1)
+    {
+        MP_WARN_IOCTL_ERR(ao);
+        p->playing = false;
+        memset(state, 0x00, sizeof(struct mp_pcm_state));
+        state->delay = 0.0;
+        return;
+    }
+    state->free_samples = (info.bytes / ao->sstride);
+    state->queued_samples = (ao->device_buffer - state->free_samples);
+    state->delay = (odelay / p->bps);
+    state->playing = p->playing;
+}
+
+static void list_devs(struct ao *ao, struct ao_device_list *list)
+{
+    struct stat st;
+    char dev_path[32] = PATH_DEV_DSP, dev_descr[256] = "Default";
+    struct ao_device_desc dev = {.name = dev_path, .desc = dev_descr};
+
+    if (stat(PATH_DEV_DSP, &st) == 0) {
+        ao_device_list_add(list, ao, &dev);
+    }
+
+    /* Auto detect. */
+    for (size_t i = 0, fail_cnt = 0; fail_cnt < 8; i ++, fail_cnt ++) {
+        snprintf(dev_path, sizeof(dev_path), PATH_DEV_DSP"%zu", i);
+        if (stat(dev_path, &st) != 0)
+            continue;
+        device_descr_get(i, dev_descr, sizeof(dev_descr));
+        ao_device_list_add(list, ao, &dev);
+        fail_cnt = 0; /* Reset fail counter. */
+    }
+}
+
+const struct ao_driver audio_out_oss = {
+    .name      = "oss",
+    .description = "OSS/ioctl audio output",
+    .init      = init,
+    .uninit    = uninit,
+    .control   = control,
+    .reset     = reset,
+    .start     = start,
+    .write     = audio_write,
+    .get_state = get_state,
+    .list_devs = list_devs,
+    .priv_size = sizeof(struct priv),
+    .priv_defaults = &(const struct priv) {
+        .dsp_fd = -1,
+        .playing = false,
+    },
+};
diff --git a/audio/out/ao_pulse.c b/audio/out/ao_pulse.c
index b09d262..6c536b0 100644
--- a/audio/out/ao_pulse.c
+++ b/audio/out/ao_pulse.c
@@ -535,6 +535,7 @@ static void reset(struct ao *ao)
     cork(ao, true);
     struct priv *priv = ao->priv;
     pa_threaded_mainloop_lock(priv->mainloop);
+    priv->playing = false;
     priv->retval = 0;
     if (!waitop(priv, pa_stream_flush(priv->stream, success_cb, ao)) ||
         !priv->retval)
@@ -696,9 +697,8 @@ static int control(struct ao *ao, enum aocontrol cmd, void *arg)
 
     case AOCONTROL_SET_MUTE:
     case AOCONTROL_SET_VOLUME: {
-        pa_operation *o;
-
         pa_threaded_mainloop_lock(priv->mainloop);
+        priv->retval = 0;
         uint32_t stream_index = pa_stream_get_index(priv->stream);
         if (cmd == AOCONTROL_SET_VOLUME) {
             const ao_control_vol_t *vol = arg;
@@ -711,27 +711,26 @@ static int control(struct ao *ao, enum aocontrol cmd, void *arg)
                 volume.values[0] = VOL_MP2PA(vol->left);
                 volume.values[1] = VOL_MP2PA(vol->right);
             }
-            o = pa_context_set_sink_input_volume(priv->context, stream_index,
-                                                 &volume, NULL, NULL);
-            if (!o) {
-                pa_threaded_mainloop_unlock(priv->mainloop);
+            if (!waitop(priv, pa_context_set_sink_input_volume(priv->context,
+                                                               stream_index,
+                                                               &volume,
+                                                               context_success_cb, ao)) ||
+                !priv->retval) {
                 GENERIC_ERR_MSG("pa_context_set_sink_input_volume() failed");
                 return CONTROL_ERROR;
             }
         } else if (cmd == AOCONTROL_SET_MUTE) {
             const bool *mute = arg;
-            o = pa_context_set_sink_input_mute(priv->context, stream_index,
-                                               *mute, NULL, NULL);
-            if (!o) {
-                pa_threaded_mainloop_unlock(priv->mainloop);
+            if (!waitop(priv, pa_context_set_sink_input_mute(priv->context,
+                                                             stream_index,
+                                                             *mute,
+                                                             context_success_cb, ao)) ||
+                !priv->retval) {
                 GENERIC_ERR_MSG("pa_context_set_sink_input_mute() failed");
                 return CONTROL_ERROR;
             }
         } else
             abort();
-        /* We don't wait for completion here */
-        pa_operation_unref(o);
-        pa_threaded_mainloop_unlock(priv->mainloop);
         return CONTROL_OK;
     }
 
diff --git a/bootstrap.py b/bootstrap.py
index 9949183..51b81f5 100755
--- a/bootstrap.py
+++ b/bootstrap.py
@@ -2,8 +2,8 @@
 
 # This script simply downloads waf to the current directory
 
-from __future__ import print_function
 import os, sys, stat, hashlib, subprocess
+from urllib.request import urlopen, URLError
 
 WAFRELEASE = "waf-2.0.20"
 WAFURLS    = ["https://waf.io/" + WAFRELEASE,
@@ -20,11 +20,6 @@ if "--no-download" in sys.argv[1:]:
     print("Did not find {} and no download was requested.".format(WAFRELEASE))
     sys.exit(1)
 
-try:
-    from urllib.request import urlopen, URLError
-except:
-    from urllib2 import urlopen, URLError
-
 waf = None
 
 for WAFURL in WAFURLS:
@@ -32,8 +27,8 @@ for WAFURL in WAFURLS:
         print("Downloading {}...".format(WAFURL))
         waf = urlopen(WAFURL).read()
         break
-    except URLError:
-        print("Download failed.")
+    except URLError as err:
+        print("Download failed! ({})".format(err))
 
 if not waf:
     print("Could not download {}.".format(WAFRELEASE))
diff --git a/common/av_common.c b/common/av_common.c
index 01428ff..bd82d75 100644
--- a/common/av_common.c
+++ b/common/av_common.c
@@ -80,12 +80,23 @@ AVCodecParameters *mp_codec_params_to_av(struct mp_codec_params *c)
     avp->codec_id = mp_codec_to_av_codec_id(c->codec);
     avp->codec_tag = c->codec_tag;
     if (c->extradata_size) {
-        avp->extradata =
-            av_mallocz(c->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
+        uint8_t *extradata = c->extradata;
+        int size = c->extradata_size;
+
+        if (avp->codec_id == AV_CODEC_ID_FLAC) {
+            // ffmpeg expects FLAC extradata to be just the STREAMINFO,
+            // so grab only that (and assume it'll be the first block)
+            if (size >= 8 && !memcmp(c->extradata, "fLaC", 4)) {
+                extradata += 8;
+                size = MPMIN(34, size - 8); // FLAC_STREAMINFO_SIZE
+            }
+        }
+
+        avp->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);
         if (!avp->extradata)
             goto error;
-        avp->extradata_size = c->extradata_size;
-        memcpy(avp->extradata, c->extradata, avp->extradata_size);
+        avp->extradata_size = size;
+        memcpy(avp->extradata, extradata, size);
     }
     avp->bits_per_coded_sample = c->bits_per_coded_sample;
 
@@ -270,7 +281,7 @@ int mp_codec_to_av_codec_id(const char *codec)
         if (desc)
             id = desc->id;
         if (id == AV_CODEC_ID_NONE) {
-            AVCodec *avcodec = avcodec_find_decoder_by_name(codec);
+            const AVCodec *avcodec = avcodec_find_decoder_by_name(codec);
             if (avcodec)
                 id = avcodec->id;
         }
@@ -285,7 +296,7 @@ const char *mp_codec_from_av_codec_id(int codec_id)
     if (desc)
         name = desc->name;
     if (!name) {
-        AVCodec *avcodec = avcodec_find_decoder(codec_id);
+        const AVCodec *avcodec = avcodec_find_decoder(codec_id);
         if (avcodec)
             name = avcodec->name;
     }
diff --git a/common/encode_lavc.c b/common/encode_lavc.c
index 2af93d2..cf033e0 100644
--- a/common/encode_lavc.c
+++ b/common/encode_lavc.c
@@ -735,7 +735,7 @@ static void encoder_destroy(void *ptr)
     free_stream(p->twopass_bytebuffer);
 }
 
-static AVCodec *find_codec_for(struct encode_lavc_context *ctx,
+static const AVCodec *find_codec_for(struct encode_lavc_context *ctx,
                                enum stream_type type, bool *used_auto)
 {
     char *codec_name = type == STREAM_VIDEO
@@ -746,7 +746,7 @@ static AVCodec *find_codec_for(struct encode_lavc_context *ctx,
 
     *used_auto = !(codec_name && codec_name[0]);
 
-    AVCodec *codec;
+    const AVCodec *codec;
     if (*used_auto) {
         codec = avcodec_find_encoder(av_guess_codec(ctx->oformat, NULL,
                                      ctx->options->file, NULL,
@@ -797,7 +797,7 @@ struct encoder_context *encoder_context_alloc(struct encode_lavc_context *ctx,
     };
 
     bool auto_codec;
-    AVCodec *codec = find_codec_for(ctx, type, &auto_codec);
+    const AVCodec *codec = find_codec_for(ctx, type, &auto_codec);
     const char *tname = stream_type_name(type);
 
     if (!codec) {
diff --git a/common/encode_lavc.h b/common/encode_lavc.h
index 06e7254..cc4030a 100644
--- a/common/encode_lavc.h
+++ b/common/encode_lavc.h
@@ -41,7 +41,7 @@ struct encode_lavc_context {
     struct encode_opts *options;
     struct mp_log *log;
     struct encode_priv *priv;
-    AVOutputFormat *oformat;
+    const AVOutputFormat *oformat;
     const char *filename;
 
     // All entry points must be guarded with the lock. Functions called by
@@ -71,7 +71,7 @@ struct encoder_context {
     struct mpv_global *global;
     struct encode_opts *options;
     struct mp_log *log;
-    AVOutputFormat *oformat;
+    const AVOutputFormat *oformat;
 
     // (avoid using this)
     struct encode_lavc_context *encode_lavc_ctx;
diff --git a/common/msg.c b/common/msg.c
index 7e271d1..81c7f65 100644
--- a/common/msg.c
+++ b/common/msg.c
@@ -126,6 +126,8 @@ static void update_loglevel(struct mp_log *log)
     struct mp_log_root *root = log->root;
     pthread_mutex_lock(&root->lock);
     log->level = MSGL_STATUS + root->verbose; // default log level
+    if (root->really_quiet)
+        log->level = -1;
     for (int n = 0; root->msg_levels && root->msg_levels[n * 2 + 0]; n++) {
         if (match_mod(log->verbose_prefix, root->msg_levels[n * 2 + 0]))
             log->level = mp_msg_find_level(root->msg_levels[n * 2 + 1]);
@@ -143,8 +145,6 @@ static void update_loglevel(struct mp_log *log)
     if (log->root->stats_file)
         log->level = MPMAX(log->level, MSGL_STATS);
     log->level = MPMIN(log->level, log->max_level);
-    if (root->really_quiet)
-        log->level = -1;
     atomic_store(&log->reload_counter, atomic_load(&log->root->reload_counter));
     pthread_mutex_unlock(&root->lock);
 }
diff --git a/common/recorder.c b/common/recorder.c
index 58bf257..0cbc81d 100644
--- a/common/recorder.c
+++ b/common/recorder.c
@@ -23,6 +23,7 @@
 #include "common/common.h"
 #include "common/global.h"
 #include "common/msg.h"
+#include "demux/demux.h"
 #include "demux/packet.h"
 #include "demux/stheader.h"
 
@@ -91,6 +92,12 @@ static int add_stream(struct mp_recorder *priv, struct sh_stream *sh)
     if (!avp)
         return -1;
 
+    // Check if we get the same codec_id for the output format;
+    // otherwise clear it to have a chance at muxing
+    if (av_codec_get_id(priv->mux->oformat->codec_tag,
+                        avp->codec_tag) != avp->codec_id)
+        avp->codec_tag = 0;
+
     // We don't know the delay, so make something up. If the format requires
     // DTS, the result will probably be broken. FFmpeg provides nothing better
     // yet (unless you demux with libavformat, which contains tons of hacks
@@ -113,7 +120,9 @@ static int add_stream(struct mp_recorder *priv, struct sh_stream *sh)
 struct mp_recorder *mp_recorder_create(struct mpv_global *global,
                                        const char *target_file,
                                        struct sh_stream **streams,
-                                       int num_streams)
+                                       int num_streams,
+                                       struct demux_attachment **attachments,
+                                       int num_attachments)
 {
     struct mp_recorder *priv = talloc_zero(NULL, struct mp_recorder);
 
@@ -147,6 +156,35 @@ struct mp_recorder *mp_recorder_create(struct mpv_global *global,
         }
     }
 
+    if (!strcmp(priv->mux->oformat->name, "matroska")) {
+        // Only attach attachments (fonts) to matroska - mp4, nut, mpegts don't
+        // like them, and we find that out too late in the muxing process.
+        AVStream *a_stream = NULL;
+        for (int i = 0; i < num_attachments; ++i) {
+            a_stream = avformat_new_stream(priv->mux, NULL);
+            if (!a_stream) {
+                MP_ERR(priv, "Can't mux one of the attachments.\n");
+                goto error;
+            }
+            struct demux_attachment *attachment = attachments[i];
+
+            a_stream->codecpar->codec_type = AVMEDIA_TYPE_ATTACHMENT;
+
+            a_stream->codecpar->extradata  = av_mallocz(
+                attachment->data_size + AV_INPUT_BUFFER_PADDING_SIZE
+            );
+            if (!a_stream->codecpar->extradata) {
+                goto error;
+            }
+            memcpy(a_stream->codecpar->extradata,
+                attachment->data, attachment->data_size);
+            a_stream->codecpar->extradata_size = attachment->data_size;
+
+            av_dict_set(&a_stream->metadata, "filename", attachment->name, 0);
+            av_dict_set(&a_stream->metadata, "mimetype", attachment->type, 0);
+        }
+    }
+
     // Not sure how to write this in a "standard" way. It appears only mkv
     // and mp4 support this directly.
     char version[200];
@@ -217,30 +255,19 @@ static void mux_packet(struct mp_recorder_sink *rst,
         MP_ERR(priv, "Failed writing packet.\n");
 }
 
-// Write all packets that currently can be written.
-static void mux_packets(struct mp_recorder_sink *rst, bool force)
+// Write all packets available in the stream queue
+static void mux_packets(struct mp_recorder_sink *rst)
 {
     struct mp_recorder *priv = rst->owner;
     if (!priv->muxing || !rst->num_packets)
         return;
 
-    int safe_count = 0;
     for (int n = 0; n < rst->num_packets; n++) {
-        if (rst->packets[n]->keyframe)
-            safe_count = n;
-    }
-    if (force)
-        safe_count = rst->num_packets;
-
-    for (int n = 0; n < safe_count; n++) {
         mux_packet(rst, rst->packets[n]);
         talloc_free(rst->packets[n]);
     }
 
-    // Remove packets[0..safe_count]
-    memmove(&rst->packets[0], &rst->packets[safe_count],
-            (rst->num_packets - safe_count) * sizeof(rst->packets[0]));
-    rst->num_packets -= safe_count;
+    rst->num_packets = 0;
 }
 
 // If there was a discontinuity, check whether we can resume muxing (and from
@@ -291,7 +318,7 @@ void mp_recorder_destroy(struct mp_recorder *priv)
     if (priv->opened) {
         for (int n = 0; n < priv->num_streams; n++) {
             struct mp_recorder_sink *rst = priv->streams[n];
-            mux_packets(rst, true);
+            mux_packets(rst);
         }
 
         if (av_write_trailer(priv->mux) < 0)
@@ -312,15 +339,15 @@ void mp_recorder_destroy(struct mp_recorder *priv)
 // This is called on a seek, or when recording was started mid-stream.
 void mp_recorder_mark_discontinuity(struct mp_recorder *priv)
 {
-    flush_packets(priv);
 
     for (int n = 0; n < priv->num_streams; n++) {
         struct mp_recorder_sink *rst = priv->streams[n];
-        mux_packets(rst, true);
+        mux_packets(rst);
         rst->discont = true;
         rst->proper_eof = false;
     }
 
+    flush_packets(priv);
     priv->muxing = false;
     priv->muxing_from_start = false;
 }
@@ -350,7 +377,7 @@ void mp_recorder_feed_packet(struct mp_recorder_sink *rst,
     if (!pkt) {
         rst->proper_eof = true;
         check_restart(priv);
-        mux_packets(rst, false);
+        mux_packets(rst);
         return;
     }
 
@@ -359,7 +386,7 @@ void mp_recorder_feed_packet(struct mp_recorder_sink *rst,
         // No, FFmpeg doesn't tell us which formats need DTS at all.
         // No, we can not shut up the FFmpeg warning, which will follow.
         MP_WARN(priv, "Source stream misses DTS on at least some packets!\n"
-                      "If the target file format requires DTS, the written\n"
+                      "If the target file format requires DTS, the written "
                       "file will be invalid.\n");
         priv->dts_warning = true;
     }
@@ -380,5 +407,5 @@ void mp_recorder_feed_packet(struct mp_recorder_sink *rst,
     MP_TARRAY_APPEND(rst, rst->packets, rst->num_packets, pkt);
 
     check_restart(priv);
-    mux_packets(rst, false);
+    mux_packets(rst);
 }
diff --git a/common/recorder.h b/common/recorder.h
index c0b1e36..e86d978 100644
--- a/common/recorder.h
+++ b/common/recorder.h
@@ -5,12 +5,15 @@ struct mp_recorder;
 struct mpv_global;
 struct demux_packet;
 struct sh_stream;
+struct demux_attachment;
 struct mp_recorder_sink;
 
 struct mp_recorder *mp_recorder_create(struct mpv_global *global,
                                        const char *target_file,
                                        struct sh_stream **streams,
-                                       int num_streams);
+                                       int num_streams,
+                                       struct demux_attachment **demux_attachments,
+                                       int num_attachments);
 void mp_recorder_destroy(struct mp_recorder *r);
 void mp_recorder_mark_discontinuity(struct mp_recorder *r);
 
diff --git a/demux/demux.c b/demux/demux.c
index e4dda43..650078d 100644
--- a/demux/demux.c
+++ b/demux/demux.c
@@ -121,8 +121,7 @@ const struct m_sub_options demux_conf = {
             M_RANGE(0, M_MAX_MEM_BYTES)},
         {"demuxer-donate-buffer", OPT_FLAG(donate_fw)},
         {"force-seekable", OPT_FLAG(force_seekable)},
-        {"cache-secs", OPT_DOUBLE(min_secs_cache), M_RANGE(0, DBL_MAX),
-            .deprecation_message = "will use unlimited time"},
+        {"cache-secs", OPT_DOUBLE(min_secs_cache), M_RANGE(0, DBL_MAX)},
         {"access-references", OPT_FLAG(access_references)},
         {"demuxer-seekable-cache", OPT_CHOICE(seekable_cache,
             {"auto", -1}, {"no", 0}, {"yes", 1})},
@@ -1945,9 +1944,18 @@ static struct mp_recorder *recorder_create(struct demux_internal *in,
         if (stream->ds->selected)
             MP_TARRAY_APPEND(NULL, streams, num_streams, stream);
     }
+
+    struct demuxer *demuxer = in->d_thread;
+    struct demux_attachment **attachments = talloc_array(NULL, struct demux_attachment*, demuxer->num_attachments);
+    for (int n = 0; n < demuxer->num_attachments; n++) {
+        attachments[n] = &demuxer->attachments[n];
+    }
+
     struct mp_recorder *res = mp_recorder_create(in->d_thread->global, dst,
-                                                 streams, num_streams);
+                                                 streams, num_streams,
+                                                 attachments, demuxer->num_attachments);
     talloc_free(streams);
+    talloc_free(attachments);
     return res;
 }
 
@@ -2827,7 +2835,7 @@ done:
     return out_pkt;
 }
 
-void demuxer_help(struct mp_log *log)
+int demuxer_help(struct mp_log *log, const m_option_t *opt, struct bstr name)
 {
     int i;
 
@@ -2837,6 +2845,9 @@ void demuxer_help(struct mp_log *log)
         mp_info(log, "%10s  %s\n",
                 demuxer_list[i]->name, demuxer_list[i]->desc);
     }
+    mp_info(log, "\n");
+
+    return M_OPT_EXIT;
 }
 
 static const char *d_level(enum demux_check level)
@@ -3970,6 +3981,26 @@ void demuxer_select_track(struct demuxer *demuxer, struct sh_stream *stream,
     pthread_mutex_unlock(&in->lock);
 }
 
+// Execute a refresh seek on the given stream.
+// ref_pts has the same meaning as with demuxer_select_track()
+void demuxer_refresh_track(struct demuxer *demuxer, struct sh_stream *stream,
+                           double ref_pts)
+{
+    struct demux_internal *in = demuxer->in;
+    struct demux_stream *ds = stream->ds;
+    pthread_mutex_lock(&in->lock);
+    ref_pts = MP_ADD_PTS(ref_pts, -in->ts_offset);
+    if (ds->selected) {
+        MP_VERBOSE(in, "refresh track %d\n", stream->index);
+        update_stream_selection_state(in, ds);
+        if (in->back_demuxing)
+            ds->back_seek_pos = ref_pts;
+        if (!in->after_seek)
+            initiate_refresh_seek(in, ds, ref_pts);
+    }
+    pthread_mutex_unlock(&in->lock);
+}
+
 // This is for demuxer implementations only. demuxer_select_track() sets the
 // logical state, while this function returns the actual state (in case the
 // demuxer attempts to cache even unselected packets for track switching - this
@@ -4144,8 +4175,8 @@ static void dumper_close(struct demux_internal *in)
 
 static int range_time_compare(const void *p1, const void *p2)
 {
-    struct demux_cached_range *r1 = (void *)p1;
-    struct demux_cached_range *r2 = (void *)p2;
+    struct demux_cached_range *r1 = *((struct demux_cached_range **)p1);
+    struct demux_cached_range *r2 = *((struct demux_cached_range **)p2);
 
     if (r1->seek_start == r2->seek_start)
         return 0;
diff --git a/demux/demux.h b/demux/demux.h
index f49e6e2..ed414f1 100644
--- a/demux/demux.h
+++ b/demux/demux.h
@@ -290,8 +290,10 @@ void demux_block_reading(struct demuxer *demuxer, bool block);
 
 void demuxer_select_track(struct demuxer *demuxer, struct sh_stream *stream,
                           double ref_pts, bool selected);
+void demuxer_refresh_track(struct demuxer *demuxer, struct sh_stream *stream,
+                           double ref_pts);
 
-void demuxer_help(struct mp_log *log);
+int demuxer_help(struct mp_log *log, const m_option_t *opt, struct bstr name);
 
 int demuxer_add_attachment(struct demuxer *demuxer, char *name,
                            char *type, void *data, size_t data_size);
diff --git a/demux/demux_edl.c b/demux/demux_edl.c
index 256b304..356b7ee 100644
--- a/demux/demux_edl.c
+++ b/demux/demux_edl.c
@@ -32,6 +32,7 @@
 #include "options/path.h"
 #include "misc/bstr.h"
 #include "common/common.h"
+#include "common/tags.h"
 #include "stream/stream.h"
 
 #define HEADER "# mpv EDL v0\n"
@@ -60,6 +61,7 @@ struct tl_parts {
 struct tl_root {
     struct tl_parts **pars;
     int num_pars;
+    struct mp_tags *tags;
 };
 
 struct priv {
@@ -171,6 +173,7 @@ static struct sh_stream *get_meta(struct tl_parts *tl, int index)
 static struct tl_root *parse_edl(bstr str, struct mp_log *log)
 {
     struct tl_root *root = talloc_zero(NULL, struct tl_root);
+    root->tags = talloc_zero(root, struct mp_tags);
     struct tl_parts *tl = add_part(root);
     while (str.len) {
         if (bstr_eatstart0(&str, "#")) {
@@ -273,6 +276,12 @@ static struct tl_root *parse_edl(bstr str, struct mp_log *log)
                 sh->codec->fps = get_param_int(&ctx, "fps", 0);
                 sh->codec->samplerate = get_param_int(&ctx, "samplerate", 0);
                 tl->delay_open = true;
+            } else if (bstr_equals0(f_type, "global_tags")) {
+                for (int n = 0; n < ctx.num_params; n++) {
+                    mp_tags_set_bstr(root->tags, ctx.param_names[n],
+                                     ctx.param_vals[n]);
+                }
+                ctx.num_params = 0;
             } else {
                 mp_err(log, "Unknown header: '%.*s'\n", BSTR_P(f_type));
                 goto error;
@@ -389,6 +398,7 @@ static void resolve_timestamps(struct tl_part *part, struct demuxer *demuxer)
 }
 
 static struct timeline_par *build_timeline(struct timeline *root,
+                                           struct tl_root *edl_root,
                                            struct tl_parts *parts)
 {
     struct timeline_par *tl = talloc_zero(root, struct timeline_par);
@@ -542,6 +552,11 @@ static struct timeline_par *build_timeline(struct timeline *root,
     if (!root->meta)
         root->meta = tl->track_layout;
 
+    // Not very sane, since demuxer fields are supposed to be treated read-only
+    // from outside, but happens to work in this case, so who cares.
+    if (root->meta)
+        mp_tags_merge(root->meta->metadata, edl_root->tags);
+
     assert(tl->num_parts == parts->num_parts);
     return tl;
 
@@ -581,7 +596,7 @@ static void build_mpv_edl_timeline(struct timeline *tl)
     for (int n = 0; n < root->num_pars; n++) {
         struct tl_parts *parts = root->pars[n];
         fix_filenames(parts, tl->demuxer->filename);
-        struct timeline_par *par = build_timeline(tl, parts);
+        struct timeline_par *par = build_timeline(tl, root, parts);
         if (!par)
             break;
         all_dash &= par->dash;
diff --git a/demux/demux_lavf.c b/demux/demux_lavf.c
index 1bc8699..71fb9fc 100644
--- a/demux/demux_lavf.c
+++ b/demux/demux_lavf.c
@@ -227,7 +227,7 @@ typedef struct lavf_priv {
     bool own_stream;
     char *filename;
     struct format_hack format_hack;
-    AVInputFormat *avif;
+    const AVInputFormat *avif;
     int avif_flags;
     AVFormatContext *avfc;
     AVIOContext *pb;
@@ -443,7 +443,7 @@ static int lavf_check_file(demuxer_t *demuxer, enum demux_check check)
     if (!lavfdopts->allow_mimetype || !mime_type)
         mime_type = "";
 
-    AVInputFormat *forced_format = NULL;
+    const AVInputFormat *forced_format = NULL;
     const char *format = lavfdopts->format;
     if (!format)
         format = s->lavf_type;
@@ -1354,6 +1354,8 @@ static void demux_close_lavf(demuxer_t *demuxer)
         }
         if (priv->own_stream)
             free_stream(priv->stream);
+        if (priv->av_opts)
+            av_dict_free(&priv->av_opts);
         talloc_free(priv);
         demuxer->priv = NULL;
     }
diff --git a/demux/demux_mf.c b/demux/demux_mf.c
index ec16447..40f94f4 100644
--- a/demux/demux_mf.c
+++ b/demux/demux_mf.c
@@ -289,6 +289,8 @@ static const struct {
     { "jls",            "ljpeg" },
     { "thm",            "mjpeg" },
     { "db",             "mjpeg" },
+    { "pcd",            "photocd" },
+    { "pfm",            "pfm" },
     { "pcx",            "pcx" },
     { "png",            "png" },
     { "pns",            "png" },
diff --git a/etc/_mpv.zsh b/etc/_mpv.zsh
index a15bb7c..d7803ce 100644
--- a/etc/_mpv.zsh
+++ b/etc/_mpv.zsh
@@ -42,7 +42,7 @@ function _mpv_generate_arguments {
   local -a option_aliases=()
 
   local list_options_line
-  for list_options_line in "${(@f)$($words[1] --list-options)}"; do
+  for list_options_line in "${(@f)$($~words[1] --list-options)}"; do
 
     [[ $list_options_line =~ $'^[ \t]+--([^ \t]+)[ \t]*(.*)' ]] || continue
 
@@ -146,7 +146,7 @@ function _mpv_generate_arguments {
 function _mpv_generate_protocols {
   _mpv_completion_protocols=()
   local list_protos_line
-  for list_protos_line in "${(@f)$($words[1] --list-protocols)}"; do
+  for list_protos_line in "${(@f)$($~words[1] --list-protocols)}"; do
     if [[ $list_protos_line =~ $'^[ \t]+(.*)' ]]; then
       _mpv_completion_protocols+="$match[1]"
     fi
@@ -158,7 +158,7 @@ function _mpv_generate_if_changed {
   # on the first run and re-generates it if the executable being completed for
   # is different than the one we used to generate the cached list.
   typeset -gA _mpv_completion_binary
-  local current_binary=${words[1]:c}
+  local current_binary=${~words[1]:c}
   zmodload -F zsh/stat b:zstat
   current_binary+=T$(zstat +mtime $current_binary)
   if [[ $_mpv_completion_binary[$1] != $current_binary ]]; then
@@ -207,7 +207,7 @@ case $state in
     esac
     local -a values
     local current
-    for current in "${(@f)$($words[1] --${option_name}=help)}"; do
+    for current in "${(@f)$($~words[1] --${option_name}=help)}"; do
       [[ $current =~ $pattern ]] || continue;
       local name=${match[name_group]//:/\\:} desc=${match[desc_group]}
       if [[ -n $desc ]]; then
diff --git a/etc/input.conf b/etc/input.conf
index 538443a..63da217 100644
--- a/etc/input.conf
+++ b/etc/input.conf
@@ -127,6 +127,7 @@
 #R add sub-pos +1                       #                down
 #t add sub-pos +1                       # same as previous binding (discouraged)
 #v cycle sub-visibility
+#Alt+v cycle secondary-sub-visibility
 # stretch SSA/ASS subtitles with anamorphic videos to match historical
 #V cycle sub-ass-vsfilter-aspect-compat
 # switch between applying no style overrides to SSA/ASS subtitles, and
diff --git a/filters/f_auto_filters.c b/filters/f_auto_filters.c
index a5394dd..5dd3a4a 100644
--- a/filters/f_auto_filters.c
+++ b/filters/f_auto_filters.c
@@ -329,9 +329,9 @@ static void aspeed_process(struct mp_filter *f)
 
         if (req_filter) {
             if (req_filter == 1) {
-                MP_VERBOSE(f, "adding scaletempo\n");
+                MP_VERBOSE(f, "adding scaletempo2\n");
                 p->sub.filter = mp_create_user_filter(f, MP_OUTPUT_CHAIN_AUDIO,
-                                                      "scaletempo", NULL);
+                                                      "scaletempo2", NULL);
             } else if (req_filter == 2) {
                 MP_VERBOSE(f, "adding drop\n");
                 p->sub.filter = mp_create_user_filter(f, MP_OUTPUT_CHAIN_AUDIO,
diff --git a/filters/f_auto_filters.h b/filters/f_auto_filters.h
index 98043c9..f315084 100644
--- a/filters/f_auto_filters.h
+++ b/filters/f_auto_filters.h
@@ -9,5 +9,5 @@ struct mp_filter *mp_deint_create(struct mp_filter *parent);
 // Rotate according to mp_image.rotate and VO capabilities.
 struct mp_filter *mp_autorotate_create(struct mp_filter *parent);
 
-// Insert a filter that inserts scaletempo depending on speed settings.
+// Insert a filter that inserts scaletempo2 depending on speed settings.
 struct mp_filter *mp_autoaspeed_create(struct mp_filter *parent);
diff --git a/filters/f_decoder_wrapper.c b/filters/f_decoder_wrapper.c
index 397c3a0..9be8743 100644
--- a/filters/f_decoder_wrapper.c
+++ b/filters/f_decoder_wrapper.c
@@ -110,16 +110,19 @@ struct dec_wrapper_opts {
     int64_t audio_reverse_size;
 };
 
-static int decoder_list_opt(struct mp_log *log, const m_option_t *opt,
-                            struct bstr name, struct bstr param);
+static int decoder_list_help(struct mp_log *log, const m_option_t *opt,
+                             struct bstr name);
 
 const struct m_sub_options dec_wrapper_conf = {
     .opts = (const struct m_option[]){
         {"correct-pts", OPT_FLAG(correct_pts)},
         {"fps", OPT_DOUBLE(force_fps), M_RANGE(0, DBL_MAX)},
-        {"ad", OPT_STRING_VALIDATE(audio_decoders, decoder_list_opt)},
-        {"vd", OPT_STRING_VALIDATE(video_decoders, decoder_list_opt)},
-        {"audio-spdif", OPT_STRING_VALIDATE(audio_spdif, decoder_list_opt)},
+        {"ad", OPT_STRING(audio_decoders),
+            .help = decoder_list_help},
+        {"vd", OPT_STRING(video_decoders),
+            .help = decoder_list_help},
+        {"audio-spdif", OPT_STRING(audio_spdif),
+            .help = decoder_list_help},
         {"video-rotate", OPT_CHOICE(video_rotate, {"no", -1}),
             .flags = UPDATE_IMGPAR, M_RANGE(0, 359)},
         {"video-aspect-override", OPT_ASPECT(movie_aspect),
@@ -232,11 +235,9 @@ struct priv {
     int dropped_frames; // total frames _probably_ dropped
 };
 
-static int decoder_list_opt(struct mp_log *log, const m_option_t *opt,
-                            struct bstr name, struct bstr param)
+static int decoder_list_help(struct mp_log *log, const m_option_t *opt,
+                             struct bstr name)
 {
-    if (!bstr_equals0(param, "help"))
-        return 1;
     if (strcmp(opt->name, "ad") == 0) {
         struct mp_decoder_list *list = audio_decoder_list();
         mp_print_decoders(log, MSGL_INFO, "Audio decoders:", list);
diff --git a/input/cmd.c b/input/cmd.c
index 692b9f5..3d3b7c6 100644
--- a/input/cmd.c
+++ b/input/cmd.c
@@ -341,6 +341,19 @@ static int pctx_read_token(struct parse_ctx *ctx, bstr *out)
         }
         return 1;
     }
+    if (ctx->start.len > 1 && bstr_eatstart0(&ctx->str, "!")) {
+        char endquote[2] = {ctx->str.start[0], '!'};
+        ctx->str = bstr_cut(ctx->str, 1);
+        int next = bstr_find(ctx->str, (bstr){endquote, 2});
+        if (next < 0) {
+            MP_ERR(ctx, "Unterminated custom quote: ...>%.*s<.\n", BSTR_P(start));
+            return -1;
+        }
+        *out = bstr_splice(ctx->str, 0, next);
+        ctx->str = bstr_cut(ctx->str, next+2);
+        return 1;
+    }
+
     return read_token(ctx->str, &ctx->str, out) ? 1 : 0;
 }
 
diff --git a/options/m_option.c b/options/m_option.c
index 4d222df..4c19996 100644
--- a/options/m_option.c
+++ b/options/m_option.c
@@ -61,6 +61,31 @@ const char m_option_path_separator = OPTION_PATH_SEPARATOR;
 #define OPT_INT_MAX(opt, T, Tm) ((opt)->min < (opt)->max \
     ? ((opt)->max >= (double)(Tm) ? (Tm) : (T)((opt)->max)) : (Tm))
 
+int m_option_parse(struct mp_log *log, const m_option_t *opt,
+                   struct bstr name, struct bstr param, void *dst)
+{
+    int r = M_OPT_INVALID;
+    if (bstr_equals0(param, "help") && opt->help) {
+        r = opt->help(log, opt, name);
+        if (r < 0)
+            return r;
+    }
+
+    r = opt->type->parse(log, opt, name, param, dst);
+    if (r < 0)
+        return r;
+
+    if (opt->validate) {
+        r = opt->validate(log, opt, name, dst);
+        if (r < 0) {
+            if (opt->type->free)
+                opt->type->free(dst);
+            return r;
+        }
+    }
+    return 1;
+}
+
 char *m_option_strerror(int code)
 {
     switch (code) {
@@ -1192,13 +1217,6 @@ const m_option_type_t m_option_type_aspect = {
 static int parse_str(struct mp_log *log, const m_option_t *opt,
                      struct bstr name, struct bstr param, void *dst)
 {
-    m_opt_string_validate_fn validate = opt->priv;
-    if (validate) {
-        int r = validate(log, opt, name, param);
-        if (r < 0)
-            return r;
-    }
-
     if (dst) {
         talloc_free(VAL(dst));
         VAL(dst) = bstrdup0(NULL, param);
diff --git a/options/m_option.h b/options/m_option.h
index afd86ea..322f120 100644
--- a/options/m_option.h
+++ b/options/m_option.h
@@ -189,9 +189,15 @@ struct m_opt_choice_alternatives {
 const char *m_opt_choice_str(const struct m_opt_choice_alternatives *choices,
                              int value);
 
-// For OPT_STRING_VALIDATE(). Behaves like m_option_type.parse().
+// Validator function signatures. Required to properly type the param value.
+typedef int (*m_opt_generic_validate_fn)(struct mp_log *log, const m_option_t *opt,
+                                         struct bstr name, void *value);
+
 typedef int (*m_opt_string_validate_fn)(struct mp_log *log, const m_option_t *opt,
-                                        struct bstr name, struct bstr param);
+                                        struct bstr name, const char **value);
+typedef int (*m_opt_int_validate_fn)(struct mp_log *log, const m_option_t *opt,
+                                     struct bstr name, const int *value);
+
 
 // m_option.priv points to this if OPT_SUBSTRUCT is used
 struct m_sub_options {
@@ -270,6 +276,9 @@ struct m_option_type {
 
     // Parse the data from a string.
     /** It is the only required function, all others can be NULL.
+     *  Generally should not be called directly outside of the options module,
+     *  but instead through \ref m_option_parse which calls additional option
+     *  specific callbacks during the process.
      *
      *  \param log for outputting parser error or help messages
      *  \param opt The option that is parsed.
@@ -384,6 +393,12 @@ struct m_option {
     // Print a warning when this option is used (for options with no direct
     // replacement.)
     const char *deprecation_message;
+
+    // Optional function that validates a param value for this option.
+    m_opt_generic_validate_fn validate;
+
+    // Optional function that displays help. Will replace type-specific help.
+    int (*help)(struct mp_log *log, const m_option_t *opt, struct bstr name);
 };
 
 char *format_file_size(int64_t size);
@@ -490,12 +505,13 @@ char *format_file_size(int64_t size);
 
 char *m_option_strerror(int code);
 
-// Helper to parse options, see \ref m_option_type::parse.
-static inline int m_option_parse(struct mp_log *log, const m_option_t *opt,
-                                 struct bstr name, struct bstr param, void *dst)
-{
-    return opt->type->parse(log, opt, name, param, dst);
-}
+// Base function to parse options. Includes calling help and validation
+// callbacks. Only when this functionality is for some reason required to not
+// happen should the parse function pointer be utilized by itself.
+//
+// See \ref m_option_type::parse.
+int m_option_parse(struct mp_log *log, const m_option_t *opt,
+                   struct bstr name, struct bstr param, void *dst);
 
 // Helper to print options, see \ref m_option_type::print.
 static inline char *m_option_print(const m_option_t *opt, const void *val_ptr)
@@ -661,9 +677,15 @@ extern const char m_option_path_separator;
 #define OPT_CHANNELS(field) \
     OPT_TYPED_FIELD(m_option_type_channels, struct m_channels, field)
 
+#define OPT_INT_VALIDATE(field, validate_fn) \
+    OPT_TYPED_FIELD(m_option_type_int, int, field), \
+    .validate = (m_opt_generic_validate_fn) \
+        MP_EXPECT_TYPE(m_opt_int_validate_fn, validate_fn)
+
 #define OPT_STRING_VALIDATE(field, validate_fn) \
     OPT_TYPED_FIELD(m_option_type_string, char*, field), \
-    .priv = MP_EXPECT_TYPE(m_opt_string_validate_fn, validate_fn)
+    .validate = (m_opt_generic_validate_fn) \
+        MP_EXPECT_TYPE(m_opt_string_validate_fn, validate_fn)
 
 #define M_CHOICES(...) \
     .priv = (void *)&(const struct m_opt_choice_alternatives[]){ __VA_ARGS__, {0}}
diff --git a/options/options.c b/options/options.c
index a11c111..cf0eebf 100644
--- a/options/options.c
+++ b/options/options.c
@@ -46,6 +46,7 @@
 #include "player/core.h"
 #include "player/command.h"
 #include "stream/stream.h"
+#include "demux/demux.h"
 
 #if HAVE_DRM
 #include "video/out/drm_common.h"
@@ -86,6 +87,7 @@ extern const struct m_sub_options ao_conf;
 
 extern const struct m_sub_options opengl_conf;
 extern const struct m_sub_options vulkan_conf;
+extern const struct m_sub_options vulkan_display_conf;
 extern const struct m_sub_options spirv_conf;
 extern const struct m_sub_options d3d11_conf;
 extern const struct m_sub_options d3d11va_conf;
@@ -112,7 +114,8 @@ static const m_option_t mp_vo_opt_list[] = {
     {"ontop-level", OPT_CHOICE(ontop_level, {"window", -1}, {"system", -2},
         {"desktop", -3}), M_RANGE(0, INT_MAX)},
     {"border", OPT_FLAG(border)},
-    {"fit-border", OPT_FLAG(fit_border)},
+    {"fit-border", OPT_FLAG(fit_border),
+     .deprecation_message = "the option is ignored and no longer needed"},
     {"on-all-workspaces", OPT_FLAG(all_workspaces)},
     {"geometry", OPT_GEOMETRY(geometry)},
     {"autofit", OPT_SIZE_BOX(autofit)},
@@ -147,8 +150,10 @@ static const m_option_t mp_vo_opt_list[] = {
         {"no", 0}, {"yes", 1}, {"downscale-big", 2})},
     {"wid", OPT_INT64(WinID)},
     {"screen", OPT_CHOICE(screen_id, {"default", -1}), M_RANGE(0, 32)},
+    {"screen-name", OPT_STRING(screen_name)},
     {"fs-screen", OPT_CHOICE(fsscreen_id, {"all", -2}, {"current", -1}),
         M_RANGE(0, 32)},
+    {"fs-screen-name", OPT_STRING(fsscreen_name)},
     {"keepaspect", OPT_FLAG(keepaspect)},
     {"keepaspect-window", OPT_FLAG(keepaspect_window)},
     {"hidpi-window-scale", OPT_FLAG(hidpi_window_scale)},
@@ -193,6 +198,7 @@ const struct m_sub_options vo_sub_opts = {
         .snap_window = 0,
         .border = 1,
         .fit_border = 1,
+        .appid = "mpv",
         .WinID = -1,
         .window_scale = 1.0,
         .x11_bypass_compositor = 2,
@@ -232,6 +238,7 @@ const struct m_sub_options mp_subtitle_sub_opts = {
         {"sub-fps", OPT_FLOAT(sub_fps)},
         {"sub-speed", OPT_FLOAT(sub_speed)},
         {"sub-visibility", OPT_FLAG(sub_visibility)},
+        {"secondary-sub-visibility", OPT_FLAG(sec_sub_visibility)},
         {"sub-forced-only", OPT_CHOICE(forced_subs_only,
             {"auto", -1}, {"no", 0}, {"yes", 1})},
         {"stretch-dvd-subs", OPT_FLAG(stretch_dvd_subs)},
@@ -269,11 +276,13 @@ const struct m_sub_options mp_subtitle_sub_opts = {
         {"sub", OPT_SUBSTRUCT(sub_style, sub_style_conf)},
         {"sub-clear-on-seek", OPT_FLAG(sub_clear_on_seek)},
         {"teletext-page", OPT_INT(teletext_page), M_RANGE(1, 999)},
+        {"sub-past-video-end", OPT_FLAG(sub_past_video_end)},
         {0}
     },
     .size = sizeof(OPT_BASE_STRUCT),
     .defaults = &(OPT_BASE_STRUCT){
         .sub_visibility = 1,
+        .sec_sub_visibility = 1,
         .forced_subs_only = -1,
         .sub_pos = 100,
         .sub_speed = 1.0,
@@ -512,9 +521,9 @@ static const m_option_t mp_opts[] = {
 #endif
 
     // demuxer.c - select audio/sub file/demuxer
-    {"demuxer", OPT_STRING(demuxer_name)},
-    {"audio-demuxer", OPT_STRING(audio_demuxer_name)},
-    {"sub-demuxer", OPT_STRING(sub_demuxer_name)},
+    {"demuxer", OPT_STRING(demuxer_name), .help = demuxer_help},
+    {"audio-demuxer", OPT_STRING(audio_demuxer_name), .help = demuxer_help},
+    {"sub-demuxer", OPT_STRING(sub_demuxer_name), .help = demuxer_help},
     {"demuxer-thread", OPT_FLAG(demuxer_thread)},
     {"demuxer-termination-timeout", OPT_DOUBLE(demux_termination_timeout)},
     {"demuxer-cache-wait", OPT_FLAG(demuxer_cache_wait)},
@@ -588,7 +597,7 @@ static const m_option_t mp_opts[] = {
     {"audio-file-auto", OPT_CHOICE(audiofile_auto,
         {"no", -1}, {"exact", 0}, {"fuzzy", 1}, {"all", 2})},
     {"cover-art-auto", OPT_CHOICE(coverart_auto,
-        {"no", -1}, {"fuzzy", 1})},
+        {"no", -1}, {"exact", 0}, {"fuzzy", 1}, {"all", 2})},
 
     {"", OPT_SUBSTRUCT(subs_rend, mp_subtitle_sub_opts)},
     {"", OPT_SUBSTRUCT(subs_filt, mp_sub_filter_opts)},
@@ -620,7 +629,7 @@ static const m_option_t mp_opts[] = {
         {"album", 2}),
         .flags = UPDATE_VOL},
     {"replaygain-preamp", OPT_FLOAT(rgain_preamp), .flags = UPDATE_VOL,
-        M_RANGE(-15, 15)},
+        M_RANGE(-150, 150)},
     {"replaygain-clip", OPT_FLAG(rgain_clip), .flags = UPDATE_VOL},
     {"replaygain-fallback", OPT_FLOAT(rgain_fallback), .flags = UPDATE_VOL,
         M_RANGE(-200, 60)},
@@ -775,6 +784,7 @@ static const m_option_t mp_opts[] = {
 
 #if HAVE_VULKAN
     {"", OPT_SUBSTRUCT(vulkan_opts, vulkan_conf)},
+    {"", OPT_SUBSTRUCT(vulkan_display_opts, vulkan_display_conf)},
 #endif
 
 #if HAVE_D3D11
@@ -1028,6 +1038,7 @@ static const struct MPOpts mp_default_opts = {
         "Artist", "Album", "Album_Artist", "Comment", "Composer",
         "Date", "Description", "Genre", "Performer", "Rating",
         "Series", "Title", "Track", "icy-title", "service_name",
+        "Uploader", "Channel_URL",
         NULL
     },
 
diff --git a/options/options.h b/options/options.h
index b865ff8..f0de678 100644
--- a/options/options.h
+++ b/options/options.h
@@ -22,7 +22,9 @@ typedef struct mp_vo_opts {
     bool focus_on_open;
 
     int screen_id;
+    char *screen_name;
     int fsscreen_id;
+    char *fsscreen_name;
     char *winname;
     char *appid;
     int x11_netwm;
@@ -71,6 +73,7 @@ typedef struct mp_vo_opts {
 // Subtitle options needed by the subtitle decoders/renderers.
 struct mp_subtitle_opts {
     int sub_visibility;
+    int sec_sub_visibility;
     int sub_pos;
     float sub_delay;
     float sub_fps;
@@ -104,6 +107,7 @@ struct mp_subtitle_opts {
     int ass_justify;
     int sub_clear_on_seek;
     int teletext_page;
+    int sub_past_video_end;
 };
 
 struct mp_sub_filter_opts {
@@ -341,6 +345,7 @@ typedef struct MPOpts {
     struct angle_opts *angle_opts;
     struct opengl_opts *opengl_opts;
     struct vulkan_opts *vulkan_opts;
+    struct vulkan_display_opts *vulkan_display_opts;
     struct spirv_opts *spirv_opts;
     struct d3d11_opts *d3d11_opts;
     struct d3d11va_opts *d3d11va_opts;
diff --git a/osdep/macos/libmpv_helper.swift b/osdep/macos/libmpv_helper.swift
index d1b00cf..b140f99 100644
--- a/osdep/macos/libmpv_helper.swift
+++ b/osdep/macos/libmpv_helper.swift
@@ -47,23 +47,26 @@ class LibmpvHelper {
     }
 
     func initRender() {
-        var advanced: CInt = 1
+        let advanced: CInt = 1
         let api = UnsafeMutableRawPointer(mutating: (MPV_RENDER_API_TYPE_OPENGL as NSString).utf8String)
-        var pAddress = mpv_opengl_init_params(get_proc_address: getProcAddress,
+        let pAddress = mpv_opengl_init_params(get_proc_address: getProcAddress,
                                               get_proc_address_ctx: nil,
                                               extra_exts: nil)
-        var params: [mpv_render_param] = [
-            mpv_render_param(type: MPV_RENDER_PARAM_API_TYPE, data: api),
-            mpv_render_param(type: MPV_RENDER_PARAM_OPENGL_INIT_PARAMS, data: &pAddress),
-            mpv_render_param(type: MPV_RENDER_PARAM_ADVANCED_CONTROL, data: &advanced),
-            mpv_render_param()
-        ]
-
-        if (mpv_render_context_create(&mpvRenderContext, mpvHandle, &params) < 0)
-        {
-            log.sendError("Render context init has failed.")
-            exit(1)
+
+        MPVHelper.withUnsafeMutableRawPointers([pAddress, advanced]) { (pointers: [UnsafeMutableRawPointer?]) in
+            var params: [mpv_render_param] = [
+                mpv_render_param(type: MPV_RENDER_PARAM_API_TYPE, data: api),
+                mpv_render_param(type: MPV_RENDER_PARAM_OPENGL_INIT_PARAMS, data: pointers[0]),
+                mpv_render_param(type: MPV_RENDER_PARAM_ADVANCED_CONTROL, data: pointers[1]),
+                mpv_render_param()
+            ]
+
+            if (mpv_render_context_create(&mpvRenderContext, mpvHandle, &params) < 0) {
+                log.sendError("Render context init has failed.")
+                exit(1)
+            }
         }
+
     }
 
     let getProcAddress: (@convention(c) (UnsafeMutableRawPointer?, UnsafePointer<Int8>?)
@@ -119,26 +122,29 @@ class LibmpvHelper {
         deinitLock.lock()
         if mpvRenderContext != nil {
             var i: GLint = 0
-            var flip: CInt = 1
-            var skip: CInt = skip ? 1 : 0
-            var ditherDepth = depth
+            let flip: CInt = 1
+            let skip: CInt = skip ? 1 : 0
+            let ditherDepth = depth
             glGetIntegerv(GLenum(GL_DRAW_FRAMEBUFFER_BINDING), &i)
             // CAOpenGLLayer has ownership of FBO zero yet can return it to us,
             // so only utilize a newly received FBO ID if it is nonzero.
             fbo = i != 0 ? i : fbo
 
-            var data = mpv_opengl_fbo(fbo: Int32(fbo),
+            let data = mpv_opengl_fbo(fbo: Int32(fbo),
                                         w: Int32(surface.width),
                                         h: Int32(surface.height),
                           internal_format: 0)
-            var params: [mpv_render_param] = [
-                mpv_render_param(type: MPV_RENDER_PARAM_OPENGL_FBO, data: &data),
-                mpv_render_param(type: MPV_RENDER_PARAM_FLIP_Y, data: &flip),
-                mpv_render_param(type: MPV_RENDER_PARAM_DEPTH, data: &ditherDepth),
-                mpv_render_param(type: MPV_RENDER_PARAM_SKIP_RENDERING, data: &skip),
-                mpv_render_param()
-            ]
-            mpv_render_context_render(mpvRenderContext, &params);
+
+            MPVHelper.withUnsafeMutableRawPointers([data, flip, ditherDepth, skip]) { (pointers: [UnsafeMutableRawPointer?]) in
+                var params: [mpv_render_param] = [
+                    mpv_render_param(type: MPV_RENDER_PARAM_OPENGL_FBO, data: pointers[0]),
+                    mpv_render_param(type: MPV_RENDER_PARAM_FLIP_Y, data: pointers[1]),
+                    mpv_render_param(type: MPV_RENDER_PARAM_DEPTH, data: pointers[2]),
+                    mpv_render_param(type: MPV_RENDER_PARAM_SKIP_RENDERING, data: pointers[3]),
+                    mpv_render_param()
+                ]
+                mpv_render_context_render(mpvRenderContext, &params);
+            }
         } else {
             glClearColor(0, 0, 0, 1)
             glClear(GLbitfield(GL_COLOR_BUFFER_BIT))
@@ -161,16 +167,20 @@ class LibmpvHelper {
             let u8Ptr = baseAddress.assumingMemoryBound(to: UInt8.self)
             let iccBstr = bstrdup(nil, bstr(start: u8Ptr, len: ptr.count))
             var icc = mpv_byte_array(data: iccBstr.start, size: iccBstr.len)
-            let params = mpv_render_param(type: MPV_RENDER_PARAM_ICC_PROFILE, data: &icc)
-            mpv_render_context_set_parameter(mpvRenderContext, params)
+            withUnsafeMutableBytes(of: &icc) { (ptr: UnsafeMutableRawBufferPointer) in
+                let params = mpv_render_param(type: MPV_RENDER_PARAM_ICC_PROFILE, data: ptr.baseAddress)
+                mpv_render_context_set_parameter(mpvRenderContext, params)
+            }
         }
     }
 
     func setRenderLux(_ lux: Int) {
         if mpvRenderContext == nil { return }
         var light = lux
-        let params = mpv_render_param(type: MPV_RENDER_PARAM_AMBIENT_LIGHT, data: &light)
-        mpv_render_context_set_parameter(mpvRenderContext, params)
+        withUnsafeMutableBytes(of: &light) { (ptr: UnsafeMutableRawBufferPointer) in
+            let params = mpv_render_param(type: MPV_RENDER_PARAM_AMBIENT_LIGHT, data: ptr.baseAddress)
+            mpv_render_context_set_parameter(mpvRenderContext, params)
+        }
     }
 
     func commandAsync(_ cmd: [String?], id: UInt64 = 1) {
diff --git a/osdep/macos/mpv_helper.swift b/osdep/macos/mpv_helper.swift
index 0e207b9..6fde975 100644
--- a/osdep/macos/mpv_helper.swift
+++ b/osdep/macos/mpv_helper.swift
@@ -86,17 +86,23 @@ class MPVHelper {
 
     func setOption(fullscreen: Bool) {
         optsPtr.pointee.fullscreen = fullscreen
-        m_config_cache_write_opt(optsCachePtr, UnsafeMutableRawPointer(&optsPtr.pointee.fullscreen))
+        _ = withUnsafeMutableBytes(of: &optsPtr.pointee.fullscreen) { (ptr: UnsafeMutableRawBufferPointer) in
+            m_config_cache_write_opt(optsCachePtr, ptr.baseAddress)
+        }
     }
 
     func setOption(minimized: Bool) {
         optsPtr.pointee.window_minimized = Int32(minimized)
-        m_config_cache_write_opt(optsCachePtr, UnsafeMutableRawPointer(&optsPtr.pointee.window_minimized))
+        _ = withUnsafeMutableBytes(of: &optsPtr.pointee.window_minimized) { (ptr: UnsafeMutableRawBufferPointer) in
+            m_config_cache_write_opt(optsCachePtr, ptr.baseAddress)
+        }
     }
 
     func setOption(maximized: Bool) {
         optsPtr.pointee.window_maximized = Int32(maximized)
-        m_config_cache_write_opt(optsCachePtr, UnsafeMutableRawPointer(&optsPtr.pointee.window_maximized))
+        _ = withUnsafeMutableBytes(of: &optsPtr.pointee.window_maximized) { (ptr: UnsafeMutableRawBufferPointer) in
+            m_config_cache_write_opt(optsCachePtr, ptr.baseAddress)
+        }
     }
 
     func setMacOptionCallback(_ callback: swift_wakeup_cb_fn, context object: AnyObject) {
@@ -123,4 +129,28 @@ class MPVHelper {
     class func bridge<T: AnyObject>(ptr: UnsafeRawPointer) -> T {
         return Unmanaged<T>.fromOpaque(ptr).takeUnretainedValue()
     }
+
+    class func withUnsafeMutableRawPointers(_ arguments: [Any],
+                                               pointers: [UnsafeMutableRawPointer?] = [],
+                                                closure: (_ pointers: [UnsafeMutableRawPointer?]) -> Void) {
+        if arguments.count > 0 {
+            let args = Array(arguments.dropFirst(1))
+            var newPtrs = pointers
+            var firstArg = arguments.first
+            withUnsafeMutableBytes(of: &firstArg) { (ptr: UnsafeMutableRawBufferPointer) in
+                newPtrs.append(ptr.baseAddress)
+                withUnsafeMutableRawPointers(args, pointers: newPtrs, closure: closure)
+            }
+
+            return
+        }
+
+        closure(pointers)
+    }
+
+    class func getPointer<T>(_ value: inout T) -> UnsafeMutableRawPointer? {
+        return withUnsafeMutableBytes(of: &value) { (ptr: UnsafeMutableRawBufferPointer) in
+            ptr.baseAddress
+        }
+    }
 }
diff --git a/osdep/macos/swift_compat.swift b/osdep/macos/swift_compat.swift
index c14aa08..24c00b0 100644
--- a/osdep/macos/swift_compat.swift
+++ b/osdep/macos/swift_compat.swift
@@ -33,7 +33,6 @@ extension String {
 #endif
 
 extension NSPasteboard.PasteboardType {
-
     static let fileURLCompat: NSPasteboard.PasteboardType = {
         if #available(OSX 10.13, *) {
             return .fileURL
@@ -53,7 +52,6 @@ extension NSPasteboard.PasteboardType {
 
 #if !swift(>=5.0)
 extension Data {
-
     mutating func withUnsafeMutableBytes<Type>(_ body: (UnsafeMutableRawBufferPointer) throws -> Type) rethrows -> Type {
         let dataCount = count
         return try withUnsafeMutableBytes { (ptr: UnsafeMutablePointer<UInt8>) throws -> Type in
@@ -65,33 +63,8 @@ extension Data {
 
 #if !swift(>=4.2)
 extension NSDraggingInfo {
-
     var draggingPasteboard: NSPasteboard {
         get { return draggingPasteboard() }
     }
 }
 #endif
-
-#if !swift(>=4.1)
-extension Array {
-
-    func compactMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult] {
-        return try self.flatMap(transform)
-    }
-}
-
-extension Array where Element == [CGLPixelFormatAttribute] {
-
-    func contains(_ obj: [CGLPixelFormatAttribute]) -> Bool {
-        return self.contains(where:{ $0 == obj })
-    }
-}
-
-extension NSWindow.Level {
-
-    static func +(left: NSWindow.Level, right: Int) -> NSWindow.Level {
-        return NSWindow.Level(left.rawValue + right)
-    }
-}
-#endif
-
diff --git a/osdep/macosx_application.h b/osdep/macosx_application.h
index 9a366d8..05d0b07 100644
--- a/osdep/macosx_application.h
+++ b/osdep/macosx_application.h
@@ -21,6 +21,11 @@
 #include "osdep/macosx_menubar.h"
 #include "options/m_option.h"
 
+enum {
+    FRAME_VISIBLE = 0,
+    FRAME_WHOLE,
+};
+
 struct macos_opts {
     int macos_title_bar_style;
     int macos_title_bar_appearance;
@@ -29,6 +34,7 @@ struct macos_opts {
     int macos_fs_animation_duration;
     int macos_force_dedicated_gpu;
     int macos_app_activation_policy;
+    int macos_geometry_calculation;
     int cocoa_cb_sw_renderer;
     int cocoa_cb_10bit_context;
 };
diff --git a/osdep/macosx_application.m b/osdep/macosx_application.m
index 95c6a3f..bb8b67b 100644
--- a/osdep/macosx_application.m
+++ b/osdep/macosx_application.m
@@ -65,6 +65,8 @@ const struct m_sub_options macos_conf = {
         {"macos-force-dedicated-gpu", OPT_FLAG(macos_force_dedicated_gpu)},
         {"macos-app-activation-policy", OPT_CHOICE(macos_app_activation_policy,
             {"regular", 0}, {"accessory", 1}, {"prohibited", 2})},
+        {"macos-geometry-calculation", OPT_CHOICE(macos_geometry_calculation,
+            {"visible", FRAME_VISIBLE}, {"whole", FRAME_WHOLE})},
         {"cocoa-cb-sw-renderer", OPT_CHOICE(cocoa_cb_sw_renderer,
             {"auto", -1}, {"no", 0}, {"yes", 1})},
         {"cocoa-cb-10bit-context", OPT_FLAG(cocoa_cb_10bit_context)},
diff --git a/osdep/macosx_menubar.m b/osdep/macosx_menubar.m
index 11fdda5..6fefcb9 100644
--- a/osdep/macosx_menubar.m
+++ b/osdep/macosx_menubar.m
@@ -218,6 +218,13 @@
                         @"target"     : self,
                         @"cmd"        : @"cycle ontop"
                     }],
+                    [NSMutableDictionary dictionaryWithDictionary:@{
+                        @"name"       : @"Toggle Visibility on All Workspaces",
+                        @"action"     : @"cmd:",
+                        @"key"        : @"",
+                        @"target"     : self,
+                        @"cmd"        : @"cycle on-all-workspaces"
+                    }],
 #if HAVE_MACOS_TOUCHBAR
                     @{ @"name": @"separator" },
                     [NSMutableDictionary dictionaryWithDictionary:@{
diff --git a/osdep/macosx_touchbar.h b/osdep/macosx_touchbar.h
index 0aa5a05..a03b68c 100644
--- a/osdep/macosx_touchbar.h
+++ b/osdep/macosx_touchbar.h
@@ -41,5 +41,6 @@ struct mpv_event;
 @property(nonatomic, retain) NSDictionary *touchbarItems;
 @property(nonatomic, assign) double duration;
 @property(nonatomic, assign) double position;
+@property(nonatomic, assign) int pause;
 
 @end
diff --git a/osdep/macosx_touchbar.m b/osdep/macosx_touchbar.m
index c189e32..ccce8f7 100644
--- a/osdep/macosx_touchbar.m
+++ b/osdep/macosx_touchbar.m
@@ -24,6 +24,7 @@
 @synthesize touchbarItems = _touchbar_items;
 @synthesize duration = _duration;
 @synthesize position = _position;
+@synthesize pause = _pause;
 
 - (id)init
 {
@@ -86,58 +87,25 @@
                 @"name": @"Time Left"
             }]
         };
-    }
-    return self;
-}
-
--(void)processEvent:(struct mpv_event *)event
-{
-    switch (event->event_id) {
-    case MPV_EVENT_END_FILE: {
-        self.position = 0;
-        self.duration = 0;
-        break;
-    }
-    case MPV_EVENT_PROPERTY_CHANGE: {
-        [self handlePropertyChange:(mpv_event_property *)event->data];
-        break;
-    }
-    }
-}
-
--(void)handlePropertyChange:(struct mpv_event_property *)property
-{
-    NSString *name = [NSString stringWithUTF8String:property->name];
-    mpv_format format = property->format;
 
-    if ([name isEqualToString:@"time-pos"] && format == MPV_FORMAT_DOUBLE) {
-        self.position = *(double *)property->data;
-        self.position = self.position < 0 ? 0 : self.position;
-        [self updateTouchBarTimeItems];
-    } else if ([name isEqualToString:@"duration"] && format == MPV_FORMAT_DOUBLE) {
-        self.duration = *(double *)property->data;
-        [self updateTouchBarTimeItems];
-    } else if ([name isEqualToString:@"pause"] && format == MPV_FORMAT_FLAG) {
-        NSButton *playButton = self.touchbarItems[play][@"view"];
-        if (*(int *)property->data) {
-            playButton.image = self.touchbarItems[play][@"imageAlt"];
-        } else {
-            playButton.image = self.touchbarItems[play][@"image"];
-        }
+        [self addObserver:self forKeyPath:@"visible" options:0 context:nil];
     }
+    return self;
 }
 
 - (nullable NSTouchBarItem *)touchBar:(NSTouchBar *)touchBar
                 makeItemForIdentifier:(NSTouchBarItemIdentifier)identifier
 {
     if ([self.touchbarItems[identifier][@"type"] isEqualToString:@"slider"]) {
-        NSSliderTouchBarItem *tbItem = [[NSSliderTouchBarItem alloc] initWithIdentifier:identifier];
-        tbItem.slider.minValue = 0.0f;
-        tbItem.slider.maxValue = 100.0f;
-        tbItem.target = self;
-        tbItem.action = @selector(seekbarChanged:);
+        NSCustomTouchBarItem *tbItem = [[NSCustomTouchBarItem alloc] initWithIdentifier:identifier];
+        NSSlider *slider = [NSSlider sliderWithTarget:self action:@selector(seekbarChanged:)];
+        slider.minValue = 0.0f;
+        slider.maxValue = 100.0f;
+        tbItem.view = slider;
         tbItem.customizationLabel = self.touchbarItems[identifier][@"name"];
-        [self.touchbarItems[identifier] setObject:tbItem.slider forKey:@"view"];
+        [self.touchbarItems[identifier] setObject:slider forKey:@"view"];
+        [self.touchbarItems[identifier] setObject:tbItem forKey:@"tbItem"];
+        [tbItem addObserver:self forKeyPath:@"visible" options:0 context:nil];
         return tbItem;
     } else if ([self.touchbarItems[identifier][@"type"] isEqualToString:@"button"]) {
         NSCustomTouchBarItem *tbItem = [[NSCustomTouchBarItem alloc] initWithIdentifier:identifier];
@@ -146,6 +114,8 @@
         tbItem.view = tbButton;
         tbItem.customizationLabel = self.touchbarItems[identifier][@"name"];
         [self.touchbarItems[identifier] setObject:tbButton forKey:@"view"];
+        [self.touchbarItems[identifier] setObject:tbItem forKey:@"tbItem"];
+        [tbItem addObserver:self forKeyPath:@"visible" options:0 context:nil];
         return tbItem;
     } else if ([self.touchbarItems[identifier][@"type"] isEqualToString:@"text"]) {
         NSCustomTouchBarItem *tbItem = [[NSCustomTouchBarItem alloc] initWithIdentifier:identifier];
@@ -154,12 +124,124 @@
         tbItem.view = tbText;
         tbItem.customizationLabel = self.touchbarItems[identifier][@"name"];
         [self.touchbarItems[identifier] setObject:tbText forKey:@"view"];
+        [self.touchbarItems[identifier] setObject:tbItem forKey:@"tbItem"];
+        [tbItem addObserver:self forKeyPath:@"visible" options:0 context:nil];
         return tbItem;
     }
 
     return nil;
 }
 
+- (void)observeValueForKeyPath:(NSString *)keyPath
+                      ofObject:(id)object
+                        change:(NSDictionary<NSKeyValueChangeKey,id> *)change
+                       context:(void *)context {
+    if ([keyPath isEqualToString:@"visible"]) {
+        NSNumber *visible = [object valueForKey:@"visible"];
+        if (visible.boolValue) {
+            [self updateTouchBarTimeItems];
+            [self updatePlayButton];
+        }
+    }
+}
+
+- (void)updateTouchBarTimeItems
+{
+    if (!self.isVisible)
+        return;
+
+    [self updateSlider];
+    [self updateTimeLeft];
+    [self updateCurrentPosition];
+}
+
+- (void)updateSlider
+{
+    NSCustomTouchBarItem *tbItem = self.touchbarItems[seekBar][@"tbItem"];
+    if (!tbItem.visible)
+        return;
+
+    NSSlider *seekSlider = self.touchbarItems[seekBar][@"view"];
+
+    if (self.duration <= 0) {
+        seekSlider.enabled = NO;
+        seekSlider.doubleValue = 0;
+    } else {
+        seekSlider.enabled = YES;
+        if (!seekSlider.highlighted)
+            seekSlider.doubleValue = (self.position/self.duration)*100;
+    }
+}
+
+- (void)updateTimeLeft
+{
+    NSCustomTouchBarItem *tbItem = self.touchbarItems[timeLeft][@"tbItem"];
+    if (!tbItem.visible)
+        return;
+
+    NSTextField *timeLeftItem = self.touchbarItems[timeLeft][@"view"];
+
+    [self removeConstraintForIdentifier:timeLeft];
+    if (self.duration <= 0) {
+        timeLeftItem.stringValue = @"";
+    } else {
+        int left = (int)(floor(self.duration)-floor(self.position));
+        NSString *leftFormat = [self formatTime:left];
+        NSString *durFormat = [self formatTime:self.duration];
+        timeLeftItem.stringValue = [NSString stringWithFormat:@"-%@", leftFormat];
+        [self applyConstraintFromString:[NSString stringWithFormat:@"-%@", durFormat]
+                          forIdentifier:timeLeft];
+    }
+}
+
+- (void)updateCurrentPosition
+{
+    NSCustomTouchBarItem *tbItem = self.touchbarItems[currentPosition][@"tbItem"];
+    if (!tbItem.visible)
+        return;
+
+    NSTextField *curPosItem = self.touchbarItems[currentPosition][@"view"];
+    NSString *posFormat = [self formatTime:(int)floor(self.position)];
+    curPosItem.stringValue = posFormat;
+
+    [self removeConstraintForIdentifier:currentPosition];
+    if (self.duration <= 0) {
+        [self applyConstraintFromString:[self formatTime:self.position]
+                          forIdentifier:currentPosition];
+    } else {
+        NSString *durFormat = [self formatTime:self.duration];
+        [self applyConstraintFromString:durFormat forIdentifier:currentPosition];
+    }
+}
+
+- (void)updatePlayButton
+{
+    NSCustomTouchBarItem *tbItem = self.touchbarItems[play][@"tbItem"];
+    if (!self.isVisible || !tbItem.visible)
+        return;
+
+    NSButton *playButton = self.touchbarItems[play][@"view"];
+    if (self.pause) {
+        playButton.image = self.touchbarItems[play][@"imageAlt"];
+    } else {
+        playButton.image = self.touchbarItems[play][@"image"];
+    }
+}
+
+- (void)buttonAction:(NSButton *)sender
+{
+    NSString *identifier = [self getIdentifierFromView:sender];
+    [self.app queueCommand:(char *)[self.touchbarItems[identifier][@"cmd"] UTF8String]];
+}
+
+- (void)seekbarChanged:(NSSlider *)slider
+{
+    NSString *identifier = [self getIdentifierFromView:slider];
+    NSString *seek = [NSString stringWithFormat:
+        self.touchbarItems[identifier][@"cmd"], slider.doubleValue];
+    [self.app queueCommand:(char *)[seek UTF8String]];
+}
+
 - (NSString *)formatTime:(int)time
 {
     int seconds = time % 60;
@@ -204,48 +286,6 @@
     }
 }
 
-- (void)updateTouchBarTimeItemConstrains
-{
-    [self removeConstraintForIdentifier:currentPosition];
-    [self removeConstraintForIdentifier:timeLeft];
-
-    if (self.duration <= 0) {
-        [self applyConstraintFromString:[self formatTime:self.position]
-                          forIdentifier:currentPosition];
-    } else {
-        NSString *durFormat = [self formatTime:self.duration];
-
-        [self applyConstraintFromString:durFormat forIdentifier:currentPosition];
-        [self applyConstraintFromString:[NSString stringWithFormat:@"-%@", durFormat]
-                          forIdentifier:timeLeft];
-    }
-}
-
-- (void)updateTouchBarTimeItems
-{
-    NSSlider *seekSlider = self.touchbarItems[seekBar][@"view"];
-    NSTextField *curPosItem = self.touchbarItems[currentPosition][@"view"];
-    NSTextField *timeLeftItem = self.touchbarItems[timeLeft][@"view"];
-
-    if (self.duration <= 0) {
-        seekSlider.enabled = NO;
-        seekSlider.doubleValue = 0;
-        timeLeftItem.stringValue = @"";
-    }
-    else {
-        seekSlider.enabled = YES;
-        if (!seekSlider.highlighted)
-            seekSlider.doubleValue = (self.position/self.duration)*100;
-        int left = (int)(floor(self.duration)-floor(self.position));
-        NSString *leftFormat = [self formatTime:left];
-        timeLeftItem.stringValue = [NSString stringWithFormat:@"-%@", leftFormat];
-    }
-    NSString *posFormat = [self formatTime:(int)floor(self.position)];
-    curPosItem.stringValue = posFormat;
-
-    [self updateTouchBarTimeItemConstrains];
-}
-
 - (NSString *)getIdentifierFromView:(id)view
 {
     NSString *identifier;
@@ -255,18 +295,40 @@
     return identifier;
 }
 
-- (void)buttonAction:(NSButton *)sender
+- (void)processEvent:(struct mpv_event *)event
 {
-    NSString *identifier = [self getIdentifierFromView:sender];
-    [self.app queueCommand:(char *)[self.touchbarItems[identifier][@"cmd"] UTF8String]];
+    switch (event->event_id) {
+    case MPV_EVENT_END_FILE: {
+        self.position = 0;
+        self.duration = 0;
+        break;
+    }
+    case MPV_EVENT_PROPERTY_CHANGE: {
+        [self handlePropertyChange:(mpv_event_property *)event->data];
+        break;
+    }
+    }
 }
 
-- (void)seekbarChanged:(NSSliderTouchBarItem *)sender
+- (void)handlePropertyChange:(struct mpv_event_property *)property
 {
-    NSString *identifier = [self getIdentifierFromView:sender.slider];
-    NSString *seek = [NSString stringWithFormat:
-        self.touchbarItems[identifier][@"cmd"], sender.slider.doubleValue];
-    [self.app queueCommand:(char *)[seek UTF8String]];
+    NSString *name = [NSString stringWithUTF8String:property->name];
+    mpv_format format = property->format;
+
+    if ([name isEqualToString:@"time-pos"] && format == MPV_FORMAT_DOUBLE) {
+        double newPosition = *(double *)property->data;
+        newPosition = newPosition < 0 ? 0 : newPosition;
+        if ((int)(floor(newPosition) - floor(self.position)) != 0) {
+            self.position = newPosition;
+            [self updateTouchBarTimeItems];
+        }
+    } else if ([name isEqualToString:@"duration"] && format == MPV_FORMAT_DOUBLE) {
+        self.duration = *(double *)property->data;
+        [self updateTouchBarTimeItems];
+    } else if ([name isEqualToString:@"pause"] && format == MPV_FORMAT_FLAG) {
+        self.pause = *(int *)property->data;
+        [self updatePlayButton];
+    }
 }
 
 @end
diff --git a/osdep/terminal-unix.c b/osdep/terminal-unix.c
index 78eb4c4..86c3030 100644
--- a/osdep/terminal-unix.c
+++ b/osdep/terminal-unix.c
@@ -45,6 +45,14 @@
 // Timeout in ms after which the (normally ambiguous) ESC key is detected.
 #define ESC_TIMEOUT 100
 
+// Timeout in ms after which the poll for input is aborted. The FG/BG state is
+// tested before every wait, and a positive value allows reactivating input
+// processing when mpv is brought to the foreground while it was running in the
+// background. In such a situation, an infinite timeout (-1) will keep mpv
+// waiting for input without realizing the terminal state changed - and thus
+// buffer all keypresses until ENTER is pressed.
+#define INPUT_TIMEOUT 1000
+
 static volatile struct termios tio_orig;
 static volatile int tio_orig_set;
 
@@ -397,7 +405,7 @@ static void *terminal_thread(void *ptr)
             { .events = POLLIN, .fd = death_pipe[0] },
             { .events = POLLIN, .fd = tty_in }
         };
-        int r = polldev(fds, stdin_ok ? 2 : 1, buf.len ? ESC_TIMEOUT : -1);
+        int r = polldev(fds, stdin_ok ? 2 : 1, buf.len ? ESC_TIMEOUT : INPUT_TIMEOUT);
         if (fds[0].revents)
             break;
         if (fds[1].revents) {
diff --git a/player/audio.c b/player/audio.c
index 50c0faa..307909c 100644
--- a/player/audio.c
+++ b/player/audio.c
@@ -314,6 +314,7 @@ static void ao_chain_set_ao(struct ao_chain *ao_c, struct ao *ao)
         mp_async_queue_set_notifier(ao_c->queue_filter, ao_c->ao_filter);
         // Make sure filtering never stops with frames stuck in access filter.
         mp_filter_set_high_priority(ao_c->queue_filter, true);
+        audio_update_volume(ao_c->mpctx);
     }
 
     if (ao_c->filter->ao_needs_update)
@@ -516,7 +517,8 @@ void reinit_audio_chain(struct MPContext *mpctx)
     struct track *track = NULL;
     track = mpctx->current_track[0][STREAM_AUDIO];
     if (!track || !track->stream) {
-        uninit_audio_out(mpctx);
+        if (!mpctx->encode_lavc_ctx)
+            uninit_audio_out(mpctx);
         error_on_track(mpctx, track);
         return;
     }
@@ -820,8 +822,10 @@ void audio_start_ao(struct MPContext *mpctx)
     MP_VERBOSE(mpctx, "starting audio playback\n");
     ao_start(ao_c->ao);
     mpctx->audio_status = STATUS_PLAYING;
-    if (ao_c->out_eof)
+    if (ao_c->out_eof) {
         mpctx->audio_status = STATUS_DRAINING;
+        MP_VERBOSE(mpctx, "audio draining\n");
+    }
     ao_c->underrun = false;
     mpctx->logged_async_diff = -1;
     mp_wakeup_core(mpctx);
@@ -870,8 +874,10 @@ void fill_audio_out_buffers(struct MPContext *mpctx)
         // until the old audio is fully played.
         // (Buggy if AO underruns.)
         if (mpctx->ao && ao_is_playing(mpctx->ao) &&
-            mpctx->video_status != STATUS_EOF)
+            mpctx->video_status != STATUS_EOF) {
+            MP_VERBOSE(mpctx, "blocked, waiting for old audio to play\n");
             ok = false;
+        }
 
         if (ao_c->start_pts_known != ok || ao_c->start_pts != pts) {
             ao_c->start_pts_known = ok;
diff --git a/player/command.c b/player/command.c
index 066e8be..051d83b 100644
--- a/player/command.c
+++ b/player/command.c
@@ -54,6 +54,7 @@
 #include "options/m_option.h"
 #include "options/m_property.h"
 #include "options/m_config_frontend.h"
+#include "osdep/getpid.h"
 #include "video/out/vo.h"
 #include "video/csputils.h"
 #include "video/hwdec.h"
@@ -426,6 +427,13 @@ static int mp_property_display_sync_active(void *ctx, struct m_property *prop,
     return m_property_flag_ro(action, arg, mpctx->display_sync_active);
 }
 
+static int mp_property_pid(void *ctx, struct m_property *prop,
+                           int action, void *arg)
+{
+    // 32 bit on linux/windows - which C99 `int' is not guaranteed to hold
+    return m_property_int64_ro(action, arg, mp_getpid());
+}
+
 /// filename with path (RO)
 static int mp_property_path(void *ctx, struct m_property *prop,
                             int action, void *arg)
@@ -2404,6 +2412,23 @@ static int mp_property_vsync_jitter(void *ctx, struct m_property *prop,
     return m_property_double_ro(action, arg, stddev);
 }
 
+static int mp_property_display_resolution(void *ctx, struct m_property *prop,
+                                          int action, void *arg)
+{
+    MPContext *mpctx = ctx;
+    struct vo *vo = mpctx->video_out;
+    if (!vo)
+        return M_PROPERTY_UNAVAILABLE;
+    int res[2];
+    if (vo_control(vo, VOCTRL_GET_DISPLAY_RES, &res) <= 0)
+        return M_PROPERTY_UNAVAILABLE;
+    if (strcmp(prop->name, "display-width") == 0) {
+        return m_property_int_ro(action, arg, res[0]);
+    } else {
+        return m_property_int_ro(action, arg, res[1]);
+    }
+}
+
 static int mp_property_hidpi_scale(void *ctx, struct m_property *prop,
                                    int action, void *arg)
 {
@@ -2587,14 +2612,14 @@ static int mp_property_osd_dim(void *ctx, struct m_property *prop,
                     (vo_res.display_par ? vo_res.display_par : 1);
 
     struct m_sub_property props[] = {
-        {"w",       SUB_PROP_DOUBLE(vo_res.w)},
-        {"h",       SUB_PROP_DOUBLE(vo_res.h)},
+        {"w",       SUB_PROP_INT(vo_res.w)},
+        {"h",       SUB_PROP_INT(vo_res.h)},
         {"par",     SUB_PROP_DOUBLE(vo_res.display_par)},
         {"aspect",  SUB_PROP_DOUBLE(aspect)},
-        {"mt",      SUB_PROP_DOUBLE(vo_res.mt)},
-        {"mb",      SUB_PROP_DOUBLE(vo_res.mb)},
-        {"ml",      SUB_PROP_DOUBLE(vo_res.ml)},
-        {"mr",      SUB_PROP_DOUBLE(vo_res.mr)},
+        {"mt",      SUB_PROP_INT(vo_res.mt)},
+        {"mb",      SUB_PROP_INT(vo_res.mb)},
+        {"ml",      SUB_PROP_INT(vo_res.ml)},
+        {"mr",      SUB_PROP_INT(vo_res.mr)},
         {0}
     };
 
@@ -2805,12 +2830,12 @@ static int mp_property_sub_pos(void *ctx, struct m_property *prop,
     return mp_property_generic_option(mpctx, prop, action, arg);
 }
 
-static int mp_property_sub_text(void *ctx, struct m_property *prop,
-                                int action, void *arg)
+static int get_sub_text(void *ctx, struct m_property *prop,
+                        int action, void *arg, int sub_index)
 {
     int type = *(int *)prop->priv;
     MPContext *mpctx = ctx;
-    struct track *track = mpctx->current_track[0][STREAM_SUB];
+    struct track *track = mpctx->current_track[sub_index][STREAM_SUB];
     struct dec_sub *sub = track ? track->d_sub : NULL;
     double pts = mpctx->playback_pts;
     if (!sub || pts == MP_NOPTS_VALUE)
@@ -2831,6 +2856,18 @@ static int mp_property_sub_text(void *ctx, struct m_property *prop,
     return M_PROPERTY_NOT_IMPLEMENTED;
 }
 
+static int mp_property_sub_text(void *ctx, struct m_property *prop,
+                                int action, void *arg)
+{
+    return get_sub_text(ctx, prop, action, arg, 0);
+}
+
+static int mp_property_secondary_sub_text(void *ctx, struct m_property *prop,
+                                          int action, void *arg)
+{
+    return get_sub_text(ctx, prop, action, arg, 1);
+}
+
 static struct sd_times get_times(void *ctx, struct m_property *prop,
                                 int action, void *arg)
 {
@@ -3500,6 +3537,7 @@ static int mp_property_script_props(void *ctx, struct m_property *prop,
 // Base list of properties. This does not include option-mapped properties.
 static const struct m_property mp_properties_base[] = {
     // General
+    {"pid", mp_property_pid},
     {"speed", mp_property_playback_speed},
     {"audio-speed-correction", mp_property_av_speed_correction, .priv = "a"},
     {"video-speed-correction", mp_property_av_speed_correction, .priv = "v"},
@@ -3519,6 +3557,8 @@ static const struct m_property mp_properties_base[] = {
     {"total-avsync-change", mp_property_total_avsync_change},
     {"mistimed-frame-count", mp_property_mistimed_frame_count},
     {"vsync-ratio", mp_property_vsync_ratio},
+    {"display-width", mp_property_display_resolution},
+    {"display-height", mp_property_display_resolution},
     {"decoder-frame-drop-count", mp_property_frame_drop_dec},
     {"frame-drop-count", mp_property_frame_drop_vo},
     {"vo-delayed-frame-count", mp_property_vo_delayed_frame_count},
@@ -3630,6 +3670,8 @@ static const struct m_property mp_properties_base[] = {
     {"sub-pos", mp_property_sub_pos},
     {"sub-text", mp_property_sub_text,
         .priv = (void *)&(const int){SD_TEXT_TYPE_PLAIN}},
+    {"secondary-sub-text", mp_property_secondary_sub_text,
+        .priv = (void *)&(const int){SD_TEXT_TYPE_PLAIN}},
     {"sub-text-ass", mp_property_sub_text,
         .priv = (void *)&(const int){SD_TEXT_TYPE_ASS}},
     {"sub-start", mp_property_sub_start},
@@ -3710,8 +3752,8 @@ static const char *const *const mp_event_property_change[] = {
       "estimated-vf-fps", "drop-frame-count", "vo-drop-frame-count",
       "total-avsync-change", "audio-speed-correction", "video-speed-correction",
       "vo-delayed-frame-count", "mistimed-frame-count", "vsync-ratio",
-      "estimated-display-fps", "vsync-jitter", "sub-text", "audio-bitrate",
-      "video-bitrate", "sub-bitrate", "decoder-frame-drop-count",
+      "estimated-display-fps", "vsync-jitter", "sub-text", "secondary-sub-text",
+      "audio-bitrate", "video-bitrate", "sub-bitrate", "decoder-frame-drop-count",
       "frame-drop-count", "video-frame-info", "vf-metadata", "af-metadata",
       "sub-start", "sub-end"),
     E(MP_EVENT_DURATION_UPDATE, "duration"),
@@ -3734,7 +3776,8 @@ static const char *const *const mp_event_property_change[] = {
       "demuxer-cache-state"),
     E(MP_EVENT_WIN_RESIZE, "current-window-scale", "osd-width", "osd-height",
       "osd-par", "osd-dimensions"),
-    E(MP_EVENT_WIN_STATE, "display-names", "display-fps"),
+    E(MP_EVENT_WIN_STATE, "display-names", "display-fps", "display-width",
+      "display-height"),
     E(MP_EVENT_WIN_STATE2, "display-hidpi-scale"),
     E(MP_EVENT_FOCUS, "focused"),
     E(MP_EVENT_CHANGE_PLAYLIST, "playlist", "playlist-pos", "playlist-pos-1",
@@ -3917,6 +3960,7 @@ static const struct property_osd_display {
     {"taskbar-progress", "Progress in taskbar"},
     {"snap-window", "Snap to screen edges"},
     {"ontop", "Stay on top"},
+    {"on-all-workspaces", "Visibility on all workspaces"},
     {"border", "Border"},
     {"framedrop", "Framedrop"},
     {"deinterlace", "Deinterlace"},
@@ -3935,6 +3979,9 @@ static const struct property_osd_display {
     {"sub-visibility",
      .msg = "Subtitles ${!sub-visibility==yes:hidden}"
       "${?sub-visibility==yes:visible${?sub==no: (but no subtitles selected)}}"},
+    {"secondary-sub-visibility",
+     .msg = "Secondary Subtitles ${!secondary-sub-visibility==yes:hidden}"
+      "${?secondary-sub-visibility==yes:visible${?secondary-sid==no: (but no secondary subtitles selected)}}"},
     {"sub-forced-only", "Forced sub only"},
     {"sub-scale", "Sub Scale"},
     {"sub-ass-vsfilter-aspect-compat", "Subtitle VSFilter aspect compat"},
@@ -5097,7 +5144,7 @@ static void cmd_loadlist(void *p)
     struct mp_cmd_ctx *cmd = p;
     struct MPContext *mpctx = cmd->mpctx;
     char *filename = cmd->args[0].v.s;
-    bool append = cmd->args[1].v.i;
+    int append = cmd->args[1].v.i;
 
     struct playlist *pl = playlist_parse_file(filename, cmd->abort->cancel,
                                               mpctx->global);
@@ -5114,7 +5161,7 @@ static void cmd_loadlist(void *p)
         if (!new)
             new = playlist_get_first(mpctx->playlist);
 
-        if (!append && new)
+        if ((!append || (append == 2 && !mpctx->playlist->current)) && new)
             mp_set_playlist_entry(mpctx, new);
 
         struct mpv_node *res = &cmd->result;
@@ -5240,6 +5287,8 @@ static void cmd_track_add(void *p)
     struct mp_cmd_ctx *cmd = p;
     struct MPContext *mpctx = cmd->mpctx;
     int type = *(int *)cmd->priv;
+    bool is_albumart = type == STREAM_VIDEO &&
+                       cmd->args[4].v.i;
 
     if (mpctx->stop_play) {
         cmd->success = false;
@@ -5259,7 +5308,7 @@ static void cmd_track_add(void *p)
         }
     }
     int first = mp_add_external_file(mpctx, cmd->args[0].v.s, type,
-                                     cmd->abort->cancel);
+                                     cmd->abort->cancel, is_albumart);
     if (first < 0) {
         cmd->success = false;
         return;
@@ -5322,8 +5371,10 @@ static void cmd_track_reload(void *p)
 
     if (t && t->is_external && t->external_filename) {
         char *filename = talloc_strdup(NULL, t->external_filename);
+        bool is_albumart = t->attached_picture;
         mp_remove_track(mpctx, t);
-        nt_num = mp_add_external_file(mpctx, filename, type, cmd->abort->cancel);
+        nt_num = mp_add_external_file(mpctx, filename, type, cmd->abort->cancel,
+                                      is_albumart);
         talloc_free(filename);
     }
 
@@ -6070,6 +6121,7 @@ const struct mp_cmd_def mp_cmds[] = {
                 .flags = MP_CMD_OPT_ARG},
             {"title", OPT_STRING(v.s), .flags = MP_CMD_OPT_ARG},
             {"lang", OPT_STRING(v.s), .flags = MP_CMD_OPT_ARG},
+            {"albumart", OPT_FLAG(v.i), .flags = MP_CMD_OPT_ARG},
         },
         .priv = &(const int){STREAM_VIDEO},
         .spawn_thread = true,
@@ -6165,7 +6217,10 @@ const struct mp_cmd_def mp_cmds[] = {
     { "loadlist", cmd_loadlist,
         {
             {"url", OPT_STRING(v.s)},
-            {"flags", OPT_CHOICE(v.i, {"replace", 0}, {"append", 1}),
+            {"flags", OPT_CHOICE(v.i,
+                {"replace", 0},
+                {"append", 1},
+                {"append-play", 2}),
                 .flags = MP_CMD_OPT_ARG},
         },
         .spawn_thread = true,
@@ -6471,6 +6526,25 @@ static void update_priority(struct MPContext *mpctx)
 #endif
 }
 
+static void update_track_switch(struct MPContext *mpctx, int order, int type)
+{
+    if (!mpctx->playback_initialized)
+        return;
+
+    int tid = mpctx->opts->stream_id[order][type];
+    struct track *track;
+    if (tid == -1) {
+        // If "auto" reset to default track selection
+        track = select_default_track(mpctx, order, type);
+        mark_track_selection(mpctx, order, type, -1);
+    } else {
+        track = mp_track_by_tid(mpctx, type, tid);
+    }
+    mp_switch_track_n(mpctx, order, type, track, (tid == -1) ? 0 : FLAG_MARK_SELECTION);
+    print_track_list(mpctx, "Track switched:");
+    mp_wakeup_core(mpctx);
+}
+
 void mp_option_change_callback(void *ctx, struct m_config_option *co, int flags,
                                bool self_update)
 {
@@ -6525,6 +6599,16 @@ void mp_option_change_callback(void *ctx, struct m_config_option *co, int flags,
         mpctx->ipc_ctx = mp_init_ipc(mpctx->clients, mpctx->global);
     }
 
+    if (opt_ptr == &opts->vo->video_driver_list) {
+        struct track *track = mpctx->current_track[0][STREAM_VIDEO];
+        uninit_video_out(mpctx);
+        reinit_video_chain(mpctx);
+        if (track)
+            reselect_demux_stream(mpctx, track, true);
+
+        mp_wakeup_core(mpctx);
+    }
+
     if (flags & UPDATE_AUDIO)
         reload_audio_output(mpctx);
 
@@ -6619,15 +6703,8 @@ void mp_option_change_callback(void *ctx, struct m_config_option *co, int flags,
 
     for (int type = 0; type < STREAM_TYPE_COUNT; type++) {
         for (int order = 0; order < num_ptracks[type]; order++) {
-            if (opt_ptr == &opts->stream_id[order][type] &&
-                mpctx->playback_initialized)
-            {
-                struct track *track =
-                    mp_track_by_tid(mpctx, type, opts->stream_id[order][type]);
-                mp_switch_track_n(mpctx, order, type, track, FLAG_MARK_SELECTION);
-                print_track_list(mpctx, "Track switched:");
-                mp_wakeup_core(mpctx);
-            }
+            if (opt_ptr == &opts->stream_id[order][type])
+                update_track_switch(mpctx, order, type);
         }
     }
 
diff --git a/player/configfiles.c b/player/configfiles.c
index 3930cf2..83aed38 100644
--- a/player/configfiles.c
+++ b/player/configfiles.c
@@ -270,7 +270,7 @@ static const char *const backup_properties[] = {
     "sub-use-margins",
     "sub-ass-force-margins",
     "sub-ass-vsfilter-aspect-compat",
-    "sub-style-override",
+    "sub-ass-override",
     "ab-loop-a",
     "ab-loop-b",
     "options/video-aspect-override",
diff --git a/player/core.h b/player/core.h
index ec154de..fcb513b 100644
--- a/player/core.h
+++ b/player/core.h
@@ -528,7 +528,8 @@ void mp_abort_trigger_locked(struct MPContext *mpctx,
                              struct mp_abort_entry *abort);
 void uninit_player(struct MPContext *mpctx, unsigned int mask);
 int mp_add_external_file(struct MPContext *mpctx, char *filename,
-                         enum stream_type filter, struct mp_cancel *cancel);
+                         enum stream_type filter, struct mp_cancel *cancel,
+                         bool cover_art);
 void mark_track_selection(struct MPContext *mpctx, int order,
                           enum stream_type type, int value);
 #define FLAG_MARK_SELECTION 1
@@ -547,7 +548,8 @@ void mp_set_playlist_entry(struct MPContext *mpctx, struct playlist_entry *e);
 void mp_play_files(struct MPContext *mpctx);
 void update_demuxer_properties(struct MPContext *mpctx);
 void print_track_list(struct MPContext *mpctx, const char *msg);
-void reselect_demux_stream(struct MPContext *mpctx, struct track *track);
+void reselect_demux_stream(struct MPContext *mpctx, struct track *track,
+                           bool refresh_only);
 void prepare_playlist(struct MPContext *mpctx, struct playlist *pl);
 void autoload_external_files(struct MPContext *mpctx, struct mp_cancel *cancel);
 struct track *select_default_track(struct MPContext *mpctx, int order,
diff --git a/player/external_files.c b/player/external_files.c
index 06585bf..8415346 100644
--- a/player/external_files.c
+++ b/player/external_files.c
@@ -42,6 +42,10 @@ static const char *const audio_exts[] = {"mp3", "aac", "mka", "dts", "flac",
                                          "wv",
                                          NULL};
 
+static const char *const image_exts[] = {"jpg", "jpeg", "png", "gif", "bmp",
+                                         "webp",
+                                         NULL};
+
 // Stolen from: vlc/-/blob/master/modules/meta_engine/folder.c#L40
 // sorted by priority (descending)
 static const char *const cover_files[] = {
@@ -79,18 +83,19 @@ static int test_ext(bstr ext)
         return STREAM_SUB;
     if (test_ext_list(ext, audio_exts))
         return STREAM_AUDIO;
+    if (test_ext_list(ext, image_exts))
+        return STREAM_VIDEO;
     return -1;
 }
 
-static int test_cover_filename(bstr fname, int *priority)
+static int test_cover_filename(bstr fname)
 {
     for (int n = 0; cover_files[n]; n++) {
         if (bstrcasecmp(bstr0(cover_files[n]), fname) == 0) {
-            *priority = MP_ARRAY_SIZE(cover_files) - n;
-            return STREAM_VIDEO;
+            return MP_ARRAY_SIZE(cover_files) - n;
         }
     }
-    return -1;
+    return 0;
 }
 
 bool mp_might_be_subtitle_file(const char *filename)
@@ -191,10 +196,7 @@ static void append_dir_subtitles(struct mpv_global *global, struct MPOpts *opts,
             talloc_steal(tmpmem2, dename.start);
 
         // check what it is (most likely)
-        int cover_prio = 0;
         int type = test_ext(tmp_fname_ext);
-        if (type < 0)
-            type = test_cover_filename(dename, &cover_prio);
         char **langs = NULL;
         int fuzz = -1;
         switch (type) {
@@ -244,15 +246,14 @@ static void append_dir_subtitles(struct mpv_global *global, struct MPOpts *opts,
         if (bstr_find(tmp_fname_trim, f_fname_trim) >= 0 && fuzz >= 1)
             prio |= 2; // contains the movie name
 
+        if (type == STREAM_VIDEO && fuzz >= 1 && prio == 0)
+            prio = test_cover_filename(dename);
+
         // doesn't contain the movie name
         // don't try in the mplayer subtitle directory
         if (!limit_fuzziness && fuzz >= 2)
             prio |= 1;
 
-        // cover art: just accept it
-        if (type == STREAM_VIDEO && fuzz >= 1)
-            prio = cover_prio;
-
         mp_dbg(log, "Potential external file: \"%s\"  Priority: %d\n",
                de->d_name, prio);
 
diff --git a/player/javascript.c b/player/javascript.c
index 8cb263e..136a596 100644
--- a/player/javascript.c
+++ b/player/javascript.c
@@ -40,7 +40,6 @@
 #include "misc/bstr.h"
 #include "osdep/timer.h"
 #include "osdep/threads.h"
-#include "osdep/getpid.h"
 #include "stream/stream.h"
 #include "sub/osd.h"
 #include "core.h"
@@ -925,33 +924,31 @@ static void script_get_user_path(js_State *J, void *af)
     js_pushstring(J, mp_get_user_path(af, jctx(J)->mpctx->global, path));
 }
 
-// args: none
-static void script_getpid(js_State *J)
-{
-    js_pushnumber(J, mp_getpid());
-}
-
-// args: prefixed file name, data (c-str)
-static void script_write_file(js_State *J, void *af)
+// args: is_append, prefixed file name, data (c-str)
+static void script__write_file(js_State *J, void *af)
 {
     static const char *prefix = "file://";
-    const char *fname = js_tostring(J, 1);
-    const char *data = js_tostring(J, 2);
+    bool append = js_toboolean(J, 1);
+    const char *fname = js_tostring(J, 2);
+    const char *data = js_tostring(J, 3);
+    const char *opstr = append ? "append" : "write";
+
     if (strstr(fname, prefix) != fname)  // simple protection for incorrect use
         js_error(J, "File name must be prefixed with '%s'", prefix);
     fname += strlen(prefix);
     fname = mp_get_user_path(af, jctx(J)->mpctx->global, fname);
-    MP_VERBOSE(jctx(J), "Writing file '%s'\n", fname);
+    MP_VERBOSE(jctx(J), "%s file '%s'\n", opstr, fname);
 
-    FILE *f = fopen(fname, "wb");
+    FILE *f = fopen(fname, append ? "ab" : "wb");
     if (!f)
-        js_error(J, "Cannot open file for writing: '%s'", fname);
+        js_error(J, "Cannot open (%s) file: '%s'", opstr, fname);
     add_af_file(af, f);
 
     int len = strlen(data);  // limited by terminating null
     int wrote = fwrite(data, 1, len, f);
     if (len != wrote)
-        js_error(J, "Cannot write to file: '%s'", fname);
+        js_error(J, "Cannot %s to file: '%s'", opstr, fname);
+    js_pushboolean(J, 1);  // success. doesn't touch last_error
 }
 
 // args: env var name
@@ -1183,11 +1180,10 @@ static const struct fn_entry utils_fns[] = {
     FN_ENTRY(split_path, 1),
     AF_ENTRY(join_path, 2),
     AF_ENTRY(get_user_path, 1),
-    FN_ENTRY(getpid, 0),
     FN_ENTRY(get_env_list, 0),
 
     FN_ENTRY(read_file, 2),
-    AF_ENTRY(write_file, 2),
+    AF_ENTRY(_write_file, 3),
     FN_ENTRY(getenv, 1),
     FN_ENTRY(compile_js, 2),
     FN_ENTRY(_gc, 1),
diff --git a/player/javascript/defaults.js b/player/javascript/defaults.js
index 0904524..91f1f52 100644
--- a/player/javascript/defaults.js
+++ b/player/javascript/defaults.js
@@ -663,7 +663,10 @@ mp.get_script_file = function() { return mp.script_file };
 mp.get_script_directory = function() { return mp.script_path };
 mp.get_time = function() { return mp.get_time_ms() / 1000 };
 mp.utils.getcwd = function() { return mp.get_property("working-directory") };
+mp.utils.getpid = function() { return mp.get_property_number("pid") }
 mp.get_mouse_pos = function() { return mp.get_property_native("mouse-pos") };
+mp.utils.write_file = mp.utils._write_file.bind(null, false);
+mp.utils.append_file = mp.utils._write_file.bind(null, true);
 mp.dispatch_event = dispatch_event;
 mp.process_timers = process_timers;
 mp.notify_idle_observers = notify_idle_observers;
@@ -748,7 +751,7 @@ g.mp_event_loop = function mp_event_loop() {
             wait = 0;  // poll the next one
         } else {
             wait = process_timers() / 1000;
-            if (wait != 0) {
+            if (wait != 0 && iobservers.length) {
                 notify_idle_observers();  // can add timers -> recalculate wait
                 wait = peek_timers_wait() / 1000;
             }
diff --git a/player/loadfile.c b/player/loadfile.c
index 0adc8e3..e992df6 100644
--- a/player/loadfile.c
+++ b/player/loadfile.c
@@ -362,7 +362,9 @@ void update_demuxer_properties(struct MPContext *mpctx)
 
 // Enables or disables the stream for the given track, according to
 // track->selected.
-void reselect_demux_stream(struct MPContext *mpctx, struct track *track)
+// With refresh_only=true, refreshes the stream if it's enabled.
+void reselect_demux_stream(struct MPContext *mpctx, struct track *track,
+                           bool refresh_only)
 {
     if (!track->stream)
         return;
@@ -372,7 +374,10 @@ void reselect_demux_stream(struct MPContext *mpctx, struct track *track)
         if (track->type == STREAM_SUB)
             pts -= 10.0;
     }
-    demuxer_select_track(track->demuxer, track->stream, pts, track->selected);
+    if (refresh_only)
+        demuxer_refresh_track(track->demuxer, track->stream, pts);
+    else
+        demuxer_select_track(track->demuxer, track->stream, pts, track->selected);
 }
 
 static void enable_demux_thread(struct MPContext *mpctx, struct demuxer *demux)
@@ -658,14 +663,14 @@ void mp_switch_track_n(struct MPContext *mpctx, int order, enum stream_type type
         if (current->remux_sink)
             close_recorder_and_error(mpctx);
         current->selected = false;
-        reselect_demux_stream(mpctx, current);
+        reselect_demux_stream(mpctx, current, false);
     }
 
     mpctx->current_track[order][type] = track;
 
     if (track) {
         track->selected = true;
-        reselect_demux_stream(mpctx, track);
+        reselect_demux_stream(mpctx, track, false);
     }
 
     if (type == STREAM_VIDEO && order == 0) {
@@ -753,7 +758,8 @@ bool mp_remove_track(struct MPContext *mpctx, struct track *track)
 // cancel will generally be used to abort the loading process, but on success
 // the demuxer is changed to be slaved to mpctx->playback_abort instead.
 int mp_add_external_file(struct MPContext *mpctx, char *filename,
-                         enum stream_type filter, struct mp_cancel *cancel)
+                         enum stream_type filter, struct mp_cancel *cancel,
+                         bool cover_art)
 {
     struct MPOpts *opts = mpctx->opts;
     if (!filename || mp_cancel_test(cancel))
@@ -827,8 +833,8 @@ int mp_add_external_file(struct MPContext *mpctx, char *filename,
         t->external_filename = talloc_strdup(t, filename);
         t->no_default = sh->type != filter;
         t->no_auto_select = t->no_default;
-        // filter==STREAM_VIDEO always means cover art.
-        t->attached_picture = t->type == STREAM_VIDEO && filter == STREAM_VIDEO;
+        // if we found video, and we are loading cover art, flag as such.
+        t->attached_picture = t->type == STREAM_VIDEO && cover_art;
         if (first_num < 0 && (filter == STREAM_TYPE_COUNT || sh->type == filter))
             first_num = mpctx->num_tracks - 1;
     }
@@ -853,7 +859,9 @@ static void open_external_files(struct MPContext *mpctx, char **files,
     files = mp_dup_str_array(tmp, files);
 
     for (int n = 0; files && files[n]; n++)
-        mp_add_external_file(mpctx, files[n], filter, mpctx->playback_abort);
+        // when given filter is set to video, we are loading up cover art
+        mp_add_external_file(mpctx, files[n], filter, mpctx->playback_abort,
+                             filter == STREAM_VIDEO);
 
     talloc_free(tmp);
 }
@@ -892,15 +900,16 @@ void autoload_external_files(struct MPContext *mpctx, struct mp_cancel *cancel)
             goto skip;
         if (e->type == STREAM_VIDEO && (sc[STREAM_VIDEO] || !sc[STREAM_AUDIO]))
             goto skip;
-        int first = mp_add_external_file(mpctx, e->fname, e->type, cancel);
+
+        // when given filter is set to video, we are loading up cover art
+        int first = mp_add_external_file(mpctx, e->fname, e->type, cancel,
+                                         e->type == STREAM_VIDEO);
         if (first < 0)
             goto skip;
 
         for (int n = first; n < mpctx->num_tracks; n++) {
             struct track *t = mpctx->tracks[n];
             t->auto_loaded = true;
-            t->attached_picture =
-                t->type == STREAM_VIDEO && e->type == STREAM_VIDEO;
             if (!t->lang)
                 t->lang = talloc_strdup(t, e->lang);
         }
@@ -1341,7 +1350,7 @@ done:
 
     if (mpctx->playback_initialized) {
         for (int n = 0; n < mpctx->num_tracks; n++)
-            reselect_demux_stream(mpctx, mpctx->tracks[n]);
+            reselect_demux_stream(mpctx, mpctx->tracks[n], false);
     }
 
     mp_notify(mpctx, MPV_EVENT_TRACKS_CHANGED, NULL);
@@ -1583,7 +1592,7 @@ static void play_current_file(struct MPContext *mpctx)
     }
 
     for (int n = 0; n < mpctx->num_tracks; n++)
-        reselect_demux_stream(mpctx, mpctx->tracks[n]);
+        reselect_demux_stream(mpctx, mpctx->tracks[n], false);
 
     update_demuxer_properties(mpctx);
 
@@ -1950,11 +1959,18 @@ void open_recorder(struct MPContext *mpctx, bool on_init)
             MP_TARRAY_APPEND(NULL, streams, num_streams, track->stream);
     }
 
+    struct demux_attachment **attachments = talloc_array(NULL, struct demux_attachment*, mpctx->demuxer->num_attachments);
+    for (int n = 0; n < mpctx->demuxer->num_attachments; n++) {
+        attachments[n] = &mpctx->demuxer->attachments[n];
+    }
+
     mpctx->recorder = mp_recorder_create(mpctx->global, mpctx->opts->record_file,
-                                         streams, num_streams);
+                                         streams, num_streams,
+                                         attachments, mpctx->demuxer->num_attachments);
 
     if (!mpctx->recorder) {
         talloc_free(streams);
+        talloc_free(attachments);
         close_recorder_and_error(mpctx);
         return;
     }
@@ -1978,5 +1994,6 @@ void open_recorder(struct MPContext *mpctx, bool on_init)
     }
 
     talloc_free(streams);
+    talloc_free(attachments);
 }
 
diff --git a/player/lua.c b/player/lua.c
index 2eb163e..e29bfa3 100644
--- a/player/lua.c
+++ b/player/lua.c
@@ -45,7 +45,6 @@
 #include "osdep/subprocess.h"
 #include "osdep/timer.h"
 #include "osdep/threads.h"
-#include "osdep/getpid.h"
 #include "stream/stream.h"
 #include "sub/osd.h"
 #include "core.h"
@@ -1146,12 +1145,6 @@ static int script_join_path(lua_State *L)
     return 1;
 }
 
-static int script_getpid(lua_State *L)
-{
-    lua_pushnumber(L, mp_getpid());
-    return 1;
-}
-
 static int script_parse_json(lua_State *L, void *tmp)
 {
     mp_lua_optarg(L, 2);
@@ -1247,7 +1240,6 @@ static const struct fn_entry utils_fns[] = {
     FN_ENTRY(file_info),
     FN_ENTRY(split_path),
     FN_ENTRY(join_path),
-    FN_ENTRY(getpid),
     AF_ENTRY(parse_json),
     AF_ENTRY(format_json),
     FN_ENTRY(get_env_list),
diff --git a/player/lua/auto_profiles.lua b/player/lua/auto_profiles.lua
index 6856138..fba57cc 100644
--- a/player/lua/auto_profiles.lua
+++ b/player/lua/auto_profiles.lua
@@ -136,16 +136,20 @@ setmetatable(p, {
 })
 
 local function compile_cond(name, s)
-    -- (pre 5.2 ignores the extra arguments)
-    local chunk, err = load("return " .. s, "profile " .. name .. " condition",
-                            "t", evil_magic)
+    local code, chunkname = "return " .. s, "profile " .. name .. " condition"
+    local chunk, err
+    if setfenv then -- lua 5.1
+        chunk, err = loadstring(code, chunkname)
+        if chunk then
+            setfenv(chunk, evil_magic)
+        end
+    else -- lua 5.2
+        chunk, err = load(code, chunkname, "t", evil_magic)
+    end
     if not chunk then
         msg.error("Profile '" .. name .. "' condition: " .. err)
         chunk = function() return false end
     end
-    if setfenv then
-        setfenv(chunk, evil_magic)
-    end
     return chunk
 end
 
diff --git a/player/lua/console.lua b/player/lua/console.lua
index a483bbe..2020952 100644
--- a/player/lua/console.lua
+++ b/player/lua/console.lua
@@ -36,6 +36,8 @@ function detect_platform()
         return 'windows'
     elseif mp.get_property_native('options/macos-force-dedicated-gpu', o) ~= o then
         return 'macos'
+    elseif os.getenv('WAYLAND_DISPLAY') then
+        return 'wayland'
     end
     return 'x11'
 end
@@ -609,6 +611,14 @@ function get_clipboard(clip)
         if not res.error then
             return res.stdout
         end
+    elseif platform == 'wayland' then
+        local res = utils.subprocess({
+            args = { 'wl-paste', clip and '-n' or  '-np' },
+            playback_only = false,
+        })
+        if not res.error then
+            return res.stdout
+        end
     elseif platform == 'windows' then
         local res = utils.subprocess({
             args = { 'powershell', '-NoProfile', '-Command', [[& {
@@ -647,7 +657,7 @@ function get_clipboard(clip)
 end
 
 -- Paste text from the window-system's clipboard. 'clip' determines whether the
--- clipboard or the primary selection buffer is used (on X11 only.)
+-- clipboard or the primary selection buffer is used (on X11 and Wayland only.)
 function paste(clip)
     local text = get_clipboard(clip)
     local before_cur = line:sub(1, cursor - 1)
diff --git a/player/lua/defaults.lua b/player/lua/defaults.lua
index 920ee42..a1deca2 100644
--- a/player/lua/defaults.lua
+++ b/player/lua/defaults.lua
@@ -333,6 +333,7 @@ end
 -- Run timers that have met their deadline.
 -- Return: next absolute time a timer expires as number, or nil if no timers
 local function process_timers()
+    local t0 = nil
     while true do
         local timer = get_next_timer()
         if not timer then
@@ -343,6 +344,14 @@ local function process_timers()
         if wait > 0 then
             return wait
         else
+            if not t0 then
+                t0 = now  -- first due callback: always executes, remember t0
+            elseif timer.next_deadline > t0 then
+                -- don't block forever with slow callbacks and endless timers.
+                -- we'll continue right after checking mpv events.
+                return 0
+            end
+
             if timer.oneshot then
                 timer:kill()
             else
@@ -518,8 +527,19 @@ function mp.dispatch_events(allow_wait)
         local wait = 0
         if not more_events then
             wait = process_timers() or 1e20 -- infinity for all practical purposes
-            for _, handler in ipairs(idle_handlers) do
-                handler()
+            if wait ~= 0 then
+                local idle_called = nil
+                for _, handler in ipairs(idle_handlers) do
+                    idle_called = true
+                    handler()
+                end
+                if idle_called then
+                    -- handlers don't complete in 0 time, and may modify timers
+                    wait = mp.get_next_timeout() or 1e20
+                    if wait < 0 then
+                        wait = 0
+                    end
+                end
             end
             -- Resume playloop - important especially if an error happened while
             -- suspended, and the error was handled, but no resume was done.
@@ -747,6 +767,10 @@ function mp_utils.getcwd()
     return mp.get_property("working-directory")
 end
 
+function mp_utils.getpid()
+    return mp.get_property_number("pid")
+end
+
 function mp_utils.format_bytes_humanized(b)
     local d = {"Bytes", "KiB", "MiB", "GiB", "TiB", "PiB"}
     local i = 1
diff --git a/player/lua/osc.lua b/player/lua/osc.lua
index af59470..18e8d4e 100644
--- a/player/lua/osc.lua
+++ b/player/lua/osc.lua
@@ -48,6 +48,7 @@ local user_opts = {
     windowcontrols = "auto",    -- whether to show window controls
     windowcontrols_alignment = "right", -- which side to show window controls on
     greenandgrumpy = false,     -- disable santa hat
+    livemarkers = true,         -- update seekbar chapter markers on duration change
 }
 
 -- read options from config and command-line
@@ -101,6 +102,7 @@ local state = {
     tc_ms = user_opts.timems,               -- Should the timecodes display their time with milliseconds
     mp_screen_sizeX, mp_screen_sizeY,       -- last screen-resolution, to detect resolution changes to issue reINITs
     initREQ = false,                        -- is a re-init request pending?
+    marginsREQ = false,                     -- is a margins update pending?
     last_mouseX, last_mouseY,               -- last mouse position, to detect significant mouse movement
     mouse_in_window = false,
     message_text,
@@ -591,8 +593,38 @@ end
 -- Element Rendering
 --
 
+-- returns nil or a chapter element from the native property chapter-list
+function get_chapter(possec)
+    local cl = mp.get_property_native("chapter-list", {})
+    local ch = nil
+
+    -- chapters might not be sorted by time. find nearest-before/at possec
+    for n=1, #cl do
+        if possec >= cl[n].time and (not ch or cl[n].time > ch.time) then
+            ch = cl[n]
+        end
+    end
+    return ch
+end
+
 function render_elements(master_ass)
 
+    -- when the slider is dragged or hovered and we have a target chapter name
+    -- then we use it instead of the normal title. we calculate it before the
+    -- render iterations because the title may be rendered before the slider.
+    state.forced_title = nil
+    local se, ae = state.slider_element, elements[state.active_element]
+    if se and (ae == se or (not ae and mouse_hit(se))) then
+        local dur = mp.get_property_number("duration", 0)
+        if dur > 0 then
+            local possec = get_slider_value(se) * dur / 100 -- of mouse pos
+            local ch = get_chapter(possec)
+            if ch and ch.title and ch.title ~= "" then
+                state.forced_title = "Chapter: " .. ch.title
+            end
+        end
+    end
+
     for n=1, #elements do
         local element = elements[n]
 
@@ -1687,6 +1719,7 @@ function update_options(list)
     validate_user_opts()
     request_tick()
     visibility_mode(user_opts.visibility, true)
+    update_duration_watch()
     request_init()
 end
 
@@ -1738,7 +1771,8 @@ function osc_init()
     ne = new_element("title", "button")
 
     ne.content = function ()
-        local title = mp.command_native({"expand-text", user_opts.title})
+        local title = state.forced_title or
+                      mp.command_native({"expand-text", user_opts.title})
         -- escape ASS, and strip newlines and trailing slashes
         title = title:gsub("\\n", " "):gsub("\\$", ""):gsub("{","\\{")
         return not (title == "") and title or "mpv"
@@ -1915,6 +1949,7 @@ function osc_init()
     ne = new_element("seekbar", "slider")
 
     ne.enabled = not (mp.get_property("percent-pos") == nil)
+    state.slider_element = ne.enabled and ne or nil  -- used for forced_title
     ne.slider.markerF = function ()
         local duration = mp.get_property_number("duration", nil)
         if not (duration == nil) then
@@ -2099,7 +2134,10 @@ function update_margins()
     local margins = osc_param.video_margins
 
     -- Don't use margins if it's visible only temporarily.
-    if (not state.osc_visible) or (get_hidetimeout() >= 0) then
+    if (not state.osc_visible) or (get_hidetimeout() >= 0) or
+       (state.fullscreen and not user_opts.showfullscreen) or
+       (not state.fullscreen and not user_opts.showwindowed)
+    then
         margins = {l = 0, r = 0, t = 0, b = 0}
     end
 
@@ -2236,6 +2274,7 @@ end
 
 function render_wipe()
     msg.trace("render_wipe()")
+    state.osd.data = "" -- allows set_osd to immediately update on enable
     state.osd:remove()
 end
 
@@ -2256,7 +2295,14 @@ function render()
     end
 
     -- init management
-    if state.initREQ then
+    if state.active_element then
+        -- mouse is held down on some element - keep ticking and igore initReq
+        -- till it's released, or else the mouse-up (click) will misbehave or
+        -- get ignored. that's because osc_init() recreates the osc elements,
+        -- but mouse handling depends on the elements staying unmodified
+        -- between mouse-down and mouse-up (using the index active_element).
+        request_tick()
+    elseif state.initREQ then
         osc_init()
         state.initREQ = false
 
@@ -2472,8 +2518,10 @@ function process_event(source, what)
         if element_has_action(elements[n], action) then
             elements[n].eventresponder[action](elements[n])
         end
-        request_tick()
     end
+
+    -- ensure rendering after any (mouse) event - icons could change etc
+    request_tick()
 end
 
 
@@ -2504,6 +2552,11 @@ local santa_hat_lines = {
 
 -- called by mpv on every frame
 function tick()
+    if state.marginsREQ == true then
+        update_margins()
+        state.marginsREQ = false
+    end
+
     if (not state.enabled) then return end
 
     if (state.idle) then
@@ -2548,7 +2601,7 @@ function tick()
         render()
     else
         -- Flush OSD
-        set_osd(osc_param.playresy, osc_param.playresy, "")
+        render_wipe()
     end
 
     state.tick_last_time = mp.get_time()
@@ -2582,12 +2635,39 @@ function enable_osc(enable)
     end
 end
 
+-- duration is observed for the sole purpose of updating chapter markers
+-- positions. live streams with chapters are very rare, and the update is also
+-- expensive (with request_init), so it's only observed when we have chapters
+-- and the user didn't disable the livemarkers option (update_duration_watch).
+function on_duration() request_init() end
+
+local duration_watched = false
+function update_duration_watch()
+    local want_watch = user_opts.livemarkers and
+                       (mp.get_property_number("chapters", 0) or 0) > 0 and
+                       true or false  -- ensure it's a boolean
+
+    if (want_watch ~= duration_watched) then
+        if want_watch then
+            mp.observe_property("duration", nil, on_duration)
+        else
+            mp.unobserve_property(on_duration)
+        end
+        duration_watched = want_watch
+    end
+end
+
 validate_user_opts()
+update_duration_watch()
 
 mp.register_event("shutdown", shutdown)
 mp.register_event("start-file", request_init)
 mp.observe_property("track-list", nil, request_init)
 mp.observe_property("playlist", nil, request_init)
+mp.observe_property("chapter-list", nil, function()
+    update_duration_watch()
+    request_init()
+end)
 
 mp.register_script_message("osc-message", show_message)
 mp.register_script_message("osc-chapterlist", function(dur)
@@ -2607,6 +2687,7 @@ end)
 mp.observe_property("fullscreen", "bool",
     function(name, val)
         state.fullscreen = val
+        state.marginsREQ = true
         request_init_resize()
     end
 )
@@ -2722,6 +2803,7 @@ function visibility_mode(mode, no_osd)
     end
 
     user_opts.visibility = mode
+    utils.shared_script_property_set("osc-visibility", mode)
 
     if not no_osd and tonumber(mp.get_property("osd-level")) >= 1 then
         mp.osd_message("OSC visibility: " .. mode)
diff --git a/player/lua/stats.lua b/player/lua/stats.lua
index 6054480..bfdf68a 100644
--- a/player/lua/stats.lua
+++ b/player/lua/stats.lua
@@ -426,6 +426,10 @@ local function append_filters(s, prop, prefix)
             n = n .. " (disabled)"
         end
 
+        if f.label ~= nil then
+            n = "@" .. f.label .. ": " .. n
+        end
+
         local p = {}
         for key,value in pairs(f.params) do
             p[#p+1] = key .. "=" .. value
@@ -513,6 +517,10 @@ local function add_video(s)
         return
     end
 
+    local osd_dims = mp.get_property_native("osd-dimensions")
+    local scaled_width = osd_dims["w"] - osd_dims["ml"] - osd_dims["mr"]
+    local scaled_height = osd_dims["h"] - osd_dims["mt"] - osd_dims["mb"]
+
     append(s, "", {prefix=o.nl .. o.nl .. "Video:", nl="", indent=""})
     if append_property(s, "video-codec", {prefix_sep="", nl="", indent=""}) then
         append_property(s, "hwdec-current", {prefix="(hwdec:", nl="", indent=" ",
@@ -544,6 +552,9 @@ local function add_video(s)
     if append(s, r["w"], {prefix="Native Resolution:"}) then
         append(s, r["h"], {prefix="x", nl="", indent=" ", prefix_sep=" ", no_prefix_markup=true})
     end
+    if append(s, scaled_width, {prefix="Scaled Resolution:"}) then
+        append(s, scaled_height, {prefix="x", nl="", indent=" ", prefix_sep=" ", no_prefix_markup=true})
+    end
     append_property(s, "current-window-scale", {prefix="Window Scale:"})
     if r["aspect"] ~= nil then
         append(s, format("%.2f", r["aspect"]), {prefix="Aspect Ratio:"})
diff --git a/player/lua/ytdl_hook.lua b/player/lua/ytdl_hook.lua
index e9a7b3a..b9cb046 100644
--- a/player/lua/ytdl_hook.lua
+++ b/player/lua/ytdl_hook.lua
@@ -38,6 +38,16 @@ function iif(cond, if_true, if_false)
     return if_false
 end
 
+-- youtube-dl JSON name to mpv tag name
+local tag_list = {
+    ["uploader"]        = "uploader",
+    ["channel_url"]     = "channel_url",
+    -- these titles tend to be a bit too long, so hide them on the terminal
+    -- (default --display-tags does not include this name)
+    ["description"]     = "ytdl_description",
+    -- "title" is handled by force-media-title
+}
+
 local safe_protos = Set {
     "http", "https", "ftp", "ftps",
     "rtmp", "rtmps", "rtmpe", "rtmpt", "rtmpts", "rtmpte",
@@ -341,6 +351,20 @@ local function as_integer(v, def)
     return def
 end
 
+local function tags_to_edl(json)
+    local tags = {}
+    for json_name, mp_name in pairs(tag_list) do
+        local v = json[json_name]
+        if v then
+            tags[#tags + 1] = mp_name .. "=" .. edl_escape(tostring(v))
+        end
+    end
+    if #tags == 0 then
+        return nil
+    end
+    return "!global_tags," .. table.concat(tags, ",")
+end
+
 -- Convert a format list from youtube-dl to an EDL URL, or plain URL.
 --  json: full json blob by youtube-dl
 --  formats: format list by youtube-dl
@@ -475,6 +499,11 @@ local function formats_to_edl(json, formats, use_all_formats)
     if #streams == 1 and single_url then
         res.url = single_url
     elseif #streams > 0 then
+        local tags = tags_to_edl(json)
+        if tags then
+            -- not a stream; just for the sake of concatenating the EDL string
+            streams[#streams + 1] = tags
+        end
         res.url = "edl://" .. table.concat(streams, ";")
     else
         return nil
@@ -507,7 +536,7 @@ local function add_single_video(json)
 
         if requested_formats then
             for _, track in pairs(requested_formats) do
-                max_bitrate = track.tbr > max_bitrate and
+                max_bitrate = (track.tbr and track.tbr > max_bitrate) and
                     track.tbr or max_bitrate
             end
         elseif json.tbr then
@@ -764,33 +793,35 @@ function run_ytdl_hook(url)
         return
     end
 
-    if (es < 0) or (json == nil) or (json == "") then
+    local parse_err = nil
+
+    if (es < 0) or (json == "") then
+        json = nil
+    elseif json then
+        json, parse_err = utils.parse_json(json)
+    end
+
+    if (json == nil) then
         -- trim our stderr to avoid spurious newlines
         ytdl_err = result.stderr:gsub("^%s*(.-)%s*$", "%1")
         msg.error(ytdl_err)
         local err = "youtube-dl failed: "
         if result.error_string and result.error_string == "init" then
             err = err .. "not found or not enough permissions"
+        elseif parse_err then
+            err = err .. "failed to parse JSON data: " .. parse_err
         elseif not result.killed_by_us then
             err = err .. "unexpected error occurred"
         else
             err = string.format("%s returned '%d'", err, es)
         end
         msg.error(err)
-        if string.find(ytdl_err, "yt%-dl%.org/bug") then
+        if parse_err or string.find(ytdl_err, "yt%-dl%.org/bug") then
             check_version(ytdl.path)
         end
         return
     end
 
-    local json, err = utils.parse_json(json)
-
-    if (json == nil) then
-        msg.error("failed to parse JSON data: " .. err)
-        check_version(ytdl.path)
-        return
-    end
-
     msg.verbose("youtube-dl succeeded!")
     msg.debug('ytdl parsing took '..os.clock()-start_time..' seconds')
 
diff --git a/player/main.c b/player/main.c
index 71f5d14..58be00b 100644
--- a/player/main.c
+++ b/player/main.c
@@ -54,7 +54,6 @@
 #include "input/input.h"
 
 #include "audio/out/ao.h"
-#include "demux/demux.h"
 #include "misc/thread_tools.h"
 #include "sub/osd.h"
 #include "test/tests.h"
@@ -202,13 +201,6 @@ static bool handle_help_options(struct MPContext *mpctx)
 {
     struct MPOpts *opts = mpctx->opts;
     struct mp_log *log = mpctx->log;
-    if ((opts->demuxer_name && strcmp(opts->demuxer_name, "help") == 0) ||
-        (opts->audio_demuxer_name && strcmp(opts->audio_demuxer_name, "help") == 0) ||
-        (opts->sub_demuxer_name && strcmp(opts->sub_demuxer_name, "help") == 0)) {
-        demuxer_help(log);
-        MP_INFO(mpctx, "\n");
-        return true;
-    }
     if (opts->ao_opts->audio_device &&
         strcmp(opts->ao_opts->audio_device, "help") == 0)
     {
diff --git a/player/scripting.c b/player/scripting.c
index 24e2931..3db8797 100644
--- a/player/scripting.c
+++ b/player/scripting.c
@@ -174,9 +174,10 @@ static int64_t mp_load_script(struct MPContext *mpctx, const char *fname)
     };
 
     talloc_free(tmp);
+    fname = NULL; // might have been freed so don't touch anymore
 
     if (!arg->client) {
-        MP_ERR(mpctx, "Failed to create client for script: %s\n", fname);
+        MP_ERR(mpctx, "Failed to create client for script: %s\n", arg->filename);
         talloc_free(arg);
         return -1;
     }
@@ -185,7 +186,7 @@ static int64_t mp_load_script(struct MPContext *mpctx, const char *fname)
     arg->log = mp_client_get_log(arg->client);
     int64_t id = mpv_client_id(arg->client);
 
-    MP_DBG(arg, "Loading %s %s...\n", backend->name, fname);
+    MP_DBG(arg, "Loading %s %s...\n", backend->name, arg->filename);
 
     if (backend->no_thread) {
         run_script(arg);
diff --git a/player/sub.c b/player/sub.c
index ae2a85a..148109b 100644
--- a/player/sub.c
+++ b/player/sub.c
@@ -114,7 +114,10 @@ static bool update_subtitle(struct MPContext *mpctx, double video_pts,
     // Handle displaying subtitles on VO with no video being played. This is
     // quite different, because normally subtitles are redrawn on new video
     // frames, using the video frames' timestamps.
-    if (mpctx->video_out && mpctx->video_status == STATUS_EOF) {
+    if (mpctx->video_out && mpctx->video_status == STATUS_EOF &&
+        (mpctx->opts->subs_rend->sub_past_video_end ||
+         !mpctx->current_track[0][STREAM_VIDEO] ||
+         mpctx->current_track[0][STREAM_VIDEO]->attached_picture)) {
         if (osd_get_force_video_pts(mpctx->osd) != video_pts) {
             osd_set_force_video_pts(mpctx->osd, video_pts);
             osd_query_and_reset_want_redraw(mpctx->osd);
diff --git a/stream/stream.h b/stream/stream.h
index 2116fdd..423ba12 100644
--- a/stream/stream.h
+++ b/stream/stream.h
@@ -109,7 +109,7 @@ typedef struct stream_info_st {
     // opts is set from ->opts
     int (*open)(struct stream *st);
     // Alternative to open(). Only either open() or open2() can be set.
-    int (*open2)(struct stream *st, struct stream_open_args *args);
+    int (*open2)(struct stream *st, const struct stream_open_args *args);
     const char *const *protocols;
     bool can_write;     // correctly checks for READ/WRITE modes
     bool local_fs;      // supports STREAM_LOCAL_FS_ONLY
diff --git a/stream/stream_concat.c b/stream/stream_concat.c
index 21f04f9..d06bd4a 100644
--- a/stream/stream_concat.c
+++ b/stream/stream_concat.c
@@ -99,7 +99,7 @@ static int combine_origin(int cur, int new)
     return new; // including cur==0
 }
 
-static int open2(struct stream *stream, struct stream_open_args *args)
+static int open2(struct stream *stream, const struct stream_open_args *args)
 {
     struct priv *p = talloc_zero(stream, struct priv);
     stream->priv = p;
diff --git a/stream/stream_file.c b/stream/stream_file.c
index d649ff4..4895a83 100644
--- a/stream/stream_file.c
+++ b/stream/stream_file.c
@@ -176,7 +176,7 @@ static bool check_stream_network(int fd)
 {
     struct statfs fs;
     const char *stypes[] = { "afpfs", "nfs", "smbfs", "webdav", "osxfusefs",
-                             "fuse", "fusefs.sshfs", NULL };
+                             "fuse", "fusefs.sshfs", "macfuse", NULL };
     if (fstatfs(fd, &fs) == 0)
         for (int i=0; stypes[i]; i++)
             if (strcmp(stypes[i], fs.f_fstypename) == 0)
@@ -246,7 +246,7 @@ static bool check_stream_network(int fd)
 }
 #endif
 
-static int open_f(stream_t *stream, struct stream_open_args *args)
+static int open_f(stream_t *stream, const struct stream_open_args *args)
 {
     struct priv *p = talloc_ptrtype(stream, p);
     *p = (struct priv) {
@@ -340,8 +340,15 @@ static int open_f(stream_t *stream, struct stream_open_args *args)
     stream->get_size = get_size;
     stream->close = s_close;
 
-    if (check_stream_network(p->fd))
+    if (check_stream_network(p->fd)) {
         stream->streaming = true;
+#if HAVE_COCOA
+        if (fcntl(p->fd, F_RDAHEAD, 0) < 0) {
+            MP_VERBOSE(stream, "Cannot disable read ahead on file '%s': %s\n",
+                       filename, mp_strerror(errno));
+        }
+#endif
+    }
 
     p->orig_size = get_size(stream);
 
diff --git a/stream/stream_lavf.c b/stream/stream_lavf.c
index e95dbc0..2269bfb 100644
--- a/stream/stream_lavf.c
+++ b/stream/stream_lavf.c
@@ -73,7 +73,8 @@ const struct m_sub_options stream_lavf_conf = {
     },
 };
 
-static const char *const http_like[];
+static const char *const http_like[] =
+    {"http", "https", "mmsh", "mmshttp", "httproxy", NULL};
 
 static int open_f(stream_t *stream);
 static struct mp_tags *read_icy(stream_t *stream);
@@ -270,7 +271,7 @@ static int open_f(stream_t *stream)
     for (int i = 0; i < sizeof(prefix) / sizeof(prefix[0]); i++)
         if (!strncmp(filename, prefix[i], strlen(prefix[i])))
             filename += strlen(prefix[i]);
-    if (!strncmp(filename, "rtsp:", 5)) {
+    if (!strncmp(filename, "rtsp:", 5) || !strncmp(filename, "rtsps:", 6)) {
         /* This is handled as a special demuxer, without a separate
          * stream layer. demux_lavf will do all the real work. Note
          * that libavformat doesn't even provide a protocol entry for
@@ -404,16 +405,13 @@ done:
     return res;
 }
 
-static const char *const http_like[] =
-    {"http", "https", "mmsh", "mmshttp", "httproxy", NULL};
-
 const stream_info_t stream_info_ffmpeg = {
   .name = "ffmpeg",
   .open = open_f,
   .protocols = (const char *const[]){
-     "rtmp", "rtsp", "http", "https", "mms", "mmst", "mmsh", "mmshttp", "rtp",
-     "httpproxy", "rtmpe", "rtmps", "rtmpt", "rtmpte", "rtmpts", "srt", "srtp",
-     "gopher", "data",
+     "rtmp", "rtsp", "rtsps", "http", "https", "mms", "mmst", "mmsh", "mmshttp",
+     "rtp", "httpproxy", "rtmpe", "rtmps", "rtmpt", "rtmpte", "rtmpts", "srt",
+     "srtp", "gopher", "gophers", "data",
      NULL },
   .can_write = true,
   .stream_origin = STREAM_ORIGIN_NET,
diff --git a/stream/stream_memory.c b/stream/stream_memory.c
index 7383ff4..e4696a7 100644
--- a/stream/stream_memory.c
+++ b/stream/stream_memory.c
@@ -44,7 +44,7 @@ static int64_t get_size(stream_t *s)
     return p->data.len;
 }
 
-static int open2(stream_t *stream, struct stream_open_args *args)
+static int open2(stream_t *stream, const struct stream_open_args *args)
 {
     stream->fill_buffer = fill_buffer;
     stream->seek = seek;
diff --git a/stream/stream_mf.c b/stream/stream_mf.c
index 69a6dce..4c871c4 100644
--- a/stream/stream_mf.c
+++ b/stream/stream_mf.c
@@ -39,4 +39,5 @@ const stream_info_t stream_info_mf = {
     .name = "mf",
     .open = mf_stream_open,
     .protocols = (const char*const[]){ "mf", NULL },
+    .stream_origin = STREAM_ORIGIN_FS,
 };
diff --git a/stream/stream_slice.c b/stream/stream_slice.c
index d7d0a6b..c0dbeeb 100644
--- a/stream/stream_slice.c
+++ b/stream/stream_slice.c
@@ -136,7 +136,7 @@ static int parse_slice_range(stream_t *stream)
     return STREAM_OK;
 }
 
-static int open2(struct stream *stream, struct stream_open_args *args)
+static int open2(struct stream *stream, const struct stream_open_args *args)
 {
     struct priv *p = talloc_zero(stream, struct priv);
     stream->priv = p;
@@ -151,8 +151,9 @@ static int open2(struct stream *stream, struct stream_open_args *args)
         return parse_ret;
     }
 
-    args->url = stream->path;
-    int inner_ret = stream_create_with_args(args, &p->inner);
+    struct stream_open_args args2 = *args;
+    args2.url = stream->path;
+    int inner_ret = stream_create_with_args(&args2, &p->inner);
     if (inner_ret != STREAM_OK) {
         return inner_ret;
     }
diff --git a/sub/dec_sub.c b/sub/dec_sub.c
index ebf3ea3..607b97e 100644
--- a/sub/dec_sub.c
+++ b/sub/dec_sub.c
@@ -449,3 +449,8 @@ void sub_set_play_dir(struct dec_sub *sub, int dir)
     sub->play_dir = dir;
     pthread_mutex_unlock(&sub->lock);
 }
+
+bool sub_is_secondary_visible(struct dec_sub *sub)
+{
+    return !!sub->opts->sec_sub_visibility;
+}
diff --git a/sub/dec_sub.h b/sub/dec_sub.h
index f998b59..542c247 100644
--- a/sub/dec_sub.h
+++ b/sub/dec_sub.h
@@ -10,7 +10,6 @@ struct sh_stream;
 struct mpv_global;
 struct demux_packet;
 struct mp_recorder_sink;
-
 struct dec_sub;
 struct sd;
 
@@ -52,6 +51,7 @@ void sub_reset(struct dec_sub *sub);
 void sub_select(struct dec_sub *sub, bool selected);
 void sub_set_recorder_sink(struct dec_sub *sub, struct mp_recorder_sink *sink);
 void sub_set_play_dir(struct dec_sub *sub, int dir);
+bool sub_is_secondary_visible(struct dec_sub *sub);
 
 int sub_control(struct dec_sub *sub, enum sd_ctrl cmd, void *arg);
 
diff --git a/sub/lavc_conv.c b/sub/lavc_conv.c
index d47b0c4..8e1d1aa 100644
--- a/sub/lavc_conv.c
+++ b/sub/lavc_conv.c
@@ -75,7 +75,7 @@ struct lavc_conv *lavc_conv_create(struct mp_log *log, const char *codec_name,
     AVCodecContext *avctx = NULL;
     AVDictionary *opts = NULL;
     const char *fmt = get_lavc_format(priv->codec);
-    AVCodec *codec = avcodec_find_decoder(mp_codec_to_av_codec_id(fmt));
+    const AVCodec *codec = avcodec_find_decoder(mp_codec_to_av_codec_id(fmt));
     if (!codec)
         goto error;
     avctx = avcodec_alloc_context3(codec);
diff --git a/sub/osd.c b/sub/osd.c
index de63bef..f02693e 100644
--- a/sub/osd.c
+++ b/sub/osd.c
@@ -290,9 +290,12 @@ static struct sub_bitmaps *render_object(struct osd_state *osd,
 
     check_obj_resize(osd, osdres, obj);
 
-    if (obj->type == OSDTYPE_SUB || obj->type == OSDTYPE_SUB2) {
+    if (obj->type == OSDTYPE_SUB) {
         if (obj->sub)
             res = sub_get_bitmaps(obj->sub, obj->vo_res, format, video_pts);
+    } else if (obj->type == OSDTYPE_SUB2) {
+        if (obj->sub && sub_is_secondary_visible(obj->sub))
+            res = sub_get_bitmaps(obj->sub, obj->vo_res, format, video_pts);
     } else if (obj->type == OSDTYPE_EXTERNAL2) {
         if (obj->external2 && obj->external2->format) {
             res = sub_bitmaps_copy(NULL, obj->external2); // need to be owner
diff --git a/sub/sd_lavc.c b/sub/sd_lavc.c
index 77877fd..e8da942 100644
--- a/sub/sd_lavc.c
+++ b/sub/sd_lavc.c
@@ -91,7 +91,7 @@ static int init(struct sd *sd)
 
     struct sd_lavc_priv *priv = talloc_zero(NULL, struct sd_lavc_priv);
     AVCodecContext *ctx = NULL;
-    AVCodec *sub_codec = avcodec_find_decoder(cid);
+    const AVCodec *sub_codec = avcodec_find_decoder(cid);
     if (!sub_codec)
         goto error;
     ctx = avcodec_alloc_context3(sub_codec);
diff --git a/video/csputils.c b/video/csputils.c
index f9b6c98..4df754a 100644
--- a/video/csputils.c
+++ b/video/csputils.c
@@ -103,6 +103,7 @@ const struct m_opt_choice_alternatives mp_csp_light_names[] = {
 
 const struct m_opt_choice_alternatives mp_chroma_names[] = {
     {"unknown",     MP_CHROMA_AUTO},
+    {"uhd",         MP_CHROMA_TOPLEFT},
     {"mpeg2/4/h264",MP_CHROMA_LEFT},
     {"mpeg1/jpeg",  MP_CHROMA_CENTER},
     {0}
@@ -188,6 +189,8 @@ enum mp_csp_prim avcol_pri_to_mp_csp_prim(int avpri)
     case AVCOL_PRI_BT709:       return MP_CSP_PRIM_BT_709;
     case AVCOL_PRI_BT2020:      return MP_CSP_PRIM_BT_2020;
     case AVCOL_PRI_BT470M:      return MP_CSP_PRIM_BT_470M;
+    case AVCOL_PRI_SMPTE431:    return MP_CSP_PRIM_DCI_P3;
+    case AVCOL_PRI_SMPTE432:    return MP_CSP_PRIM_DISPLAY_P3;
     default:                    return MP_CSP_PRIM_AUTO;
     }
 }
@@ -242,6 +245,8 @@ int mp_csp_prim_to_avcol_pri(enum mp_csp_prim prim)
     case MP_CSP_PRIM_BT_709:     return AVCOL_PRI_BT709;
     case MP_CSP_PRIM_BT_2020:    return AVCOL_PRI_BT2020;
     case MP_CSP_PRIM_BT_470M:    return AVCOL_PRI_BT470M;
+    case MP_CSP_PRIM_DCI_P3:     return AVCOL_PRI_SMPTE431;
+    case MP_CSP_PRIM_DISPLAY_P3: return AVCOL_PRI_SMPTE432;
     default:                     return AVCOL_PRI_UNSPECIFIED;
     }
 }
@@ -288,6 +293,7 @@ enum mp_csp_prim mp_csp_guess_primaries(int width, int height)
 enum mp_chroma_location avchroma_location_to_mp(int avloc)
 {
     switch (avloc) {
+    case AVCHROMA_LOC_TOPLEFT:          return MP_CHROMA_TOPLEFT;
     case AVCHROMA_LOC_LEFT:             return MP_CHROMA_LEFT;
     case AVCHROMA_LOC_CENTER:           return MP_CHROMA_CENTER;
     default:                            return MP_CHROMA_AUTO;
@@ -297,6 +303,7 @@ enum mp_chroma_location avchroma_location_to_mp(int avloc)
 int mp_chroma_location_to_av(enum mp_chroma_location mploc)
 {
     switch (mploc) {
+    case MP_CHROMA_TOPLEFT:             return AVCHROMA_LOC_TOPLEFT;
     case MP_CHROMA_LEFT:                return AVCHROMA_LOC_LEFT;
     case MP_CHROMA_CENTER:              return AVCHROMA_LOC_CENTER;
     default:                            return AVCHROMA_LOC_UNSPECIFIED;
@@ -309,8 +316,10 @@ void mp_get_chroma_location(enum mp_chroma_location loc, int *x, int *y)
 {
     *x = 0;
     *y = 0;
-    if (loc == MP_CHROMA_LEFT)
+    if (loc == MP_CHROMA_LEFT || loc == MP_CHROMA_TOPLEFT)
         *x = -1;
+    if (loc == MP_CHROMA_TOPLEFT)
+        *y = -1;
 }
 
 void mp_invert_matrix3x3(float m[3][3])
diff --git a/video/csputils.h b/video/csputils.h
index 965c313..3234682 100644
--- a/video/csputils.h
+++ b/video/csputils.h
@@ -186,6 +186,7 @@ bool mp_colorspace_equal(struct mp_colorspace c1, struct mp_colorspace c2);
 
 enum mp_chroma_location {
     MP_CHROMA_AUTO,
+    MP_CHROMA_TOPLEFT,  // uhd
     MP_CHROMA_LEFT,     // mpeg2/4, h264
     MP_CHROMA_CENTER,   // mpeg1, jpeg
     MP_CHROMA_COUNT,
diff --git a/video/decode/vd_lavc.c b/video/decode/vd_lavc.c
index f965e00..460334b 100644
--- a/video/decode/vd_lavc.c
+++ b/video/decode/vd_lavc.c
@@ -63,8 +63,8 @@ static void uninit_avctx(struct mp_filter *vd);
 static int get_buffer2_direct(AVCodecContext *avctx, AVFrame *pic, int flags);
 static enum AVPixelFormat get_format_hwdec(struct AVCodecContext *avctx,
                                            const enum AVPixelFormat *pix_fmt);
-static int hwdec_validate_opt(struct mp_log *log, const m_option_t *opt,
-                              struct bstr name, struct bstr param);
+static int hwdec_opt_help(struct mp_log *log, const m_option_t *opt,
+                          struct bstr name);
 
 #define HWDEC_DELAY_QUEUE_COUNT 2
 
@@ -117,7 +117,8 @@ const struct m_sub_options vd_lavc_conf = {
             {"no", INT_MAX}, {"yes", 1}), M_RANGE(1, INT_MAX)},
         {"vd-lavc-o", OPT_KEYVALUELIST(avopts)},
         {"vd-lavc-dr", OPT_FLAG(dr)},
-        {"hwdec", OPT_STRING_VALIDATE(hwdec_api, hwdec_validate_opt),
+        {"hwdec", OPT_STRING(hwdec_api),
+            .help = hwdec_opt_help,
             .flags = M_OPT_OPTIONAL_PARAM | UPDATE_HWDEC},
         {"hwdec-codecs", OPT_STRING(hwdec_codecs)},
         {"hwdec-image-format", OPT_IMAGEFORMAT(hwdec_image_format)},
@@ -135,7 +136,7 @@ const struct m_sub_options vd_lavc_conf = {
         .framedrop = AVDISCARD_NONREF,
         .dr = 1,
         .hwdec_api = "no",
-        .hwdec_codecs = "h264,vc1,hevc,vp9,av1",
+        .hwdec_codecs = "h264,vc1,hevc,vp8,vp9,av1",
         // Maximum number of surfaces the player wants to buffer. This number
         // might require adjustment depending on whatever the player does;
         // for example, if vo_gpu increases the number of reference surfaces for
@@ -533,33 +534,30 @@ static void select_and_set_hwdec(struct mp_filter *vd)
     }
 }
 
-static int hwdec_validate_opt(struct mp_log *log, const m_option_t *opt,
-                              struct bstr name, struct bstr param)
+static int hwdec_opt_help(struct mp_log *log, const m_option_t *opt,
+                          struct bstr name)
 {
-    if (bstr_equals0(param, "help")) {
-        struct hwdec_info *hwdecs = NULL;
-        int num_hwdecs = 0;
-        add_all_hwdec_methods(&hwdecs, &num_hwdecs);
+    struct hwdec_info *hwdecs = NULL;
+    int num_hwdecs = 0;
+    add_all_hwdec_methods(&hwdecs, &num_hwdecs);
 
-        mp_info(log, "Valid values (with alternative full names):\n");
+    mp_info(log, "Valid values (with alternative full names):\n");
 
-        for (int n = 0; n < num_hwdecs; n++) {
-            struct hwdec_info *hwdec = &hwdecs[n];
+    for (int n = 0; n < num_hwdecs; n++) {
+        struct hwdec_info *hwdec = &hwdecs[n];
 
-            mp_info(log, "  %s (%s)\n", hwdec->method_name, hwdec->name);
-        }
+        mp_info(log, "  %s (%s)\n", hwdec->method_name, hwdec->name);
+    }
 
-        talloc_free(hwdecs);
+    talloc_free(hwdecs);
 
-        mp_info(log, "  auto (yes '')\n");
-        mp_info(log, "  no\n");
-        mp_info(log, "  auto-safe\n");
-        mp_info(log, "  auto-copy\n");
-        mp_info(log, "  auto-copy-safe\n");
+    mp_info(log, "  auto (yes '')\n");
+    mp_info(log, "  no\n");
+    mp_info(log, "  auto-safe\n");
+    mp_info(log, "  auto-copy\n");
+    mp_info(log, "  auto-copy-safe\n");
 
-        return M_OPT_EXIT;
-    }
-    return 0;
+    return M_OPT_EXIT;
 }
 
 static void force_fallback(struct mp_filter *vd)
@@ -661,7 +659,9 @@ static void init_avctx(struct mp_filter *vd)
     if (!ctx->use_hwdec && ctx->vo && lavc_param->dr) {
         avctx->opaque = vd;
         avctx->get_buffer2 = get_buffer2_direct;
+#if LIBAVCODEC_VERSION_MAJOR < 60
         avctx->thread_safe_callbacks = 1;
+#endif
     }
 
     avctx->flags |= lavc_param->bitexact ? AV_CODEC_FLAG_BITEXACT : 0;
diff --git a/video/filter/vf_sub.c b/video/filter/vf_sub.c
index 5c49ac5..2ed6a2c 100644
--- a/video/filter/vf_sub.c
+++ b/video/filter/vf_sub.c
@@ -116,9 +116,18 @@ error:
     mp_filter_internal_mark_failed(f);
 }
 
+static void vf_sub_destroy(struct mp_filter *f)
+{
+    struct mp_stream_info *info = mp_filter_find_stream_info(f);
+    struct osd_state *osd = info ? info->osd : NULL;
+    if (osd)
+        osd_set_render_subs_in_filter(osd, false);
+}
+
 static const struct mp_filter_info vf_sub_filter = {
     .name = "sub",
     .process = vf_sub_process,
+    .destroy = vf_sub_destroy,
     .priv_size = sizeof(struct priv),
 };
 
diff --git a/video/image_writer.c b/video/image_writer.c
index fb297f9..cff8609 100644
--- a/video/image_writer.c
+++ b/video/image_writer.c
@@ -103,7 +103,7 @@ static bool write_lavc(struct image_writer_ctx *ctx, mp_image_t *image, FILE *fp
 
     av_init_packet(&pkt);
 
-    struct AVCodec *codec;
+    const AVCodec *codec;
     if (ctx->opts->format == AV_CODEC_ID_WEBP) {
         codec = avcodec_find_encoder_by_name("libwebp"); // non-animated encoder
     } else {
@@ -251,7 +251,7 @@ static bool write_jpeg(struct image_writer_ctx *ctx, mp_image_t *image, FILE *fp
 
 #endif
 
-static int get_encoder_format(struct AVCodec *codec, int srcfmt, bool highdepth)
+static int get_encoder_format(const AVCodec *codec, int srcfmt, bool highdepth)
 {
     const enum AVPixelFormat *pix_fmts = codec->pix_fmts;
     int current = 0;
@@ -277,7 +277,7 @@ static int get_encoder_format(struct AVCodec *codec, int srcfmt, bool highdepth)
 
 static int get_target_format(struct image_writer_ctx *ctx)
 {
-    struct AVCodec *codec = avcodec_find_encoder(ctx->opts->format);
+    const AVCodec *codec = avcodec_find_encoder(ctx->opts->format);
     if (!codec)
         goto unknown;
 
diff --git a/video/out/cocoa_cb_common.swift b/video/out/cocoa_cb_common.swift
index 476b482..dd0738f 100644
--- a/video/out/cocoa_cb_common.swift
+++ b/video/out/cocoa_cb_common.swift
@@ -83,8 +83,7 @@ class CocoaCB: Common {
     }
 
     func updateWindowSize(_ vo: UnsafeMutablePointer<vo>) {
-        guard let opts: mp_vo_opts = mpv?.opts,
-              let targetScreen = getScreenBy(id: Int(opts.screen_id)) ?? NSScreen.main else
+        guard let targetScreen = getTargetScreen(forFullscreen: false) ?? NSScreen.main else
         {
             log.sendWarning("Couldn't update Window size, no Screen available")
             return
@@ -133,11 +132,11 @@ class CocoaCB: Common {
     }
 
     override func windowSetToFullScreen() {
-        layer?.update()
+        layer?.update(force: true)
     }
 
     override func windowSetToWindow() {
-        layer?.update()
+        layer?.update(force: true)
     }
 
     override func windowDidUpdateFrame() {
diff --git a/video/out/d3d11/context.c b/video/out/d3d11/context.c
index b77e328..57feb27 100644
--- a/video/out/d3d11/context.c
+++ b/video/out/d3d11/context.c
@@ -28,7 +28,7 @@
 
 static int d3d11_validate_adapter(struct mp_log *log,
                                   const struct m_option *opt,
-                                  struct bstr name, struct bstr param);
+                                  struct bstr name, const char **value);
 
 struct d3d11_opts {
     int feature_level;
@@ -61,7 +61,7 @@ const struct m_sub_options d3d11_conf = {
         {"d3d11-flip", OPT_FLAG(flip)},
         {"d3d11-sync-interval", OPT_INT(sync_interval), M_RANGE(0, 4)},
         {"d3d11-adapter", OPT_STRING_VALIDATE(adapter_name,
-                                               d3d11_validate_adapter)},
+                                              d3d11_validate_adapter)},
         {"d3d11-output-format", OPT_CHOICE(output_format,
             {"auto",     DXGI_FORMAT_UNKNOWN},
             {"rgba8",    DXGI_FORMAT_R8G8B8A8_UNORM},
@@ -111,8 +111,9 @@ struct priv {
 
 static int d3d11_validate_adapter(struct mp_log *log,
                                   const struct m_option *opt,
-                                  struct bstr name, struct bstr param)
+                                  struct bstr name, const char **value)
 {
+    struct bstr param = bstr0(*value);
     bool help = bstr_equals0(param, "help");
     bool adapter_matched = false;
     struct bstr listing = { 0 };
diff --git a/video/out/drm_common.c b/video/out/drm_common.c
index 64c84ca..727221b 100644
--- a/video/out/drm_common.c
+++ b/video/out/drm_common.c
@@ -54,13 +54,15 @@
 
 static int vt_switcher_pipe[2];
 
-static int drm_validate_connector_opt(
-    struct mp_log *log, const struct m_option *opt, struct bstr name,
-    struct bstr param);
+static int drm_connector_opt_help(
+    struct mp_log *log, const struct m_option *opt, struct bstr name);
+
+static int drm_mode_opt_help(
+    struct mp_log *log, const struct m_option *opt, struct bstr name);
 
 static int drm_validate_mode_opt(
     struct mp_log *log, const struct m_option *opt, struct bstr name,
-    struct bstr param);
+    const char **value);
 
 static void kms_show_available_modes(
     struct mp_log *log, const drmModeConnector *connector);
@@ -71,10 +73,10 @@ static double mode_get_Hz(const drmModeModeInfo *mode);
 #define OPT_BASE_STRUCT struct drm_opts
 const struct m_sub_options drm_conf = {
     .opts = (const struct m_option[]) {
-        {"drm-connector", OPT_STRING_VALIDATE(drm_connector_spec,
-                                               drm_validate_connector_opt)},
-        {"drm-mode", OPT_STRING_VALIDATE(drm_mode_spec,
-                                          drm_validate_mode_opt)},
+        {"drm-connector", OPT_STRING(drm_connector_spec),
+            .help = drm_connector_opt_help},
+        {"drm-mode", OPT_STRING_VALIDATE(drm_mode_spec, drm_validate_mode_opt),
+            .help = drm_mode_opt_help},
         {"drm-atomic", OPT_CHOICE(drm_atomic, {"no", 0}, {"auto", 1})},
         {"drm-draw-plane", OPT_CHOICE(drm_draw_plane,
             {"primary", DRM_OPTS_PRIMARY_PLANE},
@@ -747,31 +749,28 @@ double kms_get_display_fps(const struct kms *kms)
     return mode_get_Hz(&kms->mode.mode);
 }
 
-static int drm_validate_connector_opt(struct mp_log *log, const struct m_option *opt,
-                                      struct bstr name, struct bstr param)
+static int drm_connector_opt_help(struct mp_log *log, const struct m_option *opt,
+                                  struct bstr name)
 {
-    if (bstr_equals0(param, "help")) {
-        kms_show_available_cards_and_connectors(log);
-        return M_OPT_EXIT;
-    }
-    return 1;
+    kms_show_available_cards_and_connectors(log);
+    return M_OPT_EXIT;
 }
 
-static int drm_validate_mode_opt(struct mp_log *log, const struct m_option *opt,
-                                 struct bstr name, struct bstr param)
+static int drm_mode_opt_help(struct mp_log *log, const struct m_option *opt,
+                             struct bstr name)
 {
-    if (bstr_equals0(param, "help")) {
-        kms_show_available_cards_connectors_and_modes(log);
-        return M_OPT_EXIT;
-    }
+    kms_show_available_cards_connectors_and_modes(log);
+    return M_OPT_EXIT;
+}
 
-    char *spec = bstrto0(NULL, param);
-    if (!parse_mode_spec(spec, NULL)) {
+static int drm_validate_mode_opt(struct mp_log *log, const struct m_option *opt,
+                                 struct bstr name, const char **value)
+{
+    const char *param = *value;
+    if (!parse_mode_spec(param, NULL)) {
         mp_fatal(log, "Invalid value for option drm-mode. Must be a positive number, a string of the format WxH[@R] or 'help'\n");
-        talloc_free(spec);
         return M_OPT_INVALID;
     }
-    talloc_free(spec);
 
     return 1;
 }
diff --git a/video/out/filter_kernels.c b/video/out/filter_kernels.c
index bfbd4e9..4ebc033 100644
--- a/video/out/filter_kernels.c
+++ b/video/out/filter_kernels.c
@@ -199,7 +199,7 @@ static double hamming(params *p, double x)
 
 static double quadric(params *p, double x)
 {
-    if (x <  0.75) {
+    if (x <  0.5) {
         return 0.75 - x * x;
     } else if (x <  1.5) {
         double t = x - 1.5;
diff --git a/video/out/gpu/context.c b/video/out/gpu/context.c
index 39696fb..6e58cce 100644
--- a/video/out/gpu/context.c
+++ b/video/out/gpu/context.c
@@ -50,6 +50,7 @@ extern const struct ra_ctx_fns ra_ctx_vulkan_wayland;
 extern const struct ra_ctx_fns ra_ctx_vulkan_win;
 extern const struct ra_ctx_fns ra_ctx_vulkan_xlib;
 extern const struct ra_ctx_fns ra_ctx_vulkan_android;
+extern const struct ra_ctx_fns ra_ctx_vulkan_display;
 
 /* Direct3D 11 */
 extern const struct ra_ctx_fns ra_ctx_d3d11;
@@ -106,20 +107,25 @@ static const struct ra_ctx_fns *contexts[] = {
 #if HAVE_X11
     &ra_ctx_vulkan_xlib,
 #endif
+    &ra_ctx_vulkan_display,
 
 #endif
 };
 
+int ra_ctx_api_help(struct mp_log *log, const struct m_option *opt,
+                    struct bstr name)
+{
+    mp_info(log, "GPU APIs (contexts):\n");
+    mp_info(log, "    auto (autodetect)\n");
+    for (int n = 0; n < MP_ARRAY_SIZE(contexts); n++)
+        mp_info(log, "    %s (%s)\n", contexts[n]->type, contexts[n]->name);
+    return M_OPT_EXIT;
+}
+
 int ra_ctx_validate_api(struct mp_log *log, const struct m_option *opt,
-                        struct bstr name, struct bstr param)
+                        struct bstr name, const char **value)
 {
-    if (bstr_equals0(param, "help")) {
-        mp_info(log, "GPU APIs (contexts):\n");
-        mp_info(log, "    auto (autodetect)\n");
-        for (int n = 0; n < MP_ARRAY_SIZE(contexts); n++)
-            mp_info(log, "    %s (%s)\n", contexts[n]->type, contexts[n]->name);
-        return M_OPT_EXIT;
-    }
+    struct bstr param = bstr0(*value);
     if (bstr_equals0(param, "auto"))
         return 1;
     for (int i = 0; i < MP_ARRAY_SIZE(contexts); i++) {
@@ -129,16 +135,20 @@ int ra_ctx_validate_api(struct mp_log *log, const struct m_option *opt,
     return M_OPT_INVALID;
 }
 
+int ra_ctx_context_help(struct mp_log *log, const struct m_option *opt,
+                        struct bstr name)
+{
+    mp_info(log, "GPU contexts (APIs):\n");
+    mp_info(log, "    auto (autodetect)\n");
+    for (int n = 0; n < MP_ARRAY_SIZE(contexts); n++)
+        mp_info(log, "    %s (%s)\n", contexts[n]->name, contexts[n]->type);
+    return M_OPT_EXIT;
+}
+
 int ra_ctx_validate_context(struct mp_log *log, const struct m_option *opt,
-                            struct bstr name, struct bstr param)
+                            struct bstr name, const char **value)
 {
-    if (bstr_equals0(param, "help")) {
-        mp_info(log, "GPU contexts (APIs):\n");
-        mp_info(log, "    auto (autodetect)\n");
-        for (int n = 0; n < MP_ARRAY_SIZE(contexts); n++)
-            mp_info(log, "    %s (%s)\n", contexts[n]->name, contexts[n]->type);
-        return M_OPT_EXIT;
-    }
+    struct bstr param = bstr0(*value);
     if (bstr_equals0(param, "auto"))
         return 1;
     for (int i = 0; i < MP_ARRAY_SIZE(contexts); i++) {
diff --git a/video/out/gpu/context.h b/video/out/gpu/context.h
index 8c35eb0..ca71150 100644
--- a/video/out/gpu/context.h
+++ b/video/out/gpu/context.h
@@ -100,7 +100,11 @@ struct ra_ctx *ra_ctx_create(struct vo *vo, const char *context_type,
 void ra_ctx_destroy(struct ra_ctx **ctx);
 
 struct m_option;
+int ra_ctx_api_help(struct mp_log *log, const struct m_option *opt,
+                    struct bstr name);
 int ra_ctx_validate_api(struct mp_log *log, const struct m_option *opt,
-                        struct bstr name, struct bstr param);
+                        struct bstr name, const char **value);
+int ra_ctx_context_help(struct mp_log *log, const struct m_option *opt,
+                        struct bstr name);
 int ra_ctx_validate_context(struct mp_log *log, const struct m_option *opt,
-                            struct bstr name, struct bstr param);
+                            struct bstr name, const char **value);
diff --git a/video/out/gpu/hwdec.c b/video/out/gpu/hwdec.c
index db75c64..4fb6240 100644
--- a/video/out/gpu/hwdec.c
+++ b/video/out/gpu/hwdec.c
@@ -106,8 +106,9 @@ struct ra_hwdec *ra_hwdec_load_driver(struct ra *ra, struct mp_log *log,
 }
 
 int ra_hwdec_validate_opt(struct mp_log *log, const m_option_t *opt,
-                          struct bstr name, struct bstr param)
+                          struct bstr name, const char **value)
 {
+    struct bstr param = bstr0(*value);
     bool help = bstr_equals0(param, "help");
     if (help)
         mp_info(log, "Available hwdecs:\n");
diff --git a/video/out/gpu/hwdec.h b/video/out/gpu/hwdec.h
index 3a1ae3e..050a358 100644
--- a/video/out/gpu/hwdec.h
+++ b/video/out/gpu/hwdec.h
@@ -109,7 +109,7 @@ struct ra_hwdec *ra_hwdec_load_driver(struct ra *ra, struct mp_log *log,
                                       bool is_auto);
 
 int ra_hwdec_validate_opt(struct mp_log *log, const m_option_t *opt,
-                          struct bstr name, struct bstr param);
+                          struct bstr name, const char **value);
 
 void ra_hwdec_uninit(struct ra_hwdec *hwdec);
 
diff --git a/video/out/gpu/lcms.c b/video/out/gpu/lcms.c
index 0f3a0bf..704f1fb 100644
--- a/video/out/gpu/lcms.c
+++ b/video/out/gpu/lcms.c
@@ -67,8 +67,9 @@ static bool parse_3dlut_size(const char *arg, int *p1, int *p2, int *p3)
 }
 
 static int validate_3dlut_size_opt(struct mp_log *log, const m_option_t *opt,
-                                   struct bstr name, struct bstr param)
+                                   struct bstr name, const char **value)
 {
+    struct bstr param = bstr0(*value);
     int p1, p2, p3;
     char s[20];
     snprintf(s, sizeof(s), "%.*s", BSTR_P(param));
@@ -83,11 +84,12 @@ const struct m_sub_options mp_icc_conf = {
         {"icc-profile-auto", OPT_FLAG(profile_auto)},
         {"icc-cache-dir", OPT_STRING(cache_dir), .flags = M_OPT_FILE},
         {"icc-intent", OPT_INT(intent)},
-        {"icc-contrast", OPT_CHOICE(contrast, {"inf", -1}),
+        {"icc-force-contrast", OPT_CHOICE(contrast, {"no", 0}, {"inf", -1}),
             M_RANGE(0, 1000000)},
         {"icc-3dlut-size", OPT_STRING_VALIDATE(size_str, validate_3dlut_size_opt)},
         {"3dlut-size", OPT_REPLACED("icc-3dlut-size")},
         {"icc-cache", OPT_REMOVED("see icc-cache-dir")},
+        {"icc-contrast", OPT_REMOVED("see icc-force-contrast")},
         {0}
     },
     .size = sizeof(struct mp_icc_opts),
@@ -271,48 +273,46 @@ static cmsHPROFILE get_vid_profile(struct gl_lcms *p, cmsContext cms,
         break;
 
     case MP_CSP_TRC_BT_1886: {
-        // To build an appropriate BT.1886 transformation we need access to
-        // the display's black point, so we LittleCMS' detection function.
-        // Relative colorimetric is used since we want to approximate the
-        // BT.1886 to the target device's actual black point even in e.g.
-        // perceptual mode
-        const int intent = MP_INTENT_RELATIVE_COLORIMETRIC;
-        cmsCIEXYZ bp_XYZ;
-        if (!cmsDetectBlackPoint(&bp_XYZ, disp_profile, intent, 0))
-            return false;
-
-        // Map this XYZ value back into the (linear) source space
-        cmsToneCurve *linear = cmsBuildGamma(cms, 1.0);
-        cmsHPROFILE rev_profile = cmsCreateRGBProfileTHR(cms, &wp_xyY, &prim_xyY,
-                (cmsToneCurve*[3]){linear, linear, linear});
-        cmsHPROFILE xyz_profile = cmsCreateXYZProfile();
-        cmsHTRANSFORM xyz2src = cmsCreateTransformTHR(cms,
-                xyz_profile, TYPE_XYZ_DBL, rev_profile, TYPE_RGB_DBL,
-                intent, 0);
-        cmsFreeToneCurve(linear);
-        cmsCloseProfile(rev_profile);
-        cmsCloseProfile(xyz_profile);
-        if (!xyz2src)
-            return false;
-
         double src_black[3];
-        cmsDoTransform(xyz2src, &bp_XYZ, src_black, 1);
-        cmsDeleteTransform(xyz2src);
-
-        // Contrast limiting
-        if (p->opts->contrast > 0) {
+        if (p->opts->contrast < 0) {
+            // User requested infinite contrast, return 2.4 profile
+            tonecurve[0] = cmsBuildGamma(cms, 2.4);
+            break;
+        } else if (p->opts->contrast > 0) {
+            MP_VERBOSE(p, "Using specified contrast: %d\n", p->opts->contrast);
             for (int i = 0; i < 3; i++)
-                src_black[i] = MPMAX(src_black[i], 1.0 / p->opts->contrast);
-        }
-
-        // Built-in contrast failsafe
-        double contrast = 3.0 / (src_black[0] + src_black[1] + src_black[2]);
-        MP_VERBOSE(p, "Detected ICC profile contrast: %f\n", contrast);
-        if (contrast > 100000 && !p->opts->contrast) {
-            MP_WARN(p, "ICC profile detected contrast very high (>100000),"
-                    " falling back to contrast 1000 for sanity. Set the"
-                    " icc-contrast option to silence this warning.\n");
-            src_black[0] = src_black[1] = src_black[2] = 1.0 / 1000;
+                src_black[i] = 1.0 / p->opts->contrast;
+        } else {
+            // To build an appropriate BT.1886 transformation we need access to
+            // the display's black point, so we use LittleCMS' detection
+            // function. Relative colorimetric is used since we want to
+            // approximate the BT.1886 to the target device's actual black
+            // point even in e.g. perceptual mode
+            const int intent = MP_INTENT_RELATIVE_COLORIMETRIC;
+            cmsCIEXYZ bp_XYZ;
+            if (!cmsDetectBlackPoint(&bp_XYZ, disp_profile, intent, 0))
+                return false;
+
+            // Map this XYZ value back into the (linear) source space
+            cmsHPROFILE rev_profile;
+            cmsToneCurve *linear = cmsBuildGamma(cms, 1.0);
+            rev_profile = cmsCreateRGBProfileTHR(cms, &wp_xyY, &prim_xyY,
+                    (cmsToneCurve*[3]){linear, linear, linear});
+            cmsHPROFILE xyz_profile = cmsCreateXYZProfile();
+            cmsHTRANSFORM xyz2src = cmsCreateTransformTHR(cms,
+                    xyz_profile, TYPE_XYZ_DBL, rev_profile, TYPE_RGB_DBL,
+                    intent, 0);
+            cmsFreeToneCurve(linear);
+            cmsCloseProfile(rev_profile);
+            cmsCloseProfile(xyz_profile);
+            if (!xyz2src)
+                return false;
+
+            cmsDoTransform(xyz2src, &bp_XYZ, src_black, 1);
+            cmsDeleteTransform(xyz2src);
+
+            double contrast = 3.0 / (src_black[0] + src_black[1] + src_black[2]);
+            MP_VERBOSE(p, "Detected ICC profile contrast: %f\n", contrast);
         }
 
         // Build the parametric BT.1886 transfer curve, one per channel
diff --git a/video/out/gpu/shader_cache.c b/video/out/gpu/shader_cache.c
index 5e96de9..c19a7e8 100644
--- a/video/out/gpu/shader_cache.c
+++ b/video/out/gpu/shader_cache.c
@@ -17,7 +17,7 @@
 #include "utils.h"
 
 // Force cache flush if more than this number of shaders is created.
-#define SC_MAX_ENTRIES 48
+#define SC_MAX_ENTRIES 256
 
 union uniform_val {
     float f[9];         // RA_VARTYPE_FLOAT
@@ -458,6 +458,26 @@ void gl_sc_blend(struct gl_shader_cache *sc,
     sc->params.blend_dst_alpha = blend_dst_alpha;
 }
 
+const char *gl_sc_bvec(struct gl_shader_cache *sc, int dims)
+{
+    static const char *bvecs[] = {
+        [1] = "bool",
+        [2] = "bvec2",
+        [3] = "bvec3",
+        [4] = "bvec4",
+    };
+
+    static const char *vecs[] = {
+        [1] = "float",
+        [2] = "vec2",
+        [3] = "vec3",
+        [4] = "vec4",
+    };
+
+    assert(dims > 0 && dims < MP_ARRAY_SIZE(bvecs));
+    return sc->ra->glsl_version >= 130 ? bvecs[dims] : vecs[dims];
+}
+
 static const char *vao_glsl_type(const struct ra_renderpass_input *e)
 {
     // pretty dumb... too dumb, but works for us
diff --git a/video/out/gpu/shader_cache.h b/video/out/gpu/shader_cache.h
index 547c6b6..3c87513 100644
--- a/video/out/gpu/shader_cache.h
+++ b/video/out/gpu/shader_cache.h
@@ -43,6 +43,10 @@ void gl_sc_uniform_mat2(struct gl_shader_cache *sc, char *name,
                         bool transpose, float *v);
 void gl_sc_uniform_mat3(struct gl_shader_cache *sc, char *name,
                         bool transpose, float *v);
+
+// Return the correct bvecN() variant for using mix() in this GLSL version
+const char *gl_sc_bvec(struct gl_shader_cache *sc, int dims);
+
 void gl_sc_blend(struct gl_shader_cache *sc,
                  enum ra_blend blend_src_rgb,
                  enum ra_blend blend_dst_rgb,
diff --git a/video/out/gpu/video.c b/video/out/gpu/video.c
index 851289e..2e0cfbd 100644
--- a/video/out/gpu/video.c
+++ b/video/out/gpu/video.c
@@ -317,7 +317,7 @@ static const struct gl_video_opts gl_video_opts_def = {
     },
     .scaler_resizes_only = 1,
     .scaler_lut_size = 6,
-    .interpolation_threshold = 0.0001,
+    .interpolation_threshold = 0.01,
     .alpha_mode = ALPHA_BLEND_TILES,
     .background = {0, 0, 0, 255},
     .gamma = 1.0f,
@@ -337,13 +337,13 @@ static const struct gl_video_opts gl_video_opts_def = {
 };
 
 static int validate_scaler_opt(struct mp_log *log, const m_option_t *opt,
-                               struct bstr name, struct bstr param);
+                               struct bstr name, const char **value);
 
 static int validate_window_opt(struct mp_log *log, const m_option_t *opt,
-                               struct bstr name, struct bstr param);
+                               struct bstr name, const char **value);
 
 static int validate_error_diffusion_opt(struct mp_log *log, const m_option_t *opt,
-                                        struct bstr name, struct bstr param);
+                                        struct bstr name, const char **value);
 
 #define OPT_BASE_STRUCT struct gl_video_opts
 
@@ -664,6 +664,11 @@ static bool gl_video_get_lut3d(struct gl_video *p, enum mp_csp_prim prim,
 
     talloc_free(lut3d);
 
+    if (!p->lut_3d_texture) {
+        p->use_lut_3d = false;
+        return false;
+    }
+
     return true;
 }
 
@@ -952,9 +957,6 @@ static void init_video(struct gl_video *p)
                        params.w, params.h);
 
             plane->tex = ra_tex_create(p->ra, &params);
-            if (!plane->tex)
-                abort(); // shit happens
-
             p->use_integer_conversion |= format->ctype == RA_CTYPE_UINT;
         }
     }
@@ -2341,26 +2343,29 @@ static void pass_convert_yuv(struct gl_video *p)
         // as per the BT.2020 specification, table 4. This is a non-linear
         // transformation because (constant) luminance receives non-equal
         // contributions from the three different channels.
-        GLSLF("// constant luminance conversion\n");
-        GLSL(color.br = color.br * mix(vec2(1.5816, 0.9936),
-                                       vec2(1.9404, 1.7184),
-                                       lessThanEqual(color.br, vec2(0)))
-                        + color.gg;)
+        GLSLF("// constant luminance conversion \n"
+              "color.br = color.br * mix(vec2(1.5816, 0.9936),              \n"
+              "                         vec2(1.9404, 1.7184),               \n"
+              "                         %s(lessThanEqual(color.br, vec2(0))))\n"
+              "          + color.gg;                                        \n",
+              gl_sc_bvec(p->sc, 2));
         // Expand channels to camera-linear light. This shader currently just
         // assumes everything uses the BT.2020 12-bit gamma function, since the
         // difference between 10 and 12-bit is negligible for anything other
         // than 12-bit content.
-        GLSL(color.rgb = mix(color.rgb * vec3(1.0/4.5),
-                             pow((color.rgb + vec3(0.0993))*vec3(1.0/1.0993),
-                                 vec3(1.0/0.45)),
-                             lessThanEqual(vec3(0.08145), color.rgb));)
+        GLSLF("color.rgb = mix(color.rgb * vec3(1.0/4.5),                       \n"
+              "                pow((color.rgb + vec3(0.0993))*vec3(1.0/1.0993), \n"
+              "                    vec3(1.0/0.45)),                             \n"
+              "                %s(lessThanEqual(vec3(0.08145), color.rgb)));    \n",
+              gl_sc_bvec(p->sc, 3));
         // Calculate the green channel from the expanded RYcB
         // The BT.2020 specification says Yc = 0.2627*R + 0.6780*G + 0.0593*B
         GLSL(color.g = (color.g - 0.2627*color.r - 0.0593*color.b)*1.0/0.6780;)
         // Recompress to receive the R'G'B' result, same as other systems
-        GLSL(color.rgb = mix(color.rgb * vec3(4.5),
-                             vec3(1.0993) * pow(color.rgb, vec3(0.45)) - vec3(0.0993),
-                             lessThanEqual(vec3(0.0181), color.rgb));)
+        GLSLF("color.rgb = mix(color.rgb * vec3(4.5),                       \n"
+              "                vec3(1.0993) * pow(color.rgb, vec3(0.45)) - vec3(0.0993), \n"
+              "                %s(lessThanEqual(vec3(0.0181), color.rgb))); \n",
+              gl_sc_bvec(p->sc, 3));
     }
 
     p->components = 3;
@@ -3578,6 +3583,10 @@ static bool pass_upload_image(struct gl_video *p, struct mp_image *mpi, uint64_t
     timer_pool_start(p->upload_timer);
     for (int n = 0; n < p->plane_count; n++) {
         struct texplane *plane = &vimg->planes[n];
+        if (!plane->tex) {
+            timer_pool_stop(p->upload_timer);
+            goto error;
+        }
 
         struct ra_tex_upload_params params = {
             .tex = plane->tex,
@@ -4078,8 +4087,9 @@ void gl_video_configure_queue(struct gl_video *p, struct vo *vo)
 }
 
 static int validate_scaler_opt(struct mp_log *log, const m_option_t *opt,
-                               struct bstr name, struct bstr param)
+                               struct bstr name, const char **value)
 {
+    struct bstr param = bstr0(*value);
     char s[20] = {0};
     int r = 1;
     bool tscale = bstr_equals0(name, "tscale");
@@ -4110,8 +4120,9 @@ static int validate_scaler_opt(struct mp_log *log, const m_option_t *opt,
 }
 
 static int validate_window_opt(struct mp_log *log, const m_option_t *opt,
-                               struct bstr name, struct bstr param)
+                               struct bstr name, const char **value)
 {
+    struct bstr param = bstr0(*value);
     char s[20] = {0};
     int r = 1;
     if (bstr_equals0(param, "help")) {
@@ -4135,8 +4146,9 @@ static int validate_window_opt(struct mp_log *log, const m_option_t *opt,
 }
 
 static int validate_error_diffusion_opt(struct mp_log *log, const m_option_t *opt,
-                                        struct bstr name, struct bstr param)
+                                        struct bstr name, const char **value)
 {
+    struct bstr param = bstr0(*value);
     char s[20] = {0};
     int r = 1;
     if (bstr_equals0(param, "help")) {
diff --git a/video/out/gpu/video_shaders.c b/video/out/gpu/video_shaders.c
index da48929..d39b867 100644
--- a/video/out/gpu/video_shaders.c
+++ b/video/out/gpu/video_shaders.c
@@ -354,9 +354,10 @@ void pass_linearize(struct gl_shader_cache *sc, enum mp_csp_trc trc)
 
     switch (trc) {
     case MP_CSP_TRC_SRGB:
-        GLSL(color.rgb = mix(color.rgb * vec3(1.0/12.92),
-                             pow((color.rgb + vec3(0.055))/vec3(1.055), vec3(2.4)),
-                             lessThan(vec3(0.04045), color.rgb));)
+        GLSLF("color.rgb = mix(color.rgb * vec3(1.0/12.92),             \n"
+              "                pow((color.rgb + vec3(0.055))/vec3(1.055), vec3(2.4)), \n"
+              "                %s(lessThan(vec3(0.04045), color.rgb))); \n",
+              gl_sc_bvec(sc, 3));
         break;
     case MP_CSP_TRC_BT_1886:
         GLSL(color.rgb = pow(color.rgb, vec3(2.4));)
@@ -380,9 +381,10 @@ void pass_linearize(struct gl_shader_cache *sc, enum mp_csp_trc trc)
         GLSL(color.rgb = pow(color.rgb, vec3(2.8));)
         break;
     case MP_CSP_TRC_PRO_PHOTO:
-        GLSL(color.rgb = mix(color.rgb * vec3(1.0/16.0),
-                             pow(color.rgb, vec3(1.8)),
-                             lessThan(vec3(0.03125), color.rgb));)
+        GLSLF("color.rgb = mix(color.rgb * vec3(1.0/16.0),              \n"
+              "                pow(color.rgb, vec3(1.8)),               \n"
+              "                %s(lessThan(vec3(0.03125), color.rgb))); \n",
+              gl_sc_bvec(sc, 3));
         break;
     case MP_CSP_TRC_PQ:
         GLSLF("color.rgb = pow(color.rgb, vec3(1.0/%f));\n", PQ_M2);
@@ -397,16 +399,16 @@ void pass_linearize(struct gl_shader_cache *sc, enum mp_csp_trc trc)
     case MP_CSP_TRC_HLG:
         GLSLF("color.rgb = mix(vec3(4.0) * color.rgb * color.rgb,\n"
               "                exp((color.rgb - vec3(%f)) * vec3(1.0/%f)) + vec3(%f),\n"
-              "                lessThan(vec3(0.5), color.rgb));\n",
-              HLG_C, HLG_A, HLG_B);
+              "                %s(lessThan(vec3(0.5), color.rgb)));\n",
+              HLG_C, HLG_A, HLG_B, gl_sc_bvec(sc, 3));
         GLSLF("color.rgb *= vec3(1.0/%f);\n", MP_REF_WHITE_HLG);
         break;
     case MP_CSP_TRC_V_LOG:
         GLSLF("color.rgb = mix((color.rgb - vec3(0.125)) * vec3(1.0/5.6), \n"
               "    pow(vec3(10.0), (color.rgb - vec3(%f)) * vec3(1.0/%f)) \n"
               "              - vec3(%f),                                  \n"
-              "    lessThanEqual(vec3(0.181), color.rgb));                \n",
-              VLOG_D, VLOG_C, VLOG_B);
+              "    %s(lessThanEqual(vec3(0.181), color.rgb)));            \n",
+              VLOG_D, VLOG_C, VLOG_B, gl_sc_bvec(sc, 3));
         break;
     case MP_CSP_TRC_S_LOG1:
         GLSLF("color.rgb = pow(vec3(10.0), (color.rgb - vec3(%f)) * vec3(1.0/%f))\n"
@@ -417,8 +419,8 @@ void pass_linearize(struct gl_shader_cache *sc, enum mp_csp_trc trc)
         GLSLF("color.rgb = mix((color.rgb - vec3(%f)) * vec3(1.0/%f),      \n"
               "    (pow(vec3(10.0), (color.rgb - vec3(%f)) * vec3(1.0/%f)) \n"
               "              - vec3(%f)) * vec3(1.0/%f),                   \n"
-              "    lessThanEqual(vec3(%f), color.rgb));                    \n",
-              SLOG_Q, SLOG_P, SLOG_C, SLOG_A, SLOG_B, SLOG_K2, SLOG_Q);
+              "    %s(lessThanEqual(vec3(%f), color.rgb)));                \n",
+              SLOG_Q, SLOG_P, SLOG_C, SLOG_A, SLOG_B, SLOG_K2, gl_sc_bvec(sc, 3), SLOG_Q);
         break;
     default:
         abort();
@@ -444,10 +446,11 @@ void pass_delinearize(struct gl_shader_cache *sc, enum mp_csp_trc trc)
 
     switch (trc) {
     case MP_CSP_TRC_SRGB:
-        GLSL(color.rgb = mix(color.rgb * vec3(12.92),
-                             vec3(1.055) * pow(color.rgb, vec3(1.0/2.4))
-                                 - vec3(0.055),
-                             lessThanEqual(vec3(0.0031308), color.rgb));)
+        GLSLF("color.rgb = mix(color.rgb * vec3(12.92),                       \n"
+              "               vec3(1.055) * pow(color.rgb, vec3(1.0/2.4))     \n"
+              "                   - vec3(0.055),                              \n"
+              "               %s(lessThanEqual(vec3(0.0031308), color.rgb))); \n",
+              gl_sc_bvec(sc, 3));
         break;
     case MP_CSP_TRC_BT_1886:
         GLSL(color.rgb = pow(color.rgb, vec3(1.0/2.4));)
@@ -471,9 +474,10 @@ void pass_delinearize(struct gl_shader_cache *sc, enum mp_csp_trc trc)
         GLSL(color.rgb = pow(color.rgb, vec3(1.0/2.8));)
         break;
     case MP_CSP_TRC_PRO_PHOTO:
-        GLSL(color.rgb = mix(color.rgb * vec3(16.0),
-                             pow(color.rgb, vec3(1.0/1.8)),
-                             lessThanEqual(vec3(0.001953), color.rgb));)
+        GLSLF("color.rgb = mix(color.rgb * vec3(16.0),                        \n"
+              "                pow(color.rgb, vec3(1.0/1.8)),                 \n"
+              "                %s(lessThanEqual(vec3(0.001953), color.rgb))); \n",
+              gl_sc_bvec(sc, 3));
         break;
     case MP_CSP_TRC_PQ:
         GLSLF("color.rgb *= vec3(1.0/%f);\n", 10000 / MP_REF_WHITE);
@@ -487,15 +491,15 @@ void pass_delinearize(struct gl_shader_cache *sc, enum mp_csp_trc trc)
         GLSLF("color.rgb *= vec3(%f);\n", MP_REF_WHITE_HLG);
         GLSLF("color.rgb = mix(vec3(0.5) * sqrt(color.rgb),\n"
               "                vec3(%f) * log(color.rgb - vec3(%f)) + vec3(%f),\n"
-              "                lessThan(vec3(1.0), color.rgb));\n",
-              HLG_A, HLG_B, HLG_C);
+              "                %s(lessThan(vec3(1.0), color.rgb)));\n",
+              HLG_A, HLG_B, HLG_C, gl_sc_bvec(sc, 3));
         break;
     case MP_CSP_TRC_V_LOG:
         GLSLF("color.rgb = mix(vec3(5.6) * color.rgb + vec3(0.125),   \n"
               "                vec3(%f) * log(color.rgb + vec3(%f))   \n"
               "                    + vec3(%f),                        \n"
-              "                lessThanEqual(vec3(0.01), color.rgb)); \n",
-              VLOG_C / M_LN10, VLOG_B, VLOG_D);
+              "                %s(lessThanEqual(vec3(0.01), color.rgb))); \n",
+              VLOG_C / M_LN10, VLOG_B, VLOG_D, gl_sc_bvec(sc, 3));
         break;
     case MP_CSP_TRC_S_LOG1:
         GLSLF("color.rgb = vec3(%f) * log(color.rgb + vec3(%f)) + vec3(%f);\n",
@@ -505,8 +509,8 @@ void pass_delinearize(struct gl_shader_cache *sc, enum mp_csp_trc trc)
         GLSLF("color.rgb = mix(vec3(%f) * color.rgb + vec3(%f),                \n"
               "                vec3(%f) * log(vec3(%f) * color.rgb + vec3(%f)) \n"
               "                    + vec3(%f),                                 \n"
-              "                lessThanEqual(vec3(0.0), color.rgb));           \n",
-              SLOG_P, SLOG_Q, SLOG_A / M_LN10, SLOG_K2, SLOG_B, SLOG_C);
+              "                %s(lessThanEqual(vec3(0.0), color.rgb)));       \n",
+              SLOG_P, SLOG_Q, SLOG_A / M_LN10, SLOG_K2, SLOG_B, SLOG_C, gl_sc_bvec(sc, 3));
         break;
     default:
         abort();
@@ -537,9 +541,10 @@ static void pass_ootf(struct gl_shader_cache *sc, enum mp_csp_light light,
         // This OOTF is defined by encoding the result as 709 and then decoding
         // it as 1886; although this is called 709_1886 we actually use the
         // more precise (by one decimal) values from BT.2020 instead
-        GLSL(color.rgb = mix(color.rgb * vec3(4.5),
-                             vec3(1.0993) * pow(color.rgb, vec3(0.45)) - vec3(0.0993),
-                             lessThan(vec3(0.0181), color.rgb));)
+        GLSLF("color.rgb = mix(color.rgb * vec3(4.5),                  \n"
+              "                vec3(1.0993) * pow(color.rgb, vec3(0.45)) - vec3(0.0993), \n"
+              "                %s(lessThan(vec3(0.0181), color.rgb))); \n",
+              gl_sc_bvec(sc, 3));
         GLSL(color.rgb = pow(color.rgb, vec3(2.4));)
         break;
     case MP_CSP_LIGHT_SCENE_1_2:
@@ -570,10 +575,11 @@ static void pass_inverse_ootf(struct gl_shader_cache *sc, enum mp_csp_light ligh
     }
     case MP_CSP_LIGHT_SCENE_709_1886:
         GLSL(color.rgb = pow(color.rgb, vec3(1.0/2.4));)
-        GLSL(color.rgb = mix(color.rgb * vec3(1.0/4.5),
-                             pow((color.rgb + vec3(0.0993)) * vec3(1.0/1.0993),
-                                 vec3(1/0.45)),
-                             lessThan(vec3(0.08145), color.rgb));)
+        GLSLF("color.rgb = mix(color.rgb * vec3(1.0/4.5),               \n"
+              "                pow((color.rgb + vec3(0.0993)) * vec3(1.0/1.0993), \n"
+              "                    vec3(1/0.45)),                       \n"
+              "                %s(lessThan(vec3(0.08145), color.rgb))); \n",
+              gl_sc_bvec(sc, 3));
         break;
     case MP_CSP_LIGHT_SCENE_1_2:
         GLSL(color.rgb = pow(color.rgb, vec3(1.0/1.2));)
@@ -718,7 +724,8 @@ static void pass_tone_map(struct gl_shader_cache *sc,
               "max(1e-6, sig_peak - 1.0);\n");
         GLSLF("float scale = (b*b + 2.0*b*j + j*j) / (b-a);\n");
         GLSLF("sig = mix(sig, scale * (sig + vec3(a)) / (sig + vec3(b)),"
-              "          greaterThan(sig, vec3(j)));\n");
+              "          %s(greaterThan(sig, vec3(j))));\n",
+              gl_sc_bvec(sc, 3));
         GLSLF("}\n");
         break;
 
@@ -751,7 +758,8 @@ static void pass_tone_map(struct gl_shader_cache *sc,
         GLSL(float scale = pow(cutoff / sig_peak, gamma.x) / cutoff;)
         GLSLF("sig = mix(scale * sig,"
               "          pow(sig / sig_peak, vec3(gamma)),"
-              "          greaterThan(sig, vec3(cutoff)));\n");
+              "          %s(greaterThan(sig, vec3(cutoff))));\n",
+              gl_sc_bvec(sc, 3));
         break;
     }
 
@@ -784,7 +792,8 @@ static void pass_tone_map(struct gl_shader_cache *sc,
               "vec3 pb = (2.0 * tb3 - 3.0 * tb2 + vec3(1.0)) * vec3(ks) +       \n"
               "          (tb3 - 2.0 * tb2 + tb) * vec3(1.0 - ks) +              \n"
               "          (-2.0 * tb3 + 3.0 * tb2) * vec3(maxLum);               \n"
-              "sig = mix(pb, sig_pq.rgb, lessThan(sig_pq.rgb, vec3(ks)));       \n");
+              "sig = mix(pb, sig_pq.rgb, %s(lessThan(sig_pq.rgb, vec3(ks))));   \n",
+              gl_sc_bvec(sc, 3));
         // Convert back from PQ space to linear light
         GLSLF("sig *= vec3(sig_pq.a);                                           \n"
               "sig = pow(sig, vec3(1.0/%f));                                    \n"
@@ -879,7 +888,8 @@ void pass_color_map(struct gl_shader_cache *sc, bool is_linear,
                      float coeff = cmin / (cmin - luma);
                      color.rgb = mix(color.rgb, vec3(luma), coeff);
                  })
-            GLSL(float cmax = max(max(color.r, color.g), color.b);)
+            GLSLF("float cmax = 1.0/%f * max(max(color.r, color.g), color.b);\n",
+                  dst.sig_peak);
             GLSL(if (cmax > 1.0) color.rgb /= cmax;)
         }
     }
@@ -937,7 +947,7 @@ struct deband_opts {
 
 const struct deband_opts deband_opts_def = {
     .iterations = 1,
-    .threshold = 64.0,
+    .threshold = 32.0,
     .range = 16.0,
     .grain = 48.0,
 };
@@ -990,8 +1000,8 @@ void pass_sample_deband(struct gl_shader_cache *sc, struct deband_opts *opts,
         // the difference is below the given threshold
         GLSLF("avg = average(%f, h);\n", i * opts->range);
         GLSL(diff = abs(color - avg);)
-        GLSLF("color = mix(avg, color, greaterThan(diff, vec4(%f)));\n",
-              opts->threshold / (i * 16384.0));
+        GLSLF("color = mix(avg, color, %s(greaterThan(diff, vec4(%f))));\n",
+              gl_sc_bvec(sc, 4), opts->threshold / (i * 16384.0));
     }
 
     // Add some random noise to smooth out residual differences
diff --git a/video/out/hwdec/hwdec_vaapi.c b/video/out/hwdec/hwdec_vaapi.c
index 3ed9602..2a8e181 100644
--- a/video/out/hwdec/hwdec_vaapi.c
+++ b/video/out/hwdec/hwdec_vaapi.c
@@ -249,7 +249,7 @@ static int mapper_map(struct ra_hwdec_mapper *mapper)
     CHECK_VA_STATUS(mapper, "vaSyncSurface()");
     p->surface_acquired = true;
 
-    if (!p_owner->interop_map(mapper))
+    if (!p_owner->interop_map(mapper, p_owner->probing_formats))
         goto err;
 
     if (p->desc.fourcc == VA_FOURCC_YV12)
diff --git a/video/out/hwdec/hwdec_vaapi.h b/video/out/hwdec/hwdec_vaapi.h
index 471283a..b060ba3 100644
--- a/video/out/hwdec/hwdec_vaapi.h
+++ b/video/out/hwdec/hwdec_vaapi.h
@@ -33,7 +33,7 @@ struct priv_owner {
                          const struct ra_imgfmt_desc *desc);
     void (*interop_uninit)(const struct ra_hwdec_mapper *mapper);
 
-    bool (*interop_map)(struct ra_hwdec_mapper *mapper);
+    bool (*interop_map)(struct ra_hwdec_mapper *mapper, bool probing);
     void (*interop_unmap)(struct ra_hwdec_mapper *mapper);
 };
 
diff --git a/video/out/hwdec/hwdec_vaapi_gl.c b/video/out/hwdec/hwdec_vaapi_gl.c
index 1617167..f29a9d9 100644
--- a/video/out/hwdec/hwdec_vaapi_gl.c
+++ b/video/out/hwdec/hwdec_vaapi_gl.c
@@ -137,7 +137,7 @@ static void vaapi_gl_mapper_uninit(const struct ra_hwdec_mapper *mapper)
                         p_mapper->desc.layers[n].pitch[plane]); \
         } while (0)
 
-static bool vaapi_gl_map(struct ra_hwdec_mapper *mapper)
+static bool vaapi_gl_map(struct ra_hwdec_mapper *mapper, bool probing)
 {
     struct priv *p_mapper = mapper->priv;
     struct vaapi_gl_mapper_priv *p = p_mapper->interop_mapper_priv;
diff --git a/video/out/hwdec/hwdec_vaapi_vk.c b/video/out/hwdec/hwdec_vaapi_vk.c
index 1cee9e8..24cdce7 100644
--- a/video/out/hwdec/hwdec_vaapi_vk.c
+++ b/video/out/hwdec/hwdec_vaapi_vk.c
@@ -21,8 +21,9 @@
 #include "config.h"
 #include "hwdec_vaapi.h"
 #include "video/out/placebo/ra_pl.h"
+#include "video/out/placebo/utils.h"
 
-static bool vaapi_vk_map(struct ra_hwdec_mapper *mapper)
+static bool vaapi_vk_map(struct ra_hwdec_mapper *mapper, bool probing)
 {
     struct priv *p = mapper->priv;
     const struct pl_gpu *gpu = ra_pl_get(mapper->ra);
@@ -43,6 +44,7 @@ static bool vaapi_vk_map(struct ra_hwdec_mapper *mapper)
         int fd = p->desc.objects[id].fd;
         uint32_t size = p->desc.objects[id].size;
         uint32_t offset = p->desc.layers[n].offset[0];
+        uint32_t pitch = p->desc.layers[n].pitch[0];
 
 #if PL_API_VER >= 88
         // AMD drivers do not return the size in the surface description, so we
@@ -84,11 +86,16 @@ static bool vaapi_vk_map(struct ra_hwdec_mapper *mapper)
                 .offset = offset,
 #if PL_API_VER >= 88
                 .drm_format_mod = p->desc.objects[id].drm_format_modifier,
+#endif
+#if PL_API_VER >= 106
+                .stride_w = pitch,
 #endif
             },
         };
 
+        mppl_ctx_set_log(gpu->ctx, mapper->ra->log, probing);
         const struct pl_tex *pltex = pl_tex_create(gpu, &tex_params);
+        mppl_ctx_set_log(gpu->ctx, mapper->ra->log, false);
         if (!pltex) {
             return false;
         }
diff --git a/video/out/mac/common.swift b/video/out/mac/common.swift
index cb1b74b..6289c6b 100644
--- a/video/out/mac/common.swift
+++ b/video/out/mac/common.swift
@@ -100,6 +100,7 @@ class Common: NSObject {
         }
 
         window.setOnTop(Bool(mpv.opts.ontop), Int(mpv.opts.ontop_level))
+        window.setOnAllWorkspaces(Bool(mpv.opts.all_workspaces))
         window.keepAspect = Bool(mpv.opts.keepaspect_window)
         window.title = title
         window.border = Bool(mpv.opts.border)
@@ -186,8 +187,7 @@ class Common: NSObject {
     func startDisplayLink(_ vo: UnsafeMutablePointer<vo>) {
         CVDisplayLinkCreateWithActiveCGDisplays(&link)
 
-        guard let opts: mp_vo_opts = mpv?.opts,
-              let screen = getScreenBy(id: Int(opts.screen_id)) ?? NSScreen.main,
+        guard let screen = getTargetScreen(forFullscreen: false) ?? NSScreen.main,
               let link = self.link else
         {
             log.sendWarning("Couldn't start DisplayLink, no MPVHelper, Screen or DisplayLink available")
@@ -409,9 +409,27 @@ class Common: NSObject {
         return NSScreen.screens[screenID]
     }
 
+    func getScreenBy(name screenName: String?) -> NSScreen? {
+        for screen in NSScreen.screens {
+            if screen.displayName == screenName {
+                return screen
+            }
+        }
+        return nil
+    }
+
     func getTargetScreen(forFullscreen fs: Bool) -> NSScreen? {
-        let screenID = fs ? (mpv?.opts.fsscreen_id ?? 0) : (mpv?.opts.screen_id ?? 0)
-        return getScreenBy(id: Int(screenID))
+        guard let mpv = mpv else {
+            log.sendWarning("Unexpected nil value in getTargetScreen")
+            return nil
+        }
+
+        let screenID = fs ? mpv.opts.fsscreen_id : mpv.opts.screen_id
+        var name: String?
+        if let screenName = fs ? mpv.opts.fsscreen_name : mpv.opts.screen_name {
+            name = String(cString: screenName)
+        }
+        return getScreenBy(id: Int(screenID)) ?? getScreenBy(name: name)
     }
 
     func getCurrentScreen() -> NSScreen? {
@@ -420,25 +438,34 @@ class Common: NSObject {
                                     NSScreen.main
     }
 
-    func getWindowGeometry(forScreen targetScreen: NSScreen,
+    func getWindowGeometry(forScreen screen: NSScreen,
                            videoOut vo: UnsafeMutablePointer<vo>) -> NSRect {
-        let r = targetScreen.convertRectToBacking(targetScreen.frame)
-        var screenRC: mp_rect = mp_rect(x0: Int32(0),
-                                        y0: Int32(0),
-                                        x1: Int32(r.size.width),
-                                        y1: Int32(r.size.height))
+        let r = screen.convertRectToBacking(screen.frame)
+        let targetFrame = (mpv?.macOpts.macos_geometry_calculation ?? Int32(FRAME_VISIBLE)) == FRAME_VISIBLE
+            ? screen.visibleFrame : screen.frame
+        let rv = screen.convertRectToBacking(targetFrame)
+
+        // convert origin to be relative to target screen
+        var originY = rv.origin.y - r.origin.y
+        let originX = rv.origin.x - r.origin.x
+        // flip the y origin, mp_rect expects the origin at the top-left
+        // macOS' windowing system operates from the bottom-left
+        originY = -(originY + rv.size.height)
+        var screenRC: mp_rect = mp_rect(x0: Int32(originX),
+                                        y0: Int32(originY),
+                                        x1: Int32(originX + rv.size.width),
+                                        y1: Int32(originY + rv.size.height))
 
         var geo: vo_win_geometry = vo_win_geometry()
-        vo_calc_window_geometry2(vo, &screenRC, Double(targetScreen.backingScaleFactor), &geo)
+        vo_calc_window_geometry2(vo, &screenRC, Double(screen.backingScaleFactor), &geo)
+        vo_apply_window_geometry(vo, &geo)
 
-        // flip y coordinates
-        geo.win.y1 = Int32(r.size.height) - geo.win.y1
-        geo.win.y0 = Int32(r.size.height) - geo.win.y0
-
-        let wr = NSMakeRect(CGFloat(geo.win.x0), CGFloat(geo.win.y1),
-                            CGFloat(geo.win.x1 - geo.win.x0),
-                            CGFloat(geo.win.y0 - geo.win.y1))
-        return targetScreen.convertRectFromBacking(wr)
+        let height = CGFloat(geo.win.y1 - geo.win.y0)
+        let width = CGFloat(geo.win.x1 - geo.win.x0)
+        // flip the y origin again
+        let y = CGFloat(-geo.win.y1)
+        let x = CGFloat(geo.win.x0)
+        return screen.convertRectFromBacking(NSMakeRect(x, y, width, height))
     }
 
     func getInitProperties(_ vo: UnsafeMutablePointer<vo>) -> (MPVHelper, NSScreen, NSRect) {
@@ -446,7 +473,7 @@ class Common: NSObject {
             log.sendError("Something went wrong, no MPVHelper was initialized")
             exit(1)
         }
-        guard let targetScreen = getScreenBy(id: Int(mpv.opts.screen_id)) ?? NSScreen.main else {
+        guard let targetScreen = getTargetScreen(forFullscreen: false) ?? NSScreen.main else {
             log.sendError("Something went wrong, no Screen was found")
             exit(1)
         }
@@ -508,42 +535,40 @@ class Common: NSObject {
             events.pointee |= Int32(checkEvents())
             return VO_TRUE
         case VOCTRL_VO_OPTS_CHANGED:
-            var o: UnsafeMutableRawPointer?
-            while mpv.nextChangedOption(property: &o) {
-                guard let opt = o else {
-                    log.sendError("No changed options was retrieved")
-                    return VO_TRUE
-                }
-                if opt == UnsafeMutableRawPointer(&mpv.optsPtr.pointee.border) {
+            var opt: UnsafeMutableRawPointer?
+            while mpv.nextChangedOption(property: &opt) {
+                switch opt {
+                case MPVHelper.getPointer(&mpv.optsPtr.pointee.border):
                     DispatchQueue.main.async {
                         self.window?.border = Bool(mpv.opts.border)
                     }
-                }
-                if opt == UnsafeMutableRawPointer(&mpv.optsPtr.pointee.fullscreen) {
+                case MPVHelper.getPointer(&mpv.optsPtr.pointee.fullscreen):
                     DispatchQueue.main.async {
                         self.window?.toggleFullScreen(nil)
                     }
-                }
-                if opt == UnsafeMutableRawPointer(&mpv.optsPtr.pointee.ontop) ||
-                   opt == UnsafeMutableRawPointer(&mpv.optsPtr.pointee.ontop_level) {
+                case MPVHelper.getPointer(&mpv.optsPtr.pointee.ontop): fallthrough
+                case MPVHelper.getPointer(&mpv.optsPtr.pointee.ontop_level):
                     DispatchQueue.main.async {
                         self.window?.setOnTop(Bool(mpv.opts.ontop), Int(mpv.opts.ontop_level))
                     }
-                }
-                if opt == UnsafeMutableRawPointer(&mpv.optsPtr.pointee.keepaspect_window) {
+                case MPVHelper.getPointer(&mpv.optsPtr.pointee.all_workspaces):
+                    DispatchQueue.main.async {
+                        self.window?.setOnAllWorkspaces(Bool(mpv.opts.all_workspaces))
+                    }
+                case MPVHelper.getPointer(&mpv.optsPtr.pointee.keepaspect_window):
                     DispatchQueue.main.async {
                         self.window?.keepAspect = Bool(mpv.opts.keepaspect_window)
                     }
-                }
-                if opt == UnsafeMutableRawPointer(&mpv.optsPtr.pointee.window_minimized) {
+                case MPVHelper.getPointer(&mpv.optsPtr.pointee.window_minimized):
                     DispatchQueue.main.async {
                         self.window?.setMinimized(Bool(mpv.opts.window_minimized))
                     }
-                }
-                if opt == UnsafeMutableRawPointer(&mpv.optsPtr.pointee.window_maximized) {
+                case MPVHelper.getPointer(&mpv.optsPtr.pointee.window_maximized):
                     DispatchQueue.main.async {
                         self.window?.setMaximized(Bool(mpv.opts.window_maximized))
                     }
+                default:
+                    break
                 }
             }
             return VO_TRUE
@@ -624,6 +649,17 @@ class Common: NSObject {
             SWIFT_TARRAY_STRING_APPEND(nil, &array, &count, nil)
             dnames.pointee = array
             return VO_TRUE
+        case VOCTRL_GET_DISPLAY_RES:
+            guard let screen = getCurrentScreen() else {
+                log.sendWarning("No Screen available to retrieve frame")
+                return VO_NOTAVAIL
+            }
+            let sizeData = data.assumingMemoryBound(to: Int32.self)
+            let size = UnsafeMutableBufferPointer(start: sizeData, count: 2)
+            let frame = screen.convertRectToBacking(screen.frame)
+            size[0] = Int32(frame.size.width)
+            size[1] = Int32(frame.size.height)
+            return VO_TRUE
         case VOCTRL_GET_FOCUSED:
             let focus = data.assumingMemoryBound(to: CBool.self)
             focus.pointee = NSApp.isActive
@@ -653,19 +689,14 @@ class Common: NSObject {
             return
         }
 
-        var o: UnsafeMutableRawPointer?
-        while mpv.nextChangedMacOption(property: &o) {
-            guard let opt = o else {
-                log.sendWarning("Could not retrieve changed mac option")
-                return
-            }
-
+        var opt: UnsafeMutableRawPointer?
+        while mpv.nextChangedMacOption(property: &opt) {
             switch opt {
-            case UnsafeMutableRawPointer(&mpv.macOptsPtr.pointee.macos_title_bar_appearance):
+            case MPVHelper.getPointer(&mpv.macOptsPtr.pointee.macos_title_bar_appearance):
                 titleBar?.set(appearance: Int(mpv.macOpts.macos_title_bar_appearance))
-            case UnsafeMutableRawPointer(&mpv.macOptsPtr.pointee.macos_title_bar_material):
+            case MPVHelper.getPointer(&mpv.macOptsPtr.pointee.macos_title_bar_material):
                 titleBar?.set(material: Int(mpv.macOpts.macos_title_bar_material))
-            case UnsafeMutableRawPointer(&mpv.macOptsPtr.pointee.macos_title_bar_color):
+            case MPVHelper.getPointer(&mpv.macOptsPtr.pointee.macos_title_bar_color):
                 titleBar?.set(color: mpv.macOpts.macos_title_bar_color)
             default:
                 break
diff --git a/video/out/mac/title_bar.swift b/video/out/mac/title_bar.swift
index 623fe8f..e49c2bb 100644
--- a/video/out/mac/title_bar.swift
+++ b/video/out/mac/title_bar.swift
@@ -151,7 +151,7 @@ class TitleBar: NSVisualEffectView {
         }
     }
 
-    @objc func hide() {
+    @objc func hide(_ duration: TimeInterval = 0.20) {
         guard let window = common.window else { return }
         if window.isInFullscreen && !window.isAnimating {
             alphaValue = 0
@@ -159,7 +159,7 @@ class TitleBar: NSVisualEffectView {
             return
         }
         NSAnimationContext.runAnimationGroup({ (context) -> Void in
-            context.duration = 0.20
+            context.duration = duration
             systemBar?.animator().alphaValue = 0
             animator().alphaValue = 0
         }, completionHandler: {
diff --git a/video/out/mac/window.swift b/video/out/mac/window.swift
index d692d0d..8b6c5f0 100644
--- a/video/out/mac/window.swift
+++ b/video/out/mac/window.swift
@@ -30,7 +30,7 @@ class Window: NSWindow, NSWindowDelegate {
     var isInFullscreen: Bool = false
     var isAnimating: Bool = false
     var isMoving: Bool = false
-    var forceTargetScreen: Bool = false
+    var previousStyleMask: NSWindow.StyleMask = [.titled, .closable, .miniaturizable, .resizable]
 
     var unfsContentFramePixel: NSRect { get { return convertToBacking(unfsContentFrame ?? NSRect(x: 0, y: 0, width: 160, height: 90)) } }
     var framePixel: NSRect { get { return convertToBacking(frame) } }
@@ -61,6 +61,7 @@ class Window: NSWindow, NSWindowDelegate {
         set {
             let responder = firstResponder
             let windowTitle = title
+            previousStyleMask = super.styleMask
             super.styleMask = newValue
             makeFirstResponder(responder)
             title = windowTitle
@@ -163,22 +164,26 @@ class Window: NSWindow, NSWindowDelegate {
         NSAnimationContext.runAnimationGroup({ (context) -> Void in
             context.duration = getFsAnimationDuration(duration - 0.05)
             window.animator().setFrame(tScreen.frame, display: true)
-        }, completionHandler: { })
+        }, completionHandler: nil)
     }
 
     func window(_ window: NSWindow, startCustomAnimationToExitFullScreenWithDuration duration: TimeInterval) {
         guard let tScreen = targetScreen, let currentScreen = screen else { return }
         let newFrame = calculateWindowPosition(for: tScreen, withoutBounds: tScreen == screen)
         let intermediateFrame = aspectFit(rect: newFrame, in: currentScreen.frame)
-        common.view?.layerContentsPlacement = .scaleProportionallyToFill
-        common.titleBar?.hide()
-        styleMask.remove(.fullScreen)
-        setFrame(intermediateFrame, display: true)
+        common.titleBar?.hide(0.0)
 
         NSAnimationContext.runAnimationGroup({ (context) -> Void in
-            context.duration = getFsAnimationDuration(duration - 0.05)
-            window.animator().setFrame(newFrame, display: true)
-        }, completionHandler: { })
+            context.duration = 0.0
+            common.view?.layerContentsPlacement = .scaleProportionallyToFill
+            window.animator().setFrame(intermediateFrame, display: true)
+        }, completionHandler: {
+            NSAnimationContext.runAnimationGroup({ (context) -> Void in
+                context.duration = self.getFsAnimationDuration(duration - 0.05)
+                self.styleMask.remove(.fullScreen)
+                window.animator().setFrame(newFrame, display: true)
+            }, completionHandler: nil)
+        })
     }
 
     func windowDidEnterFullScreen(_ notification: Notification) {
@@ -225,7 +230,14 @@ class Window: NSWindow, NSWindowDelegate {
 
     func setToFullScreen() {
         guard let targetFrame = targetScreen?.frame else { return }
-        styleMask.insert(.fullScreen)
+
+        if #available(macOS 11.0, *) {
+            styleMask = .borderless
+            common.titleBar?.hide(0.0)
+        } else {
+            styleMask.insert(.fullScreen)
+        }
+
         NSApp.presentationOptions = [.autoHideMenuBar, .autoHideDock]
         setFrame(targetFrame, display: true)
         endAnimation()
@@ -236,10 +248,17 @@ class Window: NSWindow, NSWindowDelegate {
 
     func setToWindow() {
         guard let tScreen = targetScreen else { return }
+
+        if #available(macOS 11.0, *) {
+            styleMask = previousStyleMask
+            common.titleBar?.hide(0.0)
+        } else {
+            styleMask.remove(.fullScreen)
+        }
+
         let newFrame = calculateWindowPosition(for: tScreen, withoutBounds: targetScreen == screen)
         NSApp.presentationOptions = []
         setFrame(newFrame, display: true)
-        styleMask.remove(.fullScreen)
         endAnimation()
         isInFullscreen = false
         mpv?.setOption(fullscreen: isInFullscreen)
@@ -274,6 +293,14 @@ class Window: NSWindow, NSWindowDelegate {
         }
     }
 
+    func setOnAllWorkspaces(_ state: Bool) {
+        if state {
+            collectionBehavior.insert(.canJoinAllSpaces)
+        } else {
+            collectionBehavior.remove(.canJoinAllSpaces)
+        }
+    }
+
     func setMinimized(_ stateWanted: Bool) {
         if isMiniaturized == stateWanted { return }
 
diff --git a/video/out/opengl/context_drm_egl.c b/video/out/opengl/context_drm_egl.c
index 86ce571..4bae27f 100644
--- a/video/out/opengl/context_drm_egl.c
+++ b/video/out/opengl/context_drm_egl.c
@@ -880,6 +880,11 @@ static int drm_egl_control(struct ra_ctx *ctx, int *events, int request,
         *(double*)arg = fps;
         return VO_TRUE;
     }
+    case VOCTRL_GET_DISPLAY_RES: {
+        ((int *)arg)[0] = p->kms->mode.mode.hdisplay;
+        ((int *)arg)[1] = p->kms->mode.mode.vdisplay;
+        return VO_TRUE;
+    }
     case VOCTRL_PAUSE:
         ctx->vo->want_redraw = true;
         p->paused = true;
diff --git a/video/out/opengl/context_wayland.c b/video/out/opengl/context_wayland.c
index 9b50dda..b402ca9 100644
--- a/video/out/opengl/context_wayland.c
+++ b/video/out/opengl/context_wayland.c
@@ -25,9 +25,6 @@
 #include "egl_helpers.h"
 #include "utils.h"
 
-// Generated from presentation-time.xml
-#include "generated/wayland/presentation-time.h"
-
 #define EGL_PLATFORM_WAYLAND_EXT 0x31D8
 
 struct priv {
@@ -39,79 +36,6 @@ struct priv {
     struct wl_egl_window *egl_window;
 };
 
-static const struct wp_presentation_feedback_listener feedback_listener;
-
-static void feedback_sync_output(void *data, struct wp_presentation_feedback *fback,
-                               struct wl_output *output)
-{
-}
-
-static void feedback_presented(void *data, struct wp_presentation_feedback *fback,
-                              uint32_t tv_sec_hi, uint32_t tv_sec_lo,
-                              uint32_t tv_nsec, uint32_t refresh_nsec,
-                              uint32_t seq_hi, uint32_t seq_lo,
-                              uint32_t flags)
-{
-    struct vo_wayland_state *wl = data;
-    vo_wayland_sync_shift(wl);
-
-    if (fback)
-        wp_presentation_feedback_destroy(fback);
-
-    // Very similar to oml_sync_control, in this case we assume that every
-    // time the compositor receives feedback, a buffer swap has been already
-    // been performed.
-    //
-    // Notes:
-    //  - tv_sec_lo + tv_sec_hi is the equivalent of oml's ust
-    //  - seq_lo + seq_hi is the equivalent of oml's msc
-    //  - these values are updated everytime the compositor receives feedback.
-
-    int index = last_available_sync(wl);
-    if (index < 0) {
-        queue_new_sync(wl);
-        index = 0;
-    }
-    int64_t sec = (uint64_t) tv_sec_lo + ((uint64_t) tv_sec_hi << 32);
-    wl->sync[index].ust = sec * 1000000LL + (uint64_t) tv_nsec / 1000;
-    wl->sync[index].msc = (uint64_t) seq_lo + ((uint64_t) seq_hi << 32);
-    wl->sync[index].filled = true;
-}
-
-static void feedback_discarded(void *data, struct wp_presentation_feedback *fback)
-{
-}
-
-static const struct wp_presentation_feedback_listener feedback_listener = {
-    feedback_sync_output,
-    feedback_presented,
-    feedback_discarded,
-};
-
-static const struct wl_callback_listener frame_listener;
-
-static void frame_callback(void *data, struct wl_callback *callback, uint32_t time)
-{
-    struct vo_wayland_state *wl = data;
-
-    if (callback)
-        wl_callback_destroy(callback);
-
-    wl->frame_callback = wl_surface_frame(wl->surface);
-    wl_callback_add_listener(wl->frame_callback, &frame_listener, wl);
-
-    if (wl->presentation) {
-        wl->feedback = wp_presentation_feedback(wl->presentation, wl->surface);
-        wp_presentation_feedback_add_listener(wl->feedback, &feedback_listener, wl);
-    }
-
-    wl->frame_wait = false;
-}
-
-static const struct wl_callback_listener frame_listener = {
-    frame_callback,
-};
-
 static void resize(struct ra_ctx *ctx)
 {
     struct priv *p = ctx->priv;
@@ -123,8 +47,6 @@ static void resize(struct ra_ctx *ctx)
     const int32_t height = wl->scaling * mp_rect_h(wl->geometry);
 
     vo_wayland_set_opaque_region(wl, ctx->opts.want_alpha);
-    wl_surface_set_buffer_scale(wl->surface, wl->scaling);
-
     if (p->egl_window)
         wl_egl_window_resize(p->egl_window, width, height, 0, 0);
 
@@ -136,14 +58,8 @@ static bool wayland_egl_start_frame(struct ra_swapchain *sw, struct ra_fbo *out_
 {
     struct ra_ctx *ctx = sw->ctx;
     struct vo_wayland_state *wl = ctx->vo->wl;
-
     bool render = !wl->hidden || wl->opts->disable_vsync;
-
-    if (wl->frame_wait && wl->presentation)
-        vo_wayland_sync_clear(wl);
-
-    if (render)
-        wl->frame_wait = true;
+    wl->frame_wait = true;
 
     return render ? ra_gl_ctx_start_frame(sw, out_fbo) : false;
 }
@@ -160,12 +76,12 @@ static void wayland_egl_swap_buffers(struct ra_swapchain *sw)
         vo_wayland_wait_frame(wl);
 
     if (wl->presentation)
-        wayland_sync_swap(wl);
+        vo_wayland_sync_swap(wl);
 }
 
 static const struct ra_swapchain_fns wayland_egl_swapchain = {
-    .start_frame   = wayland_egl_start_frame,
-    .swap_buffers  = wayland_egl_swap_buffers,
+    .start_frame  = wayland_egl_start_frame,
+    .swap_buffers = wayland_egl_swap_buffers,
 };
 
 static void wayland_egl_get_vsync(struct ra_ctx *ctx, struct vo_vsync_info *info)
@@ -209,9 +125,6 @@ static bool egl_create_context(struct ra_ctx *ctx)
 
     ra_add_native_resource(ctx->ra, "wl", wl->display);
 
-    wl->frame_callback = wl_surface_frame(wl->surface);
-    wl_callback_add_listener(wl->frame_callback, &frame_listener, wl);
-
     return true;
 }
 
diff --git a/video/out/placebo/ra_pl.c b/video/out/placebo/ra_pl.c
index f8df590..09ff742 100644
--- a/video/out/placebo/ra_pl.c
+++ b/video/out/placebo/ra_pl.c
@@ -22,9 +22,7 @@ const struct pl_gpu *ra_pl_get(const struct ra *ra)
     return ra->fns == &ra_fns_pl ? get_gpu(ra) : NULL;
 }
 
-#if PL_API_VER >= 60
 static struct pl_timer *get_active_timer(const struct ra *ra);
-#endif
 
 struct ra *ra_create_pl(const struct pl_gpu *gpu, struct mp_log *log)
 {
@@ -144,8 +142,14 @@ bool mppl_wrap_tex(struct ra *ra, const struct pl_tex *pltex,
             .blit_dst = pltex->params.blit_dst,
             .host_mutable = pltex->params.host_writable,
             .downloadable = pltex->params.host_readable,
+#if PL_API_VER >= 103
+            // These don't exist upstream, so just pick something reasonable
+            .src_linear = pltex->params.format->caps & PL_FMT_CAP_LINEAR,
+            .src_repeat = false,
+#else
             .src_linear = pltex->params.sample_mode == PL_TEX_SAMPLE_LINEAR,
             .src_repeat = pltex->params.address_mode == PL_TEX_ADDRESS_REPEAT,
+#endif
         },
         .priv = (void *) pltex,
     };
@@ -157,32 +161,6 @@ static struct ra_tex *tex_create_pl(struct ra *ra,
                                     const struct ra_tex_params *params)
 {
     const struct pl_gpu *gpu = get_gpu(ra);
-
-    // Check size limits
-    bool ok = false;
-    switch (params->dimensions) {
-    case 1:
-        ok = params->w <= gpu->limits.max_tex_1d_dim;
-        break;
-
-    case 2:
-        ok = params->w <= gpu->limits.max_tex_2d_dim &&
-             params->h <= gpu->limits.max_tex_2d_dim;
-        break;
-
-    case 3:
-        ok = params->w <= gpu->limits.max_tex_2d_dim &&
-             params->h <= gpu->limits.max_tex_2d_dim &&
-             params->d <= gpu->limits.max_tex_2d_dim;
-        break;
-    };
-
-    if (!ok) {
-        MP_ERR(ra, "Texture size %dx%dx%d exceeds dimension limits!\n",
-               params->w, params->h, params->d);
-        return NULL;
-    }
-
     const struct pl_tex *pltex = pl_tex_create(gpu, &(struct pl_tex_params) {
         .w = params->w,
         .h = params->dimensions >= 2 ? params->h : 0,
@@ -195,10 +173,12 @@ static struct ra_tex *tex_create_pl(struct ra *ra,
         .blit_dst = params->blit_dst || params->render_dst,
         .host_writable = params->host_mutable,
         .host_readable = params->downloadable,
+#if PL_API_VER < 103
         .sample_mode = params->src_linear ? PL_TEX_SAMPLE_LINEAR
                                           : PL_TEX_SAMPLE_NEAREST,
         .address_mode = params->src_repeat ? PL_TEX_ADDRESS_REPEAT
                                            : PL_TEX_ADDRESS_CLAMP,
+#endif
         .initial_data = params->initial_data,
     });
 
@@ -209,6 +189,10 @@ static struct ra_tex *tex_create_pl(struct ra *ra,
         return NULL;
     }
 
+    // Keep track of these, so we can correctly bind them later
+    ratex->params.src_repeat = params->src_repeat;
+    ratex->params.src_linear = params->src_linear;
+
     return ratex;
 }
 
@@ -230,9 +214,7 @@ static bool tex_upload_pl(struct ra *ra, const struct ra_tex_upload_params *para
         .buf = params->buf ? params->buf->priv : NULL,
         .buf_offset = params->buf_offset,
         .ptr = (void *) params->src,
-#if PL_API_VER >= 60
         .timer = get_active_timer(ra),
-#endif
     };
 
     const struct pl_buf *staging = NULL;
@@ -285,9 +267,7 @@ static bool tex_download_pl(struct ra *ra, struct ra_tex_download_params *params
         .tex = tex,
         .ptr = params->dst,
         .stride_w = params->stride / texel_size,
-#if PL_API_VER >= 60
         .timer = get_active_timer(ra),
-#endif
     };
 
     uint8_t *staging = NULL;
@@ -320,19 +300,7 @@ static struct ra_buf *buf_create_pl(struct ra *ra,
         [RA_BUF_TYPE_SHARED_MEMORY]  = 0,
     };
 
-    const struct pl_gpu *gpu = get_gpu(ra);
-    size_t max_size[] = {
-        [PL_BUF_TEX_TRANSFER] = gpu->limits.max_xfer_size,
-        [PL_BUF_UNIFORM]      = gpu->limits.max_ubo_size,
-        [PL_BUF_STORAGE]      = gpu->limits.max_ssbo_size,
-    };
-
-    if (params->size > max_size[buf_type[params->type]]) {
-        MP_ERR(ra, "Buffer size %zu exceeds size limits!\n", params->size);
-        return NULL;
-    }
-
-    const struct pl_buf *plbuf = pl_buf_create(gpu, &(struct pl_buf_params) {
+    const struct pl_buf *plbuf = pl_buf_create(get_gpu(ra), &(struct pl_buf_params) {
         .type = buf_type[params->type],
         .size = params->size,
         .host_mapped = params->host_mapped,
@@ -399,7 +367,18 @@ static void blit_pl(struct ra *ra, struct ra_tex *dst, struct ra_tex *src,
         pldst.y1 = MPMIN(MPMAX(dst_rc->y1, 0), dst->params.h);
     }
 
+#if PL_API_VER >= 103
+    pl_tex_blit(get_gpu(ra), &(struct pl_tex_blit_params) {
+        .src = src->priv,
+        .dst = dst->priv,
+        .src_rc = plsrc,
+        .dst_rc = pldst,
+        .sample_mode = src->params.src_linear ? PL_TEX_SAMPLE_LINEAR
+                                              : PL_TEX_SAMPLE_NEAREST,
+    });
+#else
     pl_tex_blit(get_gpu(ra), dst->priv, src->priv, pldst, plsrc);
+#endif
 }
 
 static const enum pl_var_type var_type[RA_VARTYPE_COUNT] = {
@@ -627,9 +606,17 @@ static void renderpass_run_pl(struct ra *ra,
             struct pl_desc_binding bind;
             switch (inp->type) {
             case RA_VARTYPE_TEX:
-            case RA_VARTYPE_IMG_W:
-                bind.object = (* (struct ra_tex **) val->data)->priv;
+            case RA_VARTYPE_IMG_W: {
+                struct ra_tex *tex = *((struct ra_tex **) val->data);
+                bind.object = tex->priv;
+#if PL_API_VER >= 103
+                bind.sample_mode = tex->params.src_linear ? PL_TEX_SAMPLE_LINEAR
+                                                          : PL_TEX_SAMPLE_NEAREST;
+                bind.address_mode = tex->params.src_repeat ? PL_TEX_ADDRESS_REPEAT
+                                                           : PL_TEX_ADDRESS_CLAMP;
+#endif
                 break;
+            }
             case RA_VARTYPE_BUF_RO:
             case RA_VARTYPE_BUF_RW:
                 bind.object = (* (struct ra_buf **) val->data)->priv;
@@ -666,8 +653,6 @@ static void renderpass_run_pl(struct ra *ra,
     pl_pass_run(get_gpu(ra), &pl_params);
 }
 
-#if PL_API_VER >= 60
-
 struct ra_timer_pl {
     // Because libpplacebo only supports one operation per timer, we need
     // to use multiple pl_timers to sum up multiple passes/transfers
@@ -739,8 +724,6 @@ static struct pl_timer *get_active_timer(const struct ra *ra)
     return t->timers[t->idx_timers++];
 }
 
-#endif // PL_API_VER >= 60
-
 static struct ra_fns ra_fns_pl = {
     .destroy                = destroy_ra_pl,
     .tex_create             = tex_create_pl,
@@ -759,11 +742,9 @@ static struct ra_fns ra_fns_pl = {
     .renderpass_create      = renderpass_create_pl,
     .renderpass_destroy     = renderpass_destroy_pl,
     .renderpass_run         = renderpass_run_pl,
-#if PL_API_VER >= 60
     .timer_create           = timer_create_pl,
     .timer_destroy          = timer_destroy_pl,
     .timer_start            = timer_start_pl,
     .timer_stop             = timer_stop_pl,
-#endif
 };
 
diff --git a/video/out/vo.h b/video/out/vo.h
index 7efec53..8e17b3c 100644
--- a/video/out/vo.h
+++ b/video/out/vo.h
@@ -120,6 +120,7 @@ enum mp_voctrl {
     VOCTRL_GET_AMBIENT_LUX,             // int*
     VOCTRL_GET_DISPLAY_FPS,             // double*
     VOCTRL_GET_HIDPI_SCALE,             // double*
+    VOCTRL_GET_DISPLAY_RES,             // int[2]
 
     /* private to vo_gpu */
     VOCTRL_EXTERNAL_RESIZE,
diff --git a/video/out/vo_drm.c b/video/out/vo_drm.c
index a2c6fc8..a2fada9 100644
--- a/video/out/vo_drm.c
+++ b/video/out/vo_drm.c
@@ -654,6 +654,11 @@ static int control(struct vo *vo, uint32_t request, void *arg)
         *(double*)arg = fps;
         return VO_TRUE;
     }
+    case VOCTRL_GET_DISPLAY_RES: {
+        ((int *)arg)[0] = p->kms->mode.mode.hdisplay;
+        ((int *)arg)[1] = p->kms->mode.mode.vdisplay;
+        return VO_TRUE;
+    }
     case VOCTRL_PAUSE:
         vo->want_redraw = true;
         p->paused = true;
diff --git a/video/out/vo_gpu.c b/video/out/vo_gpu.c
index 5d28a30..38b29c3 100644
--- a/video/out/vo_gpu.c
+++ b/video/out/vo_gpu.c
@@ -292,8 +292,10 @@ static int preinit(struct vo *vo)
     p->log = vo->log;
 
     struct ra_ctx_opts opts = p->opts;
-    struct gl_video_opts *gl_opts = mp_get_config_group(p->ctx, vo->global, &gl_video_conf);
+    struct gl_video_opts *gl_opts =
+        mp_get_config_group(p->ctx, vo->global, &gl_video_conf);
     opts.want_alpha = gl_opts->alpha_mode == 1;
+    talloc_free(gl_opts);
 
     p->ctx = ra_ctx_create(vo, p->context_type, p->context_name, opts);
     if (!p->ctx)
@@ -321,8 +323,12 @@ err_out:
 
 #define OPT_BASE_STRUCT struct gpu_priv
 static const m_option_t options[] = {
-    {"gpu-context", OPT_STRING_VALIDATE(context_name, ra_ctx_validate_context)},
-    {"gpu-api", OPT_STRING_VALIDATE(context_type, ra_ctx_validate_api)},
+    {"gpu-context",
+        OPT_STRING_VALIDATE(context_name, ra_ctx_validate_context),
+        .help = ra_ctx_context_help},
+    {"gpu-api",
+        OPT_STRING_VALIDATE(context_type, ra_ctx_validate_api),
+        .help = ra_ctx_api_help},
     {"gpu-debug", OPT_FLAG(opts.debug)},
     {"gpu-sw", OPT_FLAG(opts.allow_sw)},
     {0}
diff --git a/video/out/vo_rpi.c b/video/out/vo_rpi.c
index 4d5de1d..bc5babb 100644
--- a/video/out/vo_rpi.c
+++ b/video/out/vo_rpi.c
@@ -748,6 +748,10 @@ static int control(struct vo *vo, uint32_t request, void *data)
     case VOCTRL_GET_DISPLAY_FPS:
         *(double *)data = p->display_fps;
         return VO_TRUE;
+    case VOCTRL_GET_DISPLAY_RES:
+        ((int *)data)[0] = p->w;
+        ((int *)data)[1] = p->h;
+        return VO_TRUE;
     }
 
     return VO_NOTIMPL;
diff --git a/video/out/vo_sixel.c b/video/out/vo_sixel.c
index 8318c51..c9cc157 100644
--- a/video/out/vo_sixel.c
+++ b/video/out/vo_sixel.c
@@ -63,19 +63,19 @@ struct priv {
     int opt_pad_x;
     int opt_rows;
     int opt_cols;
+    int opt_clear;
 
     // Internal data
     sixel_output_t *output;
     sixel_dither_t *dither;
     sixel_dither_t *testdither;
     uint8_t        *buffer;
+    bool            skip_frame_draw;
 
-    // The dimensions that will be actually
-    // be used after processing user inputs
-    int top;
-    int left;
-    int width;
-    int height;
+    int left, top;  // image origin cell (1 based)
+    int width, height;  // actual image px size - always reflects dst_rect.
+    int num_cols, num_rows;  // terminal size in cells
+    int canvas_ok;  // whether canvas vo->dwidth and vo->dheight are positive
 
     int previous_histgram_colors;
 
@@ -115,7 +115,7 @@ static int detect_scene_change(struct vo* vo)
 
 }
 
-static void dealloc_dithers_and_buffer(struct vo* vo)
+static void dealloc_dithers_and_buffers(struct vo* vo)
 {
     struct priv* priv = vo->priv;
 
@@ -124,6 +124,11 @@ static void dealloc_dithers_and_buffer(struct vo* vo)
         priv->buffer = NULL;
     }
 
+    if (priv->frame) {
+        talloc_free(priv->frame);
+        priv->frame = NULL;
+    }
+
     if (priv->dither) {
         sixel_dither_unref(priv->dither);
         priv->dither = NULL;
@@ -139,15 +144,15 @@ static SIXELSTATUS prepare_static_palette(struct vo* vo)
 {
     struct priv* priv = vo->priv;
 
-    if (priv->dither) {
-        sixel_dither_set_body_only(priv->dither, 1);
-    } else {
+    if (!priv->dither) {
         priv->dither = sixel_dither_get(BUILTIN_XTERM256);
         if (priv->dither == NULL)
             return SIXEL_FALSE;
 
         sixel_dither_set_diffusion_type(priv->dither, priv->opt_diffuse);
     }
+
+    sixel_dither_set_body_only(priv->dither, 0);
     return SIXEL_OK;
 }
 
@@ -159,7 +164,8 @@ static SIXELSTATUS prepare_dynamic_palette(struct vo *vo)
     /* create histgram and construct color palette
      * with median cut algorithm. */
     status = sixel_dither_initialize(priv->testdither, priv->buffer,
-                                     priv->width, priv->height, 3,
+                                     priv->width, priv->height,
+                                     SIXEL_PIXELFORMAT_RGB888,
                                      LARGE_NORM, REP_CENTER_BOX,
                                      QUALITY_LOW);
     if (SIXEL_FAILED(status))
@@ -179,22 +185,18 @@ static SIXELSTATUS prepare_dynamic_palette(struct vo *vo)
 
         sixel_dither_set_diffusion_type(priv->dither, priv->opt_diffuse);
     } else {
-        if (priv->dither == NULL) {
+        if (priv->dither == NULL)
             return SIXEL_FALSE;
-        }
-        sixel_dither_set_body_only(priv->dither, 1);
     }
 
+    sixel_dither_set_body_only(priv->dither, 0);
     return status;
 }
 
-static void resize(struct vo *vo)
+static void update_canvas_dimensions(struct vo *vo)
 {
     // this function sets the vo canvas size in pixels vo->dwidth, vo->dheight,
-    // and the output scaled size in priv->width, priv->height
-    // and the scaling rectangles in pixels priv->src_rect, priv->dst_rect
-    // as well as image positioning in cells priv->top, priv->left.
-    // no other scaling/rendering size values are required past this point.
+    // and the number of rows and columns available in priv->num_rows/cols
     struct priv *priv   = vo->priv;
     int num_rows        = TERMINAL_FALLBACK_ROWS;
     int num_cols        = TERMINAL_FALLBACK_COLS;
@@ -254,6 +256,19 @@ static void resize(struct vo *vo)
     vo->dheight = total_px_height * (num_rows - 1) / num_rows / 6 * 6;
     vo->dwidth  = total_px_width;
 
+    priv->num_rows = num_rows;
+    priv->num_cols = num_cols;
+
+    priv->canvas_ok = vo->dwidth > 0 && vo->dheight > 0;
+}
+
+static void set_sixel_output_parameters(struct vo *vo)
+{
+    // This function sets output scaled size in priv->width, priv->height
+    // and the scaling rectangles in pixels priv->src_rect, priv->dst_rect
+    // as well as image positioning in cells priv->top, priv->left.
+    struct priv *priv = vo->priv;
+
     vo_get_src_dst_rects(vo, &priv->src_rect, &priv->dst_rect, &priv->osd);
 
     // priv->width and priv->height are the width and height of dst_rect
@@ -265,15 +280,14 @@ static void resize(struct vo *vo)
     // top/left values must be greater than 1. If it is set, then
     // the image will be rendered from there and no further centering is done.
     priv->top  = (priv->opt_top  > 0) ?  priv->opt_top :
-                  num_rows * priv->dst_rect.y0 / vo->dheight + 1;
+                  priv->num_rows * priv->dst_rect.y0 / vo->dheight + 1;
     priv->left = (priv->opt_left > 0) ?  priv->opt_left :
-                  num_cols * priv->dst_rect.x0 / vo->dwidth  + 1;
+                  priv->num_cols * priv->dst_rect.x0 / vo->dwidth  + 1;
 }
 
-static int reconfig(struct vo *vo, struct mp_image_params *params)
+static int update_sixel_swscaler(struct vo *vo, struct mp_image_params *params)
 {
     struct priv *priv = vo->priv;
-    resize(vo);
 
     priv->sws->src = *params;
     priv->sws->src.w = mp_rect_w(priv->src_rect);
@@ -286,6 +300,8 @@ static int reconfig(struct vo *vo, struct mp_image_params *params)
         .p_h = 1,
     };
 
+    dealloc_dithers_and_buffers(vo);
+
     priv->frame = mp_image_alloc(IMGFMT, priv->width, priv->height);
     if (!priv->frame)
         return -1;
@@ -293,17 +309,15 @@ static int reconfig(struct vo *vo, struct mp_image_params *params)
     if (mp_sws_reinit(priv->sws) < 0)
         return -1;
 
-    printf(ESC_HIDE_CURSOR);
-    printf(ESC_CLEAR_SCREEN);
-    vo->want_redraw = true;
-
-    dealloc_dithers_and_buffer(vo);
-    SIXELSTATUS status = sixel_dither_new(&priv->testdither,
-                                          priv->opt_reqcolors, NULL);
-    if (SIXEL_FAILED(status)) {
-        MP_ERR(vo, "reconfig: Failed to create new dither: %s\n",
-               sixel_helper_format_error(status));
-        return -1;
+    // create testdither only if dynamic palette mode is set
+    if (!priv->opt_fixedpal) {
+        SIXELSTATUS status = sixel_dither_new(&priv->testdither,
+                                              priv->opt_reqcolors, NULL);
+        if (SIXEL_FAILED(status)) {
+            MP_ERR(vo, "update_sixel_swscaler: Failed to create new dither: %s\n",
+                   sixel_helper_format_error(status));
+            return -1;
+        }
     }
 
     priv->buffer =
@@ -312,28 +326,82 @@ static int reconfig(struct vo *vo, struct mp_image_params *params)
     return 0;
 }
 
-static void draw_image(struct vo *vo, mp_image_t *mpi)
+static int reconfig(struct vo *vo, struct mp_image_params *params)
+{
+    struct priv *priv = vo->priv;
+    int ret = 0;
+    update_canvas_dimensions(vo);
+    if (priv->canvas_ok) {  // if too small - succeed but skip the rendering
+        set_sixel_output_parameters(vo);
+        ret = update_sixel_swscaler(vo, params);
+    }
+
+    printf(ESC_CLEAR_SCREEN);
+    vo->want_redraw = true;
+
+    return ret;
+}
+
+static void draw_frame(struct vo *vo, struct vo_frame *frame)
 {
     struct priv *priv = vo->priv;
-    struct mp_image src = *mpi;
     SIXELSTATUS status;
+    struct mp_image *mpi = NULL;
+
+    int  prev_rows   = priv->num_rows;
+    int  prev_cols   = priv->num_cols;
+    int  prev_height = vo->dheight;
+    int  prev_width  = vo->dwidth;
+    bool resized     = false;
+    update_canvas_dimensions(vo);
+    if (!priv->canvas_ok)
+        return;
 
-    struct mp_rect src_rc = priv->src_rect;
-    src_rc.x0 = MP_ALIGN_DOWN(src_rc.x0, mpi->fmt.align_x);
-    src_rc.y0 = MP_ALIGN_DOWN(src_rc.y0, mpi->fmt.align_y);
-    mp_image_crop_rc(&src, src_rc);
+    if (prev_rows != priv->num_rows || prev_cols != priv->num_cols ||
+        prev_width != vo->dwidth || prev_height != vo->dheight)
+    {
+        set_sixel_output_parameters(vo);
+        // Not checking for vo->config_ok because draw_frame is never called
+        // with a failed reconfig.
+        update_sixel_swscaler(vo, vo->params);
 
-    // Downscale the image
-    mp_sws_scale(priv->sws, priv->frame, &src);
+        printf(ESC_CLEAR_SCREEN);
+        resized = true;
+    }
+
+    if (frame->repeat && !frame->redraw && !resized) {
+        // Frame is repeated, and no need to update OSD either
+        priv->skip_frame_draw = true;
+        return;
+    } else {
+        // Either frame is new, or OSD has to be redrawn
+        priv->skip_frame_draw = false;
+    }
+
+    // Normal case where we have to draw the frame and the image is not NULL
+    if (frame->current) {
+        mpi = mp_image_new_ref(frame->current);
+        struct mp_rect src_rc = priv->src_rect;
+        src_rc.x0 = MP_ALIGN_DOWN(src_rc.x0, mpi->fmt.align_x);
+        src_rc.y0 = MP_ALIGN_DOWN(src_rc.y0, mpi->fmt.align_y);
+        mp_image_crop_rc(mpi, src_rc);
+
+        // scale/pan to our dest rect
+        mp_sws_scale(priv->sws, priv->frame, mpi);
+    } else {
+        // Image is NULL, so need to clear image and draw OSD
+        mp_image_clear(priv->frame, 0, 0, priv->width, priv->height);
+    }
 
     struct mp_osd_res dim = {
         .w = priv->width,
         .h = priv->height
     };
     osd_draw_on_image(vo->osd, dim, mpi ? mpi->pts : 0, 0, priv->frame);
+
     // Copy from mpv to RGB format as required by libsixel
-    memcpy_pic(priv->buffer, priv->frame->planes[0], priv->width * depth, priv->height,
-               priv->width * depth, priv->frame->stride[0]);
+    memcpy_pic(priv->buffer, priv->frame->planes[0], priv->width * depth,
+               priv->height, priv->width * depth, priv->frame->stride[0]);
 
     // Even if either of these prepare palette functions fail, on re-running them
     // they should try to re-initialize the dithers, so it shouldn't dereference
@@ -346,11 +414,12 @@ static void draw_image(struct vo *vo, mp_image_t *mpi)
     }
 
     if (SIXEL_FAILED(status)) {
-        MP_WARN(vo, "draw_image: prepare_palette returned error: %s\n",
+        MP_WARN(vo, "draw_frame: prepare_palette returned error: %s\n",
                 sixel_helper_format_error(status));
     }
 
-    talloc_free(mpi);
+    if (mpi)
+        talloc_free(mpi);
 }
 
 static int sixel_write(char *data, int size, void *priv)
@@ -361,6 +430,12 @@ static int sixel_write(char *data, int size, void *priv)
 static void flip_page(struct vo *vo)
 {
     struct priv* priv = vo->priv;
+    if (!priv->canvas_ok)
+        return;
+
+    // If frame is repeated and no update required, then we skip encoding
+    if (priv->skip_frame_draw)
+        return;
 
     // Make sure that image and dither are valid before drawing
     if (priv->buffer == NULL || priv->dither == NULL)
@@ -369,8 +444,7 @@ static void flip_page(struct vo *vo)
     // Go to the offset row and column, then display the image
     printf(ESC_GOTOXY, priv->top, priv->left);
     sixel_encode(priv->buffer, priv->width, priv->height,
-                 PIXELFORMAT_RGB888,
-                 priv->dither, priv->output);
+                 depth, priv->dither, priv->output);
     fflush(stdout);
 }
 
@@ -400,18 +474,17 @@ static int preinit(struct vo *vo)
     printf(ESC_USE_GLOBAL_COLOR_REG);
 
     priv->dither = NULL;
-    status = sixel_dither_new(&priv->testdither, priv->opt_reqcolors, NULL);
 
-    if (SIXEL_FAILED(status)) {
-        MP_ERR(vo, "preinit: Failed to create new dither: %s\n",
-               sixel_helper_format_error(status));
-        return -1;
+    // create testdither only if dynamic palette mode is set
+    if (!priv->opt_fixedpal) {
+        status = sixel_dither_new(&priv->testdither, priv->opt_reqcolors, NULL);
+        if (SIXEL_FAILED(status)) {
+            MP_ERR(vo, "preinit: Failed to create new dither: %s\n",
+                   sixel_helper_format_error(status));
+            return -1;
+        }
     }
 
-    resize(vo);
-    priv->buffer =
-        talloc_array(NULL, uint8_t, depth * priv->width * priv->height);
-
     priv->previous_histgram_colors = 0;
 
     return 0;
@@ -424,15 +497,9 @@ static int query_format(struct vo *vo, int format)
 
 static int control(struct vo *vo, uint32_t request, void *data)
 {
-    if (request == VOCTRL_SET_PANSCAN) {
-        if (!reconfig(vo, vo->params)) {
-            return VO_TRUE;
-        } else {
-            return VO_FALSE;
-        }
-    } else {
-        return VO_NOTIMPL;
-    }
+    if (request == VOCTRL_SET_PANSCAN)
+        return (vo->config_ok && !reconfig(vo, vo->params)) ? VO_TRUE : VO_FALSE;
+    return VO_NOTIMPL;
 }
 
 
@@ -442,8 +509,10 @@ static void uninit(struct vo *vo)
 
     printf(ESC_RESTORE_CURSOR);
 
-    printf(ESC_CLEAR_SCREEN);
-    printf(ESC_GOTOXY, 1, 1);
+    if (priv->opt_clear) {
+        printf(ESC_CLEAR_SCREEN);
+        printf(ESC_GOTOXY, 1, 1);
+    }
     fflush(stdout);
 
     if (priv->output) {
@@ -451,24 +520,24 @@ static void uninit(struct vo *vo)
         priv->output = NULL;
     }
 
-    dealloc_dithers_and_buffer(vo);
+    dealloc_dithers_and_buffers(vo);
 }
 
 #define OPT_BASE_STRUCT struct priv
 
 const struct vo_driver video_out_sixel = {
     .name = "sixel",
-    .description = "libsixel",
+    .description = "terminal graphics using sixels",
     .preinit = preinit,
     .query_format = query_format,
     .reconfig = reconfig,
     .control = control,
-    .draw_image = draw_image,
+    .draw_frame = draw_frame,
     .flip_page = flip_page,
     .uninit = uninit,
     .priv_size = sizeof(struct priv),
     .priv_defaults = &(const struct priv) {
-        .opt_diffuse = DIFFUSE_ATKINSON,
+        .opt_diffuse = DIFFUSE_AUTO,
         .opt_width = 0,
         .opt_height = 0,
         .opt_reqcolors = 256,
@@ -480,6 +549,7 @@ const struct vo_driver video_out_sixel = {
         .opt_pad_x = -1,
         .opt_rows = 0,
         .opt_cols = 0,
+        .opt_clear = 1,
     },
     .options = (const m_option_t[]) {
         {"dither", OPT_CHOICE(opt_diffuse,
@@ -503,6 +573,7 @@ const struct vo_driver video_out_sixel = {
         {"pad-x", OPT_INT(opt_pad_x)},
         {"rows", OPT_INT(opt_rows)},
         {"cols", OPT_INT(opt_cols)},
+        {"exit-clear", OPT_FLAG(opt_clear), },
         {0}
     },
     .options_prefix = "vo-sixel",
diff --git a/video/out/vo_tct.c b/video/out/vo_tct.c
index b0965e1..9325d3c 100644
--- a/video/out/vo_tct.c
+++ b/video/out/vo_tct.c
@@ -76,7 +76,6 @@ static const struct m_sub_options vo_tct_conf = {
 struct priv {
     struct vo_tct_opts *opts;
     size_t buffer_size;
-    char *buffer;
     int swidth;
     int sheight;
     struct mp_image *frame;
@@ -200,9 +199,6 @@ static int reconfig(struct vo *vo, struct mp_image_params *params)
     p->swidth = p->dst.x1 - p->dst.x0;
     p->sheight = p->dst.y1 - p->dst.y0;
 
-    if (p->buffer)
-        free(p->buffer);
-
     p->sws->src = *params;
     p->sws->dst = (struct mp_image_params) {
         .imgfmt = IMGFMT,
@@ -213,6 +209,8 @@ static int reconfig(struct vo *vo, struct mp_image_params *params)
     };
 
     const int mul = (p->opts->algo == ALGO_PLAIN ? 1 : 2);
+    if (p->frame)
+        talloc_free(p->frame);
     p->frame = mp_image_alloc(IMGFMT, p->swidth, p->sheight * mul);
     if (!p->frame)
         return -1;
@@ -258,8 +256,8 @@ static void uninit(struct vo *vo)
     printf(ESC_CLEAR_SCREEN);
     printf(ESC_GOTOXY, 0, 0);
     struct priv *p = vo->priv;
-    if (p->buffer)
-        talloc_free(p->buffer);
+    if (p->frame)
+        talloc_free(p->frame);
 }
 
 static int preinit(struct vo *vo)
diff --git a/video/out/vo_wlshm.c b/video/out/vo_wlshm.c
index f6c3771..5e7ae94 100644
--- a/video/out/vo_wlshm.c
+++ b/video/out/vo_wlshm.c
@@ -23,6 +23,7 @@
 
 #include <libswscale/swscale.h>
 
+#include "osdep/endian.h"
 #include "sub/osd.h"
 #include "video/fmt-conversion.h"
 #include "video/mp_image.h"
@@ -73,25 +74,6 @@ static void buffer_destroy(void *p)
     munmap(buf->mpi.planes[0], buf->size);
 }
 
-static const struct wl_callback_listener frame_listener;
-
-static void frame_callback(void *data, struct wl_callback *callback, uint32_t time)
-{
-    struct vo_wayland_state *wl = data;
-
-    if (callback)
-        wl_callback_destroy(callback);
-
-    wl->frame_callback = wl_surface_frame(wl->surface);
-    wl_callback_add_listener(wl->frame_callback, &frame_listener, wl);
-
-    wl->frame_wait = false;
-}
-
-static const struct wl_callback_listener frame_listener = {
-    frame_callback,
-};
-
 static int allocate_memfd(size_t size)
 {
     int fd = memfd_create("mpv", MFD_CLOEXEC | MFD_ALLOW_SEALING);
@@ -142,10 +124,6 @@ static struct buffer *buffer_create(struct vo *vo, int width, int height)
     if (!buf->buffer)
         goto error4;
     wl_buffer_add_listener(buf->buffer, &buffer_listener, buf);
-    if (!wl->frame_callback) {
-        wl->frame_callback = wl_surface_frame(wl->surface);
-        wl_callback_add_listener(wl->frame_callback, &frame_listener, wl);
-    }
 
     close(fd);
     talloc_set_destructor(buf, buffer_destroy);
@@ -207,7 +185,7 @@ static int resize(struct vo *vo)
     vo->dheight = height;
     vo_get_src_dst_rects(vo, &p->src, &p->dst, &p->osd);
     p->sws->dst = (struct mp_image_params) {
-        .imgfmt = IMGFMT_BGR0,
+        .imgfmt = MP_SELECT_LE_BE(IMGFMT_BGR0, IMGFMT_0RGB),
         .w = width,
         .h = height,
         .p_w = 1,
@@ -240,12 +218,12 @@ static void draw_image(struct vo *vo, struct mp_image *src)
     struct priv *p = vo->priv;
     struct vo_wayland_state *wl = vo->wl;
     struct buffer *buf;
+    bool render = !wl->hidden || wl->opts->disable_vsync;
+    wl->frame_wait = true;
 
-    if (wl->hidden)
+    if (!render)
         return;
 
-    wl->frame_wait = true;
-
     buf = p->free_buffers;
     if (buf) {
         p->free_buffers = buf->next;
@@ -298,6 +276,19 @@ static void flip_page(struct vo *vo)
 
     if (!wl->opts->disable_vsync)
         vo_wayland_wait_frame(wl);
+
+    if (wl->presentation)
+        vo_wayland_sync_swap(wl);
+}
+
+static void get_vsync(struct vo *vo, struct vo_vsync_info *info)
+{
+    struct vo_wayland_state *wl = vo->wl;
+    if (wl->presentation) {
+        info->vsync_duration = wl->vsync_duration;
+        info->skipped_vsyncs = wl->last_skipped_vsyncs;
+        info->last_queue_display_time = wl->last_queue_display_time;
+    }
 }
 
 static void uninit(struct vo *vo)
@@ -327,6 +318,7 @@ const struct vo_driver video_out_wlshm = {
     .control = control,
     .draw_image = draw_image,
     .flip_page = flip_page,
+    .get_vsync = get_vsync,
     .wakeup = vo_wayland_wakeup,
     .wait_events = vo_wayland_wait_events,
     .uninit = uninit,
diff --git a/video/out/vulkan/context.c b/video/out/vulkan/context.c
index 3518d3e..efc62a2 100644
--- a/video/out/vulkan/context.c
+++ b/video/out/vulkan/context.c
@@ -31,8 +31,9 @@ struct vulkan_opts {
 };
 
 static int vk_validate_dev(struct mp_log *log, const struct m_option *opt,
-                           struct bstr name, struct bstr param)
+                           struct bstr name, const char **value)
 {
+    struct bstr param = bstr0(*value);
     int ret = M_OPT_INVALID;
     VkResult res;
 
@@ -220,6 +221,20 @@ bool ra_vk_ctx_resize(struct ra_ctx *ctx, int width, int height)
     return ok;
 }
 
+char *ra_vk_ctx_get_device_name(struct ra_ctx *ctx)
+{
+    /*
+     * This implementation is a bit odd because it has to work even if the
+     * ctx hasn't been initialised yet. A context implementation may need access
+     * to the device name before it can fully initialise the ctx.
+     */
+    struct vulkan_opts *opts = mp_get_config_group(NULL, ctx->global,
+                                                   &vulkan_conf);
+    char *device_name = talloc_strdup(NULL, opts->device);
+    talloc_free(opts);
+    return device_name;
+}
+
 static int color_depth(struct ra_swapchain *sw)
 {
     return 0; // TODO: implement this somehow?
diff --git a/video/out/vulkan/context.h b/video/out/vulkan/context.h
index 6ae64bb..d85b3fe 100644
--- a/video/out/vulkan/context.h
+++ b/video/out/vulkan/context.h
@@ -25,3 +25,6 @@ bool ra_vk_ctx_resize(struct ra_ctx *ctx, int width, int height);
 
 // May be called on a ra_ctx of any type.
 struct mpvk_ctx *ra_vk_ctx_get(struct ra_ctx *ctx);
+
+// Get the user requested Vulkan device name.
+char *ra_vk_ctx_get_device_name(struct ra_ctx *ctx);
\ No newline at end of file
diff --git a/video/out/vulkan/context_display.c b/video/out/vulkan/context_display.c
new file mode 100644
index 0000000..5545b33
--- /dev/null
+++ b/video/out/vulkan/context_display.c
@@ -0,0 +1,395 @@
+/*
+ * This file is part of mpv.
+ *
+ * mpv is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * mpv is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "options/m_config.h"
+
+#include "context.h"
+#include "utils.h"
+
+struct vulkan_display_opts {
+    int display;
+    int mode;
+    int plane;
+};
+
+struct mode_selector {
+    // Indexes of selected display/mode/plane.
+    int display_idx;
+    int mode_idx;
+    int plane_idx;
+
+    // Must be freed with talloc_free
+    VkDisplayModePropertiesKHR *out_mode_props;
+};
+
+/**
+ * If a selector is passed, verify that it is valid and return the matching
+ * mode properties. If null is passed, walk all modes and print them out.
+ */
+static bool walk_display_properties(struct mp_log *log,
+                                    int msgl_err,
+                                    VkPhysicalDevice device,
+                                    struct mode_selector *selector) {
+    bool ret = false;
+    VkResult res;
+
+    int msgl_info = selector ? MSGL_TRACE : MSGL_INFO;
+
+    // Use a dummy as parent for all other allocations.
+    void *tmp = talloc_new(NULL);
+
+    VkPhysicalDeviceProperties prop;
+    vkGetPhysicalDeviceProperties(device, &prop);
+    mp_msg(log, msgl_info, "  '%s' (GPU ID %x:%x)\n", prop.deviceName,
+           (unsigned)prop.vendorID, (unsigned)prop.deviceID);
+
+    // Count displays. This must be done before enumerating planes with the
+    // Intel driver, or it will not enumerate any planes. WTF.
+    int num_displays = 0;
+    vkGetPhysicalDeviceDisplayPropertiesKHR(device, &num_displays, NULL);
+    if (!num_displays) {
+        mp_msg(log, msgl_info, "    No available displays for device.\n");
+        goto done;
+    }
+    if (selector && selector->display_idx + 1 > num_displays) {
+        mp_msg(log, msgl_err, "Selected display (%d) not present.\n",
+               selector->display_idx);
+        goto done;
+    }
+
+    // Enumerate Planes
+    int num_planes = 0;
+    vkGetPhysicalDeviceDisplayPlanePropertiesKHR(device, &num_planes, NULL);
+    if (!num_planes) {
+        mp_msg(log, msgl_info, "    No available planes for device.\n");
+        goto done;
+    }
+    if (selector && selector->plane_idx + 1 > num_planes) {
+        mp_msg(log, msgl_err, "Selected plane (%d) not present.\n",
+               selector->plane_idx);
+        goto done;
+    }
+
+    VkDisplayPlanePropertiesKHR *planes =
+        talloc_array(tmp, VkDisplayPlanePropertiesKHR, num_planes);
+    res = vkGetPhysicalDeviceDisplayPlanePropertiesKHR(device, &num_planes,
+                                                       planes);
+    if (res != VK_SUCCESS) {
+        mp_msg(log, msgl_err, "    Failed enumerating planes\n");
+        goto done;
+    }
+
+    // Allocate zeroed arrays so that planes with no displays have a null entry.
+    VkDisplayKHR **planes_to_displays =
+        talloc_zero_array(tmp, VkDisplayKHR *, num_planes);
+    for (int j = 0; j < num_planes; j++) {
+        int num_displays_for_plane = 0;
+        vkGetDisplayPlaneSupportedDisplaysKHR(device, j,
+                                              &num_displays_for_plane, NULL);
+        if (!num_displays_for_plane)
+            continue;
+
+        // Null terminated array
+        VkDisplayKHR *displays =
+            talloc_zero_array(planes_to_displays, VkDisplayKHR,
+                              num_displays_for_plane + 1);
+        res = vkGetDisplayPlaneSupportedDisplaysKHR(device, j,
+                                                    &num_displays_for_plane,
+                                                    displays);
+        if (res != VK_SUCCESS) {
+            mp_msg(log, msgl_err, "      Failed enumerating plane displays\n");
+            continue;
+        }
+        planes_to_displays[j] = displays;
+    }
+
+    // Enumerate Displays and Modes
+    VkDisplayPropertiesKHR *props =
+        talloc_array(tmp, VkDisplayPropertiesKHR, num_displays);
+    res = vkGetPhysicalDeviceDisplayPropertiesKHR(device, &num_displays, props);
+    if (res != VK_SUCCESS) {
+        mp_msg(log, msgl_err, "    Failed enumerating display properties\n");
+        goto done;
+    }
+
+    for (int j = 0; j < num_displays; j++) {
+        if (selector && selector->display_idx != j)
+            continue;
+
+        mp_msg(log, msgl_info, "    Display %d: '%s' (%dx%d)\n",
+               j,
+               props[j].displayName,
+               props[j].physicalResolution.width,
+               props[j].physicalResolution.height);
+
+        VkDisplayKHR display = props[j].display;
+
+        mp_msg(log, msgl_info, "    Modes:\n");
+
+        int num_modes = 0;
+        vkGetDisplayModePropertiesKHR(device, display, &num_modes, NULL);
+        if (!num_modes) {
+            mp_msg(log, msgl_info, "      No available modes for display.\n");
+            continue;
+        }
+        if (selector && selector->mode_idx + 1 > num_modes) {
+            mp_msg(log, msgl_err, "Selected mode (%d) not present.\n",
+                   selector->mode_idx);
+            goto done;
+        }
+
+        VkDisplayModePropertiesKHR *modes =
+            talloc_array(tmp, VkDisplayModePropertiesKHR, num_modes);
+        res = vkGetDisplayModePropertiesKHR(device, display, &num_modes, modes);
+        if (res != VK_SUCCESS) {
+            mp_msg(log, msgl_err, "      Failed enumerating display modes\n");
+            continue;
+        }
+
+        for (int k = 0; k < num_modes; k++) {
+            if (selector && selector->mode_idx != k)
+                continue;
+
+            mp_msg(log, msgl_info, "      Mode %02d: %dx%d (%02d.%03d Hz)\n", k,
+                   modes[k].parameters.visibleRegion.width,
+                   modes[k].parameters.visibleRegion.height,
+                   modes[k].parameters.refreshRate / 1000,
+                   modes[k].parameters.refreshRate % 1000);
+
+            if (selector)
+                selector->out_mode_props = talloc_dup(NULL, &modes[k]);
+        }
+
+        int found_plane = -1;
+        mp_msg(log, msgl_info, "    Planes:\n");
+        for (int k = 0; k < num_planes; k++) {
+            VkDisplayKHR *displays = planes_to_displays[k];
+            if (!displays) {
+                // This plane is not connected to any displays.
+                continue;
+            }
+            for (int d = 0; displays[d]; d++) {
+                if (displays[d] == display) {
+                    if (selector && selector->plane_idx != k)
+                        continue;
+
+                    mp_msg(log, msgl_info, "      Plane: %d\n", k);
+                    found_plane = k;
+                }
+            }
+        }
+        if (selector && selector->plane_idx != found_plane) {
+            mp_msg(log, msgl_err,
+                   "Selected plane (%d) not available on selected display.\n",
+                   selector->plane_idx);
+            goto done;
+        }
+    }
+    ret = true;
+done:
+    talloc_free(tmp);
+    return ret;
+}
+
+static int print_display_info(struct mp_log *log, const struct m_option *opt,
+                              struct bstr name) {
+    VkResult res;
+    VkPhysicalDevice *devices = NULL;
+
+    // Create a dummy instance to list the resources
+    VkInstanceCreateInfo info = {
+        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
+        .enabledExtensionCount = 1,
+        .ppEnabledExtensionNames = (const char*[]) {
+            VK_KHR_DISPLAY_EXTENSION_NAME
+        },
+    };
+
+    VkInstance inst = NULL;
+    res = vkCreateInstance(&info, NULL, &inst);
+    if (res != VK_SUCCESS) {
+        mp_warn(log, "Unable to create Vulkan instance.\n");
+        goto done;
+    }
+
+    uint32_t num_devices = 0;
+    vkEnumeratePhysicalDevices(inst, &num_devices, NULL);
+    if (!num_devices) {
+        mp_info(log, "No Vulkan devices detected.\n");
+        goto done;
+    }
+
+    devices = talloc_array(NULL, VkPhysicalDevice, num_devices);
+    vkEnumeratePhysicalDevices(inst, &num_devices, devices);
+    if (res != VK_SUCCESS) {
+        mp_warn(log, "Failed enumerating physical devices.\n");
+        goto done;
+    }
+
+    mp_info(log, "Vulkan Devices:\n");
+    for (int i = 0; i < num_devices; i++) {
+        walk_display_properties(log, MSGL_WARN, devices[i], NULL);
+    }
+
+done:
+    talloc_free(devices);
+    vkDestroyInstance(inst, NULL);
+    return M_OPT_EXIT;
+}
+
+#define OPT_BASE_STRUCT struct vulkan_display_opts
+const struct m_sub_options vulkan_display_conf = {
+    .opts = (const struct m_option[]) {
+        {"vulkan-display-display", OPT_INT(display),
+            .help = print_display_info,
+        },
+        {"vulkan-display-mode", OPT_INT(mode),
+            .help = print_display_info,
+        },
+        {"vulkan-display-plane", OPT_INT(plane),
+            .help = print_display_info,
+        },
+        {0}
+    },
+    .size = sizeof(struct vulkan_display_opts),
+    .defaults = &(struct vulkan_display_opts) {
+        .display = 0,
+        .mode = 0,
+        .plane = 0,
+    },
+};
+
+struct priv {
+    struct mpvk_ctx vk;
+    struct vulkan_display_opts *opts;
+    uint32_t width;
+    uint32_t height;
+};
+
+static void display_uninit(struct ra_ctx *ctx)
+{
+    struct priv *p = ctx->priv;
+
+    ra_vk_ctx_uninit(ctx);
+    mpvk_uninit(&p->vk);
+}
+
+static bool display_init(struct ra_ctx *ctx)
+{
+    struct priv *p = ctx->priv = talloc_zero(ctx, struct priv);
+    struct mpvk_ctx *vk = &p->vk;
+    int msgl = ctx->opts.probing ? MSGL_V : MSGL_ERR;
+    VkResult res;
+    bool ret = false;
+
+    VkDisplayModePropertiesKHR *mode = NULL;
+
+    p->opts = mp_get_config_group(p, ctx->global, &vulkan_display_conf);
+    int display_idx = p->opts->display;
+    int mode_idx = p->opts->mode;
+    int plane_idx = p->opts->plane;
+
+    if (!mpvk_init(vk, ctx, VK_KHR_DISPLAY_EXTENSION_NAME))
+        goto error;
+
+    char *device_name = ra_vk_ctx_get_device_name(ctx);
+    struct pl_vulkan_device_params vulkan_params = {
+        .instance = vk->vkinst->instance,
+        .device_name = device_name,
+    };
+    VkPhysicalDevice device = pl_vulkan_choose_device(vk->ctx, &vulkan_params);
+    talloc_free(device_name);
+    if (!device) {
+        MP_MSG(ctx, msgl, "Failed to open physical device.\n");
+        goto error;
+    }
+
+    struct mode_selector selector = {
+        .display_idx = display_idx,
+        .mode_idx = mode_idx,
+        .plane_idx = plane_idx,
+
+    };
+    if (!walk_display_properties(ctx->log, msgl, device, &selector))
+        goto error;
+    mode = selector.out_mode_props;
+
+    VkDisplaySurfaceCreateInfoKHR xinfo = {
+        .sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
+        .displayMode = mode->displayMode,
+        .imageExtent = mode->parameters.visibleRegion,
+        .planeIndex = plane_idx,
+        .transform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
+        .alphaMode = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
+    };
+
+    res = vkCreateDisplayPlaneSurfaceKHR(vk->vkinst->instance, &xinfo, NULL,
+                                         &vk->surface);
+    if (res != VK_SUCCESS) {
+        MP_MSG(ctx, msgl, "Failed creating Display surface\n");
+        goto error;
+    }
+
+    p->width = mode->parameters.visibleRegion.width;
+    p->height = mode->parameters.visibleRegion.height;
+
+    struct ra_vk_ctx_params params = {0};
+    if (!ra_vk_ctx_init(ctx, vk, params, VK_PRESENT_MODE_FIFO_KHR))
+        goto error;
+
+    ret = true;
+
+done:
+    talloc_free(mode);
+    return ret;
+
+error:
+    display_uninit(ctx);
+    goto done;
+}
+
+static bool display_reconfig(struct ra_ctx *ctx)
+{
+    struct priv *p = ctx->priv;
+    return ra_vk_ctx_resize(ctx, p->width, p->height);
+}
+
+static int display_control(struct ra_ctx *ctx, int *events, int request, void *arg)
+{
+    return VO_NOTIMPL;
+}
+
+static void display_wakeup(struct ra_ctx *ctx)
+{
+    // TODO
+}
+
+static void display_wait_events(struct ra_ctx *ctx, int64_t until_time_us)
+{
+    // TODO
+}
+
+const struct ra_ctx_fns ra_ctx_vulkan_display = {
+    .type           = "vulkan",
+    .name           = "displayvk",
+    .reconfig       = display_reconfig,
+    .control        = display_control,
+    .wakeup         = display_wakeup,
+    .wait_events    = display_wait_events,
+    .init           = display_init,
+    .uninit         = display_uninit,
+};
diff --git a/video/out/vulkan/context_wayland.c b/video/out/vulkan/context_wayland.c
index 98bc8af..d2e6309 100644
--- a/video/out/vulkan/context_wayland.c
+++ b/video/out/vulkan/context_wayland.c
@@ -22,97 +22,15 @@
 #include "context.h"
 #include "utils.h"
 
-// Generated from presentation-time.xml
-#include "generated/wayland/presentation-time.h"
-
 struct priv {
     struct mpvk_ctx vk;
 };
 
-static const struct wp_presentation_feedback_listener feedback_listener;
-
-static void feedback_sync_output(void *data, struct wp_presentation_feedback *fback,
-                               struct wl_output *output)
-{
-}
-
-static void feedback_presented(void *data, struct wp_presentation_feedback *fback,
-                              uint32_t tv_sec_hi, uint32_t tv_sec_lo,
-                              uint32_t tv_nsec, uint32_t refresh_nsec,
-                              uint32_t seq_hi, uint32_t seq_lo,
-                              uint32_t flags)
-{
-    struct vo_wayland_state *wl = data;
-    vo_wayland_sync_shift(wl);
-
-    if (fback)
-        wp_presentation_feedback_destroy(fback);
-
-    // Very similar to oml_sync_control, in this case we assume that every
-    // time the compositor receives feedback, a buffer swap has been already
-    // been performed.
-    //
-    // Notes:
-    //  - tv_sec_lo + tv_sec_hi is the equivalent of oml's ust
-    //  - seq_lo + seq_hi is the equivalent of oml's msc
-    //  - these values are updated everytime the compositor receives feedback.
-
-    int index = last_available_sync(wl);
-    if (index < 0) {
-        queue_new_sync(wl);
-        index = 0;
-    }
-    int64_t sec = (uint64_t) tv_sec_lo + ((uint64_t) tv_sec_hi << 32);
-    wl->sync[index].ust = sec * 1000000LL + (uint64_t) tv_nsec / 1000;
-    wl->sync[index].msc = (uint64_t) seq_lo + ((uint64_t) seq_hi << 32);
-    wl->sync[index].filled = true;
-}
-
-static void feedback_discarded(void *data, struct wp_presentation_feedback *fback)
-{
-}
-
-static const struct wp_presentation_feedback_listener feedback_listener = {
-    feedback_sync_output,
-    feedback_presented,
-    feedback_discarded,
-};
-
-static const struct wl_callback_listener frame_listener;
-
-static void frame_callback(void *data, struct wl_callback *callback, uint32_t time)
-{
-    struct vo_wayland_state *wl = data;
-
-    if (callback)
-        wl_callback_destroy(callback);
-
-    wl->frame_callback = wl_surface_frame(wl->surface);
-    wl_callback_add_listener(wl->frame_callback, &frame_listener, wl);
-
-    if (wl->presentation) {
-        wl->feedback = wp_presentation_feedback(wl->presentation, wl->surface);
-        wp_presentation_feedback_add_listener(wl->feedback, &feedback_listener, wl);
-    }
-
-    wl->frame_wait = false;
-}
-
-static const struct wl_callback_listener frame_listener = {
-    frame_callback,
-};
-
 static bool wayland_vk_start_frame(struct ra_ctx *ctx)
 {
     struct vo_wayland_state *wl = ctx->vo->wl;
-
     bool render = !wl->hidden || wl->opts->disable_vsync;
-
-    if (wl->frame_wait && wl->presentation)
-        vo_wayland_sync_clear(wl);
-
-    if (render)
-        wl->frame_wait = true;
+    wl->frame_wait = true;
 
     return render;
 }
@@ -125,7 +43,7 @@ static void wayland_vk_swap_buffers(struct ra_ctx *ctx)
         vo_wayland_wait_frame(wl);
 
     if (wl->presentation)
-        wayland_sync_swap(wl);
+        vo_wayland_sync_swap(wl);
 }
 
 static void wayland_vk_get_vsync(struct ra_ctx *ctx, struct vo_vsync_info *info)
@@ -189,9 +107,6 @@ static bool wayland_vk_init(struct ra_ctx *ctx)
 
     ra_add_native_resource(ctx->ra, "wl", ctx->vo->wl->display);
 
-    ctx->vo->wl->frame_callback = wl_surface_frame(ctx->vo->wl->surface);
-    wl_callback_add_listener(ctx->vo->wl->frame_callback, &frame_listener, ctx->vo->wl);
-
     return true;
 
 error:
@@ -209,7 +124,6 @@ static bool resize(struct ra_ctx *ctx)
     const int32_t height = wl->scaling * mp_rect_h(wl->geometry);
 
     vo_wayland_set_opaque_region(wl, ctx->opts.want_alpha);
-    wl_surface_set_buffer_scale(wl->surface, wl->scaling);
     return ra_vk_ctx_resize(ctx, width, height);
 }
 
diff --git a/video/out/w32_common.c b/video/out/w32_common.c
index f977854..8633468 100644
--- a/video/out/w32_common.c
+++ b/video/out/w32_common.c
@@ -97,14 +97,17 @@ struct vo_w32_state {
     // Has the window seen a WM_DESTROY? If so, don't call DestroyWindow again.
     bool destroyed;
 
+    bool focused;
+
     // whether the window position and size were intialized
     bool window_bounds_initialized;
 
     bool current_fs;
     bool toggle_fs; // whether the current fullscreen state needs to be switched
 
-    RECT windowrc; // currently known window rect
-    RECT prev_windowrc; // last non-fullscreen window rect
+    // Note: maximized state doesn't involve nor modify windowrc
+    RECT windowrc; // currently known normal/fullscreen window client rect
+    RECT prev_windowrc; // saved normal window client rect while in fullscreen
 
     // video size
     uint32_t o_dwidth;
@@ -129,7 +132,13 @@ struct vo_w32_state {
     // UTF-16 decoding state for WM_CHAR and VK_PACKET
     int high_surrogate;
 
-    // Whether to fit the window on screen on next window state updating
+    // Fit the window to one monitor working area next time it's not fullscreen
+    // and not maximized. Used once after every new "untrusted" size comes from
+    // mpv, else we assume that the last known size is valid and don't fit.
+    // FIXME: on a multi-monitor setup one bit is not enough, because the first
+    // fit (autofit etc) should be to one monitor, but later size changes from
+    // mpv like window-scale (VOCTRL_SET_UNFS_WINDOW_SIZE) should allow the
+    // entire virtual desktop area - but we still limit to one monitor size.
     bool fit_on_screen;
 
     ITaskbarList2 *taskbar_list;
@@ -795,13 +804,12 @@ static void update_window_style(struct vo_w32_state *w32)
     w32->windowrc = wr;
 }
 
-// Adjust rc size and position if its size is larger than rc2.
+// If rc is wider/taller than n_w/n_h, shrink rc size while keeping the center.
 // returns true if the rectangle was modified.
-static bool fit_rect(RECT *rc, RECT *rc2)
+static bool fit_rect_size(RECT *rc, long n_w, long n_h)
 {
-    // Calculate old size and maximum new size
+    // nothing to do if we already fit.
     int o_w = rect_w(*rc), o_h = rect_h(*rc);
-    int n_w = rect_w(*rc2), n_h = rect_h(*rc2);
     if (o_w <= n_w && o_h <= n_h)
         return false;
 
@@ -821,17 +829,27 @@ static bool fit_rect(RECT *rc, RECT *rc2)
     return true;
 }
 
-// Adjust window size and position if its size is larger than the screen size.
+// If the window is bigger than the desktop, shrink to fit with same center.
+// Also, if the top edge is above the working area, move down to align.
 static void fit_window_on_screen(struct vo_w32_state *w32)
 {
-    if (w32->parent || w32->current_fs || IsMaximized(w32->window))
-        return;
-
     RECT screen = get_working_area(w32);
-    if (w32->opts->border && w32->opts->fit_border)
+    if (w32->opts->border)
         subtract_window_borders(w32, w32->window, &screen);
 
-    if (fit_rect(&w32->windowrc, &screen)) {
+    bool adjusted = fit_rect_size(&w32->windowrc, rect_w(screen), rect_h(screen));
+
+    if (w32->windowrc.top < screen.top) {
+        // if the top-edge of client area is above the target area (mainly
+        // because the client-area is centered but the title bar is taller
+        // than the bottom border), then move it down to align the edges.
+        // Windows itself applies the same constraint during manual move.
+        w32->windowrc.bottom += screen.top - w32->windowrc.top;
+        w32->windowrc.top = screen.top;
+        adjusted = true;
+    }
+
+    if (adjusted) {
         MP_VERBOSE(w32, "adjusted window bounds: %d:%d:%d:%d\n",
                    (int)w32->windowrc.left, (int)w32->windowrc.top,
                    (int)rect_w(w32->windowrc), (int)rect_h(w32->windowrc));
@@ -839,11 +857,10 @@ static void fit_window_on_screen(struct vo_w32_state *w32)
 }
 
 // Calculate new fullscreen state and change window size and position.
-// returns true if fullscreen state was changed.
-static bool update_fullscreen_state(struct vo_w32_state *w32)
+static void update_fullscreen_state(struct vo_w32_state *w32)
 {
     if (w32->parent)
-        return false;
+        return;
 
     bool new_fs = w32->opts->fullscreen;
     if (w32->toggle_fs) {
@@ -875,7 +892,6 @@ static bool update_fullscreen_state(struct vo_w32_state *w32)
     MP_VERBOSE(w32, "reset window bounds: %d:%d:%d:%d\n",
                (int)w32->windowrc.left, (int)w32->windowrc.top,
                (int)rect_w(w32->windowrc), (int)rect_h(w32->windowrc));
-    return toggle_fs;
 }
 
 static void update_minimized_state(struct vo_w32_state *w32)
@@ -969,15 +985,13 @@ static void reinit_window_state(struct vo_w32_state *w32)
         return;
 
     // The order matters: fs state should be updated prior to changing styles
-    bool toggle_fs = update_fullscreen_state(w32);
+    update_fullscreen_state(w32);
     update_window_style(w32);
 
-    // Assume that the window has already been fit on screen before switching fs
-    if (!toggle_fs || w32->fit_on_screen) {
+    // fit_on_screen is applied at most once when/if applicable (normal win).
+    if (w32->fit_on_screen && !w32->current_fs && !IsMaximized(w32->window)) {
         fit_window_on_screen(w32);
-        // The fullscreen state might still be active, so set the flag
-        // to fit on screen next time the window leaves the fullscreen.
-        w32->fit_on_screen = w32->current_fs;
+        w32->fit_on_screen = false;
     }
 
     // Show and activate the window after all window state parameters were set
@@ -1198,7 +1212,13 @@ static LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam,
         break;
     case WM_KILLFOCUS:
         mp_input_put_key(w32->input_ctx, MP_INPUT_RELEASE_ALL);
-        break;
+        w32->focused = false;
+        signal_events(w32, VO_EVENT_FOCUS);
+        return 0;
+    case WM_SETFOCUS:
+        w32->focused = true;
+        signal_events(w32, VO_EVENT_FOCUS);
+        return 0;
     case WM_SETCURSOR:
         // The cursor should only be hidden if the mouse is in the client area
         // and if the window isn't in menu mode (HIWORD(lParam) is non-zero)
@@ -1756,6 +1776,11 @@ static int gui_thread_control(struct vo_w32_state *w32, int request, void *arg)
         update_display_info(w32);
         *(double*) arg = w32->display_fps;
         return VO_TRUE;
+    case VOCTRL_GET_DISPLAY_RES: ;
+        RECT r = get_screen_area(w32);
+        ((int *)arg)[0] = r.right;
+        ((int *)arg)[1] = r.bottom;
+        return VO_TRUE;
     case VOCTRL_GET_DISPLAY_NAMES:
         *(char ***)arg = get_disp_names(w32);
         return VO_TRUE;
@@ -1768,6 +1793,9 @@ static int gui_thread_control(struct vo_w32_state *w32, int request, void *arg)
             return p->len ? VO_TRUE : VO_FALSE;
         }
         return VO_FALSE;
+    case VOCTRL_GET_FOCUSED:
+        *(bool *)arg = w32->focused;
+        return VO_TRUE;
     }
     return VO_NOTIMPL;
 }
diff --git a/video/out/wayland_common.c b/video/out/wayland_common.c
index 38b9ca0..4157782 100644
--- a/video/out/wayland_common.c
+++ b/video/out/wayland_common.c
@@ -17,30 +17,89 @@
 
 #include <errno.h>
 #include <limits.h>
-#include <poll.h>
-#include <unistd.h>
 #include <linux/input-event-codes.h>
+#include <poll.h>
 #include <time.h>
+#include <unistd.h>
+#include <wayland-cursor.h>
+#include <xkbcommon/xkbcommon.h>
+
 #include "common/msg.h"
-#include "options/m_config.h"
 #include "input/input.h"
 #include "input/keycodes.h"
+#include "options/m_config.h"
 #include "osdep/io.h"
 #include "osdep/timer.h"
-#include "win_state.h"
 #include "wayland_common.h"
+#include "win_state.h"
 
-// Generated from xdg-shell.xml
+// Generated from wayland-protocols
+#include "generated/wayland/idle-inhibit-unstable-v1.h"
+#include "generated/wayland/presentation-time.h"
+#include "generated/wayland/xdg-decoration-unstable-v1.h"
 #include "generated/wayland/xdg-shell.h"
 
-// Generated from idle-inhibit-unstable-v1.xml
-#include "generated/wayland/idle-inhibit-unstable-v1.h"
+static const struct mp_keymap keymap[] = {
+    /* Special keys */
+    {XKB_KEY_Pause,     MP_KEY_PAUSE}, {XKB_KEY_Escape, MP_KEY_ESC},
+    {XKB_KEY_BackSpace, MP_KEY_BS},    {XKB_KEY_Tab,    MP_KEY_TAB},
+    {XKB_KEY_Return,    MP_KEY_ENTER}, {XKB_KEY_Menu,   MP_KEY_MENU},
+    {XKB_KEY_Print,     MP_KEY_PRINT},
 
-// Generated from xdg-decoration-unstable-v1.xml
-#include "generated/wayland/xdg-decoration-unstable-v1.h"
+    /* Cursor keys */
+    {XKB_KEY_Left, MP_KEY_LEFT}, {XKB_KEY_Right, MP_KEY_RIGHT},
+    {XKB_KEY_Up,   MP_KEY_UP},   {XKB_KEY_Down,  MP_KEY_DOWN},
 
-// Generated from presentation-time.xml
-#include "generated/wayland/presentation-time.h"
+    /* Navigation keys */
+    {XKB_KEY_Insert,  MP_KEY_INSERT},  {XKB_KEY_Delete,    MP_KEY_DELETE},
+    {XKB_KEY_Home,    MP_KEY_HOME},    {XKB_KEY_End,       MP_KEY_END},
+    {XKB_KEY_Page_Up, MP_KEY_PAGE_UP}, {XKB_KEY_Page_Down, MP_KEY_PAGE_DOWN},
+
+    /* F-keys */
+    {XKB_KEY_F1,  MP_KEY_F + 1},  {XKB_KEY_F2,  MP_KEY_F + 2},
+    {XKB_KEY_F3,  MP_KEY_F + 3},  {XKB_KEY_F4,  MP_KEY_F + 4},
+    {XKB_KEY_F5,  MP_KEY_F + 5},  {XKB_KEY_F6,  MP_KEY_F + 6},
+    {XKB_KEY_F7,  MP_KEY_F + 7},  {XKB_KEY_F8,  MP_KEY_F + 8},
+    {XKB_KEY_F9,  MP_KEY_F + 9},  {XKB_KEY_F10, MP_KEY_F +10},
+    {XKB_KEY_F11, MP_KEY_F +11},  {XKB_KEY_F12, MP_KEY_F +12},
+
+    /* Numpad independent of numlock */
+    {XKB_KEY_KP_Subtract, '-'}, {XKB_KEY_KP_Add,    '+'},
+    {XKB_KEY_KP_Multiply, '*'}, {XKB_KEY_KP_Divide, '/'},
+    {XKB_KEY_KP_Enter, MP_KEY_KPENTER},
+
+    /* Numpad with numlock */
+    {XKB_KEY_KP_0, MP_KEY_KP0}, {XKB_KEY_KP_1, MP_KEY_KP1},
+    {XKB_KEY_KP_2, MP_KEY_KP2}, {XKB_KEY_KP_3, MP_KEY_KP3},
+    {XKB_KEY_KP_4, MP_KEY_KP4}, {XKB_KEY_KP_5, MP_KEY_KP5},
+    {XKB_KEY_KP_6, MP_KEY_KP6}, {XKB_KEY_KP_7, MP_KEY_KP7},
+    {XKB_KEY_KP_8, MP_KEY_KP8}, {XKB_KEY_KP_9, MP_KEY_KP9},
+    {XKB_KEY_KP_Decimal, MP_KEY_KPDEC}, {XKB_KEY_KP_Separator, MP_KEY_KPDEC},
+
+    /* Numpad without numlock */
+    {XKB_KEY_KP_Insert, MP_KEY_KPINS}, {XKB_KEY_KP_End,       MP_KEY_KP1},
+    {XKB_KEY_KP_Down,   MP_KEY_KP2},   {XKB_KEY_KP_Page_Down, MP_KEY_KP3},
+    {XKB_KEY_KP_Left,   MP_KEY_KP4},   {XKB_KEY_KP_Begin,     MP_KEY_KP5},
+    {XKB_KEY_KP_Right,  MP_KEY_KP6},   {XKB_KEY_KP_Home,      MP_KEY_KP7},
+    {XKB_KEY_KP_Up,     MP_KEY_KP8},   {XKB_KEY_KP_Page_Up,   MP_KEY_KP9},
+    {XKB_KEY_KP_Delete, MP_KEY_KPDEL},
+
+    /* Multimedia keys */
+    {XKB_KEY_XF86MenuKB, MP_KEY_MENU},
+    {XKB_KEY_XF86AudioPlay, MP_KEY_PLAY}, {XKB_KEY_XF86AudioPause, MP_KEY_PAUSE},
+    {XKB_KEY_XF86AudioStop, MP_KEY_STOP},
+    {XKB_KEY_XF86AudioPrev, MP_KEY_PREV}, {XKB_KEY_XF86AudioNext, MP_KEY_NEXT},
+    {XKB_KEY_XF86AudioRewind, MP_KEY_REWIND},
+    {XKB_KEY_XF86AudioForward, MP_KEY_FORWARD},
+    {XKB_KEY_XF86AudioMute, MP_KEY_MUTE},
+    {XKB_KEY_XF86AudioLowerVolume, MP_KEY_VOLUME_DOWN},
+    {XKB_KEY_XF86AudioRaiseVolume, MP_KEY_VOLUME_UP},
+    {XKB_KEY_XF86HomePage, MP_KEY_HOMEPAGE}, {XKB_KEY_XF86WWW, MP_KEY_WWW},
+    {XKB_KEY_XF86Mail, MP_KEY_MAIL}, {XKB_KEY_XF86Favorites, MP_KEY_FAVORITES},
+    {XKB_KEY_XF86Search, MP_KEY_SEARCH}, {XKB_KEY_XF86Sleep, MP_KEY_SLEEP},
+
+    {0, 0}
+};
 
 #define OPT_BASE_STRUCT struct wayland_opts
 const struct m_sub_options wayland_conf = {
@@ -60,97 +119,46 @@ const struct m_sub_options wayland_conf = {
     },
 };
 
-static void xdg_wm_base_ping(void *data, struct xdg_wm_base *wm_base, uint32_t serial)
-{
-    xdg_wm_base_pong(wm_base, serial);
-}
-
-static const struct xdg_wm_base_listener xdg_wm_base_listener = {
-    xdg_wm_base_ping,
+struct vo_wayland_output {
+    struct vo_wayland_state *wl;
+    struct wl_output *output;
+    struct mp_rect geometry;
+    bool has_surface;
+    uint32_t id;
+    uint32_t flags;
+    int phys_width;
+    int phys_height;
+    int scale;
+    double refresh_rate;
+    char *make;
+    char *model;
+    struct wl_list link;
 };
 
-static int spawn_cursor(struct vo_wayland_state *wl)
-{
-    if (wl->allocated_cursor_scale == wl->scaling) /* Reuse if size is identical */
-        return 0;
-    else if (wl->cursor_theme)
-        wl_cursor_theme_destroy(wl->cursor_theme);
-
-    const char *size_str = getenv("XCURSOR_SIZE");
-    int size = 32;
-    if (size_str != NULL) {
-        errno = 0;
-        char *end;
-        long size_long = strtol(size_str, &end, 10);
-        if (!*end && !errno && size_long > 0 && size_long <= INT_MAX)
-            size = (int)size_long;
-    }
-
-    wl->cursor_theme = wl_cursor_theme_load(NULL, size*wl->scaling, wl->shm);
-    if (!wl->cursor_theme) {
-        MP_ERR(wl, "Unable to load cursor theme!\n");
-        return 1;
-    }
-
-    wl->default_cursor = wl_cursor_theme_get_cursor(wl->cursor_theme, "left_ptr");
-    if (!wl->default_cursor) {
-        MP_ERR(wl, "Unable to load cursor theme!\n");
-        return 1;
-    }
-
-    wl->allocated_cursor_scale = wl->scaling;
-
-    return 0;
-}
-
-static int set_cursor_visibility(struct vo_wayland_state *wl, bool on)
-{
-    wl->cursor_visible = on;
-    if (on) {
-        if (spawn_cursor(wl))
-            return VO_FALSE;
-        struct wl_cursor_image *img = wl->default_cursor->images[0];
-        struct wl_buffer *buffer = wl_cursor_image_get_buffer(img);
-        if (!buffer)
-            return VO_FALSE;
-        wl_pointer_set_cursor(wl->pointer, wl->pointer_id, wl->cursor_surface,
-                              img->hotspot_x/wl->scaling, img->hotspot_y/wl->scaling);
-        wl_surface_set_buffer_scale(wl->cursor_surface, wl->scaling);
-        wl_surface_attach(wl->cursor_surface, buffer, 0, 0);
-        wl_surface_damage(wl->cursor_surface, 0, 0, img->width, img->height);
-        wl_surface_commit(wl->cursor_surface);
-    } else {
-        wl_pointer_set_cursor(wl->pointer, wl->pointer_id, NULL, 0, 0);
-    }
-    return VO_TRUE;
-}
-
-static int get_mods(struct vo_wayland_state *wl)
-{
-    static char* const mod_names[] = {
-        XKB_MOD_NAME_SHIFT,
-        XKB_MOD_NAME_CTRL,
-        XKB_MOD_NAME_ALT,
-        XKB_MOD_NAME_LOGO,
-    };
-
-    static const int mods[] = {
-        MP_KEY_MODIFIER_SHIFT,
-        MP_KEY_MODIFIER_CTRL,
-        MP_KEY_MODIFIER_ALT,
-        MP_KEY_MODIFIER_META,
-    };
-
-    for (int n = 0; n < MP_ARRAY_SIZE(mods); n++) {
-        xkb_mod_index_t index = xkb_keymap_mod_get_index(wl->xkb_keymap, mod_names[n]);
-        if (!xkb_state_mod_index_is_consumed(wl->xkb_state, wl->keyboard_code, index)
-            && xkb_state_mod_index_is_active(wl->xkb_state, index,
-                                             XKB_STATE_MODS_DEPRESSED))
-            return mods[n];
-    }
-    return 0;
-}
+struct vo_wayland_sync {
+    int64_t ust;
+    int64_t msc;
+    int64_t sbc;
+    bool filled;
+};
 
+static int check_for_resize(struct vo_wayland_state *wl, wl_fixed_t x_w, wl_fixed_t y_w,
+                            int edge_pixels, enum xdg_toplevel_resize_edge *edge);
+static int get_mods(struct vo_wayland_state *wl);
+static int last_available_sync(struct vo_wayland_state *wl);
+static int lookupkey(int key);
+static int set_cursor_visibility(struct vo_wayland_state *wl, bool on);
+static int spawn_cursor(struct vo_wayland_state *wl);
+
+static void greatest_common_divisor(struct vo_wayland_state *wl, int a, int b);
+static void queue_new_sync(struct vo_wayland_state *wl);
+static void remove_output(struct vo_wayland_output *out);
+static void set_geometry(struct vo_wayland_state *wl);
+static void set_surface_scaling(struct vo_wayland_state *wl);
+static void sync_shift(struct vo_wayland_state *wl);
+static void window_move(struct vo_wayland_state *wl, uint32_t serial);
+
+/* Wayland listener boilerplate */
 static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
                                  uint32_t serial, struct wl_surface *surface,
                                  wl_fixed_t sx, wl_fixed_t sy)
@@ -186,48 +194,6 @@ static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
     wl->toplevel_configured = false;
 }
 
-static void window_move(struct vo_wayland_state *wl, uint32_t serial)
-{
-    if (wl->xdg_toplevel)
-        xdg_toplevel_move(wl->xdg_toplevel, wl->seat, serial);
-}
-
-static int check_for_resize(struct vo_wayland_state *wl, wl_fixed_t x_w, wl_fixed_t y_w,
-                            int edge_pixels, enum xdg_toplevel_resize_edge *edge)
-{
-    if (wl->touch_entries || wl->vo_opts->fullscreen || wl->vo_opts->window_maximized)
-        return 0;
-
-    int pos[2] = { wl_fixed_to_double(x_w), wl_fixed_to_double(y_w) };
-    int left_edge   = pos[0] < edge_pixels;
-    int top_edge    = pos[1] < edge_pixels;
-    int right_edge  = pos[0] > (mp_rect_w(wl->geometry) - edge_pixels);
-    int bottom_edge = pos[1] > (mp_rect_h(wl->geometry) - edge_pixels);
-
-    if (left_edge) {
-        *edge = XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
-        if (top_edge)
-            *edge = XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
-        else if (bottom_edge)
-            *edge = XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
-    } else if (right_edge) {
-        *edge = XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
-        if (top_edge)
-            *edge = XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
-        else if (bottom_edge)
-            *edge = XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
-    } else if (top_edge) {
-        *edge = XDG_TOPLEVEL_RESIZE_EDGE_TOP;
-    } else if (bottom_edge) {
-        *edge = XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
-    } else {
-        *edge = 0;
-        return 0;
-    }
-
-    return 1;
-}
-
 static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
                                   uint32_t serial, uint32_t time, uint32_t button,
                                   uint32_t state)
@@ -266,6 +232,7 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
         mp_input_put_key(wl->vo->input_ctx, button | state | mpmod);
 
     if (!mp_input_test_dragging(wl->vo->input_ctx, wl->mouse_x, wl->mouse_y) &&
+        (!wl->vo_opts->fullscreen) && (!wl->vo_opts->window_maximized) &&
         (button == MP_MBTN_LEFT) && (state == MP_KEY_STATE_DOWN)) {
         uint32_t edges;
         // Implement an edge resize zone if there are no decorations
@@ -373,90 +340,28 @@ static const struct wl_touch_listener touch_listener = {
     touch_handle_cancel,
 };
 
-static const struct mp_keymap keymap[] = {
-    /* Special keys */
-    {XKB_KEY_Pause,     MP_KEY_PAUSE}, {XKB_KEY_Escape, MP_KEY_ESC},
-    {XKB_KEY_BackSpace, MP_KEY_BS},    {XKB_KEY_Tab,    MP_KEY_TAB},
-    {XKB_KEY_Return,    MP_KEY_ENTER}, {XKB_KEY_Menu,   MP_KEY_MENU},
-    {XKB_KEY_Print,     MP_KEY_PRINT},
-
-    /* Cursor keys */
-    {XKB_KEY_Left, MP_KEY_LEFT}, {XKB_KEY_Right, MP_KEY_RIGHT},
-    {XKB_KEY_Up,   MP_KEY_UP},   {XKB_KEY_Down,  MP_KEY_DOWN},
+static void keyboard_handle_keymap(void *data, struct wl_keyboard *wl_keyboard,
+                                   uint32_t format, int32_t fd, uint32_t size)
+{
+    struct vo_wayland_state *wl = data;
+    char *map_str;
 
-    /* Navigation keys */
-    {XKB_KEY_Insert,  MP_KEY_INSERT},  {XKB_KEY_Delete,    MP_KEY_DELETE},
-    {XKB_KEY_Home,    MP_KEY_HOME},    {XKB_KEY_End,       MP_KEY_END},
-    {XKB_KEY_Page_Up, MP_KEY_PAGE_UP}, {XKB_KEY_Page_Down, MP_KEY_PAGE_DOWN},
+    if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1) {
+        close(fd);
+        return;
+    }
 
-    /* F-keys */
-    {XKB_KEY_F1,  MP_KEY_F + 1},  {XKB_KEY_F2,  MP_KEY_F + 2},
-    {XKB_KEY_F3,  MP_KEY_F + 3},  {XKB_KEY_F4,  MP_KEY_F + 4},
-    {XKB_KEY_F5,  MP_KEY_F + 5},  {XKB_KEY_F6,  MP_KEY_F + 6},
-    {XKB_KEY_F7,  MP_KEY_F + 7},  {XKB_KEY_F8,  MP_KEY_F + 8},
-    {XKB_KEY_F9,  MP_KEY_F + 9},  {XKB_KEY_F10, MP_KEY_F +10},
-    {XKB_KEY_F11, MP_KEY_F +11},  {XKB_KEY_F12, MP_KEY_F +12},
+    map_str = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
+    if (map_str == MAP_FAILED) {
+        close(fd);
+        return;
+    }
 
-    /* Numpad independent of numlock */
-    {XKB_KEY_KP_Subtract, '-'}, {XKB_KEY_KP_Add,    '+'},
-    {XKB_KEY_KP_Multiply, '*'}, {XKB_KEY_KP_Divide, '/'},
-    {XKB_KEY_KP_Enter, MP_KEY_KPENTER},
+    wl->xkb_keymap = xkb_keymap_new_from_string(wl->xkb_context, map_str,
+                                                XKB_KEYMAP_FORMAT_TEXT_V1, 0);
 
-    /* Numpad with numlock */
-    {XKB_KEY_KP_0, MP_KEY_KP0}, {XKB_KEY_KP_1, MP_KEY_KP1},
-    {XKB_KEY_KP_2, MP_KEY_KP2}, {XKB_KEY_KP_3, MP_KEY_KP3},
-    {XKB_KEY_KP_4, MP_KEY_KP4}, {XKB_KEY_KP_5, MP_KEY_KP5},
-    {XKB_KEY_KP_6, MP_KEY_KP6}, {XKB_KEY_KP_7, MP_KEY_KP7},
-    {XKB_KEY_KP_8, MP_KEY_KP8}, {XKB_KEY_KP_9, MP_KEY_KP9},
-    {XKB_KEY_KP_Decimal, MP_KEY_KPDEC}, {XKB_KEY_KP_Separator, MP_KEY_KPDEC},
-
-    /* Numpad without numlock */
-    {XKB_KEY_KP_Insert, MP_KEY_KPINS}, {XKB_KEY_KP_End,       MP_KEY_KP1},
-    {XKB_KEY_KP_Down,   MP_KEY_KP2},   {XKB_KEY_KP_Page_Down, MP_KEY_KP3},
-    {XKB_KEY_KP_Left,   MP_KEY_KP4},   {XKB_KEY_KP_Begin,     MP_KEY_KP5},
-    {XKB_KEY_KP_Right,  MP_KEY_KP6},   {XKB_KEY_KP_Home,      MP_KEY_KP7},
-    {XKB_KEY_KP_Up,     MP_KEY_KP8},   {XKB_KEY_KP_Page_Up,   MP_KEY_KP9},
-    {XKB_KEY_KP_Delete, MP_KEY_KPDEL},
-
-    /* Multimedia keys */
-    {XKB_KEY_XF86MenuKB, MP_KEY_MENU},
-    {XKB_KEY_XF86AudioPlay, MP_KEY_PLAY}, {XKB_KEY_XF86AudioPause, MP_KEY_PAUSE},
-    {XKB_KEY_XF86AudioStop, MP_KEY_STOP},
-    {XKB_KEY_XF86AudioPrev, MP_KEY_PREV}, {XKB_KEY_XF86AudioNext, MP_KEY_NEXT},
-    {XKB_KEY_XF86AudioRewind, MP_KEY_REWIND},
-    {XKB_KEY_XF86AudioForward, MP_KEY_FORWARD},
-    {XKB_KEY_XF86AudioMute, MP_KEY_MUTE},
-    {XKB_KEY_XF86AudioLowerVolume, MP_KEY_VOLUME_DOWN},
-    {XKB_KEY_XF86AudioRaiseVolume, MP_KEY_VOLUME_UP},
-    {XKB_KEY_XF86HomePage, MP_KEY_HOMEPAGE}, {XKB_KEY_XF86WWW, MP_KEY_WWW},
-    {XKB_KEY_XF86Mail, MP_KEY_MAIL}, {XKB_KEY_XF86Favorites, MP_KEY_FAVORITES},
-    {XKB_KEY_XF86Search, MP_KEY_SEARCH}, {XKB_KEY_XF86Sleep, MP_KEY_SLEEP},
-
-    {0, 0}
-};
-
-static void keyboard_handle_keymap(void *data, struct wl_keyboard *wl_keyboard,
-                                   uint32_t format, int32_t fd, uint32_t size)
-{
-    struct vo_wayland_state *wl = data;
-    char *map_str;
-
-    if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1) {
-        close(fd);
-        return;
-    }
-
-    map_str = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
-    if (map_str == MAP_FAILED) {
-        close(fd);
-        return;
-    }
-
-    wl->xkb_keymap = xkb_keymap_new_from_string(wl->xkb_context, map_str,
-                                                XKB_KEYMAP_FORMAT_TEXT_V1, 0);
-
-    munmap(map_str, size);
-    close(fd);
+    munmap(map_str, size);
+    close(fd);
 
     if (!wl->xkb_keymap) {
         MP_ERR(wl, "failed to compile keymap\n");
@@ -487,34 +392,6 @@ static void keyboard_handle_leave(void *data, struct wl_keyboard *wl_keyboard,
     wl->has_keyboard_input = false;
 }
 
-static bool create_input(struct vo_wayland_state *wl)
-{
-    wl->xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
-
-    if (!wl->xkb_context) {
-        MP_ERR(wl, "failed to initialize input: check xkbcommon\n");
-        return 1;
-    }
-
-    return 0;
-}
-
-static int lookupkey(int key)
-{
-    const char *passthrough_keys = " -+*/<>`~!@#$%^&()_{}:;\"\',.?\\|=[]";
-
-    int mpkey = 0;
-    if ((key >= 'a' && key <= 'z') || (key >= 'A' && key <= 'Z') ||
-        (key >= '0' && key <= '9') ||
-        (key >  0   && key <  256 && strchr(passthrough_keys, key)))
-        mpkey = key;
-
-    if (!mpkey)
-        mpkey = lookup_keymap_table(keymap, key);
-
-    return mpkey;
-}
-
 static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
                                 uint32_t serial, uint32_t time, uint32_t key,
                                 uint32_t state)
@@ -601,73 +478,6 @@ static const struct wl_seat_listener seat_listener = {
     seat_handle_caps,
 };
 
-static void output_handle_geometry(void *data, struct wl_output *wl_output,
-                                   int32_t x, int32_t y, int32_t phys_width,
-                                   int32_t phys_height, int32_t subpixel,
-                                   const char *make, const char *model,
-                                   int32_t transform)
-{
-    struct vo_wayland_output *output = data;
-    output->make = talloc_strdup(output->wl, make);
-    output->model = talloc_strdup(output->wl, model);
-    output->geometry.x0 = x;
-    output->geometry.y0 = y;
-    output->phys_width = phys_width;
-    output->phys_height = phys_height;
-}
-
-static void output_handle_mode(void *data, struct wl_output *wl_output,
-                               uint32_t flags, int32_t width,
-                               int32_t height, int32_t refresh)
-{
-    struct vo_wayland_output *output = data;
-
-    /* Only save current mode */
-    if (!(flags & WL_OUTPUT_MODE_CURRENT))
-        return;
-
-    output->geometry.x1 = width;
-    output->geometry.y1 = height;
-    output->flags = flags;
-    output->refresh_rate = (double)refresh * 0.001;
-}
-
-static void output_handle_done(void* data, struct wl_output *wl_output)
-{
-    struct vo_wayland_output *o = data;
-
-    o->geometry.x1 += o->geometry.x0;
-    o->geometry.y1 += o->geometry.y0;
-
-    MP_VERBOSE(o->wl, "Registered output %s %s (0x%x):\n"
-               "\tx: %dpx, y: %dpx\n"
-               "\tw: %dpx (%dmm), h: %dpx (%dmm)\n"
-               "\tscale: %d\n"
-               "\tHz: %f\n", o->make, o->model, o->id, o->geometry.x0,
-               o->geometry.y0, mp_rect_w(o->geometry), o->phys_width,
-               mp_rect_h(o->geometry), o->phys_height, o->scale, o->refresh_rate);
-    
-    o->wl->pending_vo_events |= VO_EVENT_WIN_STATE;
-}
-
-static void output_handle_scale(void* data, struct wl_output *wl_output,
-                                int32_t factor)
-{
-    struct vo_wayland_output *output = data;
-    if (!factor) {
-        MP_ERR(output->wl, "Invalid output scale given by the compositor!\n");
-        return;
-    }
-    output->scale = factor;
-}
-
-static const struct wl_output_listener output_listener = {
-    output_handle_geometry,
-    output_handle_mode,
-    output_handle_done,
-    output_handle_scale,
-};
-
 static void data_offer_handle_offer(void *data, struct wl_data_offer *offer,
                                     const char *mime_type)
 {
@@ -683,7 +493,6 @@ static void data_offer_handle_offer(void *data, struct wl_data_offer *offer,
 
 static void data_offer_source_actions(void *data, struct wl_data_offer *offer, uint32_t source_actions)
 {
-
 }
 
 static void data_offer_action(void *data, struct wl_data_offer *wl_data_offer, uint32_t dnd_action)
@@ -792,10 +601,99 @@ static const struct wl_data_device_listener data_device_listener = {
     data_device_handle_selection,
 };
 
+static void output_handle_geometry(void *data, struct wl_output *wl_output,
+                                   int32_t x, int32_t y, int32_t phys_width,
+                                   int32_t phys_height, int32_t subpixel,
+                                   const char *make, const char *model,
+                                   int32_t transform)
+{
+    struct vo_wayland_output *output = data;
+    output->make = talloc_strdup(output->wl, make);
+    output->model = talloc_strdup(output->wl, model);
+    output->geometry.x0 = x;
+    output->geometry.y0 = y;
+    output->phys_width = phys_width;
+    output->phys_height = phys_height;
+}
+
+static void output_handle_mode(void *data, struct wl_output *wl_output,
+                               uint32_t flags, int32_t width,
+                               int32_t height, int32_t refresh)
+{
+    struct vo_wayland_output *output = data;
+
+    /* Only save current mode */
+    if (!(flags & WL_OUTPUT_MODE_CURRENT))
+        return;
+
+    output->geometry.x1 = width;
+    output->geometry.y1 = height;
+    output->flags = flags;
+    output->refresh_rate = (double)refresh * 0.001;
+}
+
+static void output_handle_done(void* data, struct wl_output *wl_output)
+{
+    struct vo_wayland_output *o = data;
+    struct vo_wayland_state *wl = o->wl;
+
+    o->geometry.x1 += o->geometry.x0;
+    o->geometry.y1 += o->geometry.y0;
+
+    MP_VERBOSE(o->wl, "Registered output %s %s (0x%x):\n"
+               "\tx: %dpx, y: %dpx\n"
+               "\tw: %dpx (%dmm), h: %dpx (%dmm)\n"
+               "\tscale: %d\n"
+               "\tHz: %f\n", o->make, o->model, o->id, o->geometry.x0,
+               o->geometry.y0, mp_rect_w(o->geometry), o->phys_width,
+               mp_rect_h(o->geometry), o->phys_height, o->scale, o->refresh_rate);
+
+    /* If we satisfy this conditional, something about the current
+     * output must have changed (resolution, scale, etc). All window
+     * geometry and scaling should be recalculated. */
+    if (wl->current_output && wl->current_output->output == wl_output) {
+        set_surface_scaling(wl);
+        if (!wl->vo_opts->fullscreen && !wl->vo_opts->window_maximized) {
+            wl_surface_set_buffer_scale(wl->surface, wl->scaling);
+        } else {
+            wl->scale_change = true;
+        }
+        spawn_cursor(wl);
+        set_geometry(wl);
+        wl->window_size = wl->vdparams;
+        if (!wl->vo_opts->fullscreen && !wl->vo_opts->window_maximized)
+            wl->geometry = wl->window_size;
+        wl->pending_vo_events |= VO_EVENT_DPI;
+        wl->pending_vo_events |= VO_EVENT_RESIZE;
+    }
+
+    wl->pending_vo_events |= VO_EVENT_WIN_STATE;
+}
+
+static void output_handle_scale(void* data, struct wl_output *wl_output,
+                                int32_t factor)
+{
+    struct vo_wayland_output *output = data;
+    if (!factor) {
+        MP_ERR(output->wl, "Invalid output scale given by the compositor!\n");
+        return;
+    }
+    output->scale = factor;
+}
+
+static const struct wl_output_listener output_listener = {
+    output_handle_geometry,
+    output_handle_mode,
+    output_handle_done,
+    output_handle_scale,
+};
+
 static void surface_handle_enter(void *data, struct wl_surface *wl_surface,
                                  struct wl_output *output)
 {
     struct vo_wayland_state *wl = data;
+    struct mp_rect old_output_geometry = wl->current_output->geometry;
+    struct mp_rect old_geometry = wl->geometry;
     wl->current_output = NULL;
 
     struct vo_wayland_output *o;
@@ -807,9 +705,30 @@ static void surface_handle_enter(void *data, struct wl_surface *wl_surface,
     }
 
     wl->current_output->has_surface = true;
-    if (wl->scaling != wl->current_output->scale)
+    bool force_resize = false;
+
+    if (wl->scaling != wl->current_output->scale) {
+        set_surface_scaling(wl);
+        if (!wl->vo_opts->fullscreen && !wl->vo_opts->window_maximized) {
+            wl->scale_change = true;
+        } else {
+            wl_surface_set_buffer_scale(wl->surface, wl->scaling);
+        }
+        spawn_cursor(wl);
+        wl->pending_vo_events |= VO_EVENT_DPI;
+    }
+
+    if (!mp_rect_equals(&old_output_geometry, &wl->current_output->geometry)) {
+        set_geometry(wl);
+        wl->window_size = wl->vdparams;
+        force_resize = true;
+    }
+
+    if (!wl->vo_opts->fullscreen && !wl->vo_opts->window_maximized)
+        wl->geometry = wl->window_size;
+
+    if (!mp_rect_equals(&old_geometry, &wl->geometry) || force_resize)
         wl->pending_vo_events |= VO_EVENT_RESIZE;
-    wl->scaling = wl->current_output->scale;
 
     MP_VERBOSE(wl, "Surface entered output %s %s (0x%x), scale = %i\n", o->make,
                o->model, o->id, wl->scaling);
@@ -837,120 +756,24 @@ static const struct wl_surface_listener surface_listener = {
     surface_handle_leave,
 };
 
-static void pres_set_clockid(void *data, struct wp_presentation *pres,
-                           uint32_t clockid)
+static void xdg_wm_base_ping(void *data, struct xdg_wm_base *wm_base, uint32_t serial)
 {
-    struct vo_wayland_state *wl = data;
-    
-    if (clockid == CLOCK_MONOTONIC)
-        wl->presentation = pres;
+    xdg_wm_base_pong(wm_base, serial);
 }
 
-static const struct wp_presentation_listener pres_listener = {
-    pres_set_clockid,
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+    xdg_wm_base_ping,
 };
 
-static void registry_handle_add(void *data, struct wl_registry *reg, uint32_t id,
-                                const char *interface, uint32_t ver)
+static void handle_surface_config(void *data, struct xdg_surface *surface,
+                                  uint32_t serial)
 {
-    int found = 1;
-    struct vo_wayland_state *wl = data;
+    xdg_surface_ack_configure(surface, serial);
+}
 
-    if (!strcmp(interface, wl_compositor_interface.name) && (ver >= 3) && found++) {
-        wl->compositor = wl_registry_bind(reg, id, &wl_compositor_interface, 3);
-        wl->surface = wl_compositor_create_surface(wl->compositor);
-        wl->cursor_surface = wl_compositor_create_surface(wl->compositor);
-        wl_surface_add_listener(wl->surface, &surface_listener, wl);
-    }
-
-    if (!strcmp(interface, wl_output_interface.name) && (ver >= 2) && found++) {
-        struct vo_wayland_output *output = talloc_zero(wl, struct vo_wayland_output);
-
-        output->wl     = wl;
-        output->id     = id;
-        output->scale  = 1;
-        output->output = wl_registry_bind(reg, id, &wl_output_interface, 2);
-
-        wl_output_add_listener(output->output, &output_listener, output);
-        wl_list_insert(&wl->output_list, &output->link);
-    }
-
-    if (!strcmp(interface, xdg_wm_base_interface.name) && found++) {
-        ver = MPMIN(ver, 2); /* We can use either 1 or 2 */
-        wl->wm_base = wl_registry_bind(reg, id, &xdg_wm_base_interface, ver);
-        xdg_wm_base_add_listener(wl->wm_base, &xdg_wm_base_listener, wl);
-    }
-
-    if (!strcmp(interface, wl_seat_interface.name) && found++) {
-        wl->seat = wl_registry_bind(reg, id, &wl_seat_interface, 1);
-        wl_seat_add_listener(wl->seat, &seat_listener, wl);
-    }
-
-    if (!strcmp(interface, wl_shm_interface.name) && found++) {
-        wl->shm = wl_registry_bind(reg, id, &wl_shm_interface, 1);
-    }
-
-    if (!strcmp(interface, wl_data_device_manager_interface.name) && (ver >= 3) && found++) {
-        wl->dnd_devman = wl_registry_bind(reg, id, &wl_data_device_manager_interface, 3);
-    }
-
-    if (!strcmp(interface, zxdg_decoration_manager_v1_interface.name) && found++) {
-        wl->xdg_decoration_manager = wl_registry_bind(reg, id, &zxdg_decoration_manager_v1_interface, 1);
-    }
-
-    if (!strcmp(interface, wp_presentation_interface.name) && found++) {
-        wl->presentation = wl_registry_bind(reg, id, &wp_presentation_interface, 1);
-        wp_presentation_add_listener(wl->presentation, &pres_listener, wl);
-    }
-
-    if (!strcmp(interface, zwp_idle_inhibit_manager_v1_interface.name) && found++) {
-        wl->idle_inhibit_manager = wl_registry_bind(reg, id, &zwp_idle_inhibit_manager_v1_interface, 1);
-    }
-
-    if (found > 1)
-        MP_VERBOSE(wl, "Registered for protocol %s\n", interface);
-}
-
-static void remove_output(struct vo_wayland_output *out)
-{
-    if (!out)
-        return;
-
-    MP_VERBOSE(out->wl, "Deregistering output %s %s (0x%x)\n", out->make,
-               out->model, out->id);
-    wl_list_remove(&out->link);
-    talloc_free(out->make);
-    talloc_free(out->model);
-    talloc_free(out);
-    return;
-}
-
-static void registry_handle_remove(void *data, struct wl_registry *reg, uint32_t id)
-{
-    struct vo_wayland_state *wl = data;
-    struct vo_wayland_output *output, *tmp;
-    wl_list_for_each_safe(output, tmp, &wl->output_list, link) {
-        if (output->id == id) {
-            remove_output(output);
-            return;
-        }
-    }
-}
-
-static const struct wl_registry_listener registry_listener = {
-    registry_handle_add,
-    registry_handle_remove,
-};
-
-static void handle_surface_config(void *data, struct xdg_surface *surface,
-                                  uint32_t serial)
-{
-    xdg_surface_ack_configure(surface, serial);
-}
-
-static const struct xdg_surface_listener xdg_surface_listener = {
-    handle_surface_config,
-};
+static const struct xdg_surface_listener xdg_surface_listener = {
+    handle_surface_config,
+};
 
 static void handle_toplevel_config(void *data, struct xdg_toplevel *toplevel,
                                    int32_t width, int32_t height, struct wl_array *states)
@@ -959,6 +782,10 @@ static void handle_toplevel_config(void *data, struct xdg_toplevel *toplevel,
     struct mp_vo_opts *vo_opts = wl->vo_opts;
     struct mp_rect old_geometry = wl->geometry;
 
+    /* Don't do anything here if we haven't finished setting geometry. */
+    if (mp_rect_w(wl->geometry) == 0 || mp_rect_h(wl->geometry) == 0)
+        return;
+
     bool is_maximized = false;
     bool is_fullscreen = false;
     bool is_activated = false;
@@ -1014,6 +841,7 @@ static void handle_toplevel_config(void *data, struct xdg_toplevel *toplevel,
 
             if (wl->activated) {
                 /* If the surface comes back into view, force a redraw. */
+                vo_wayland_wait_frame(wl);
                 wl->pending_vo_events |= VO_EVENT_EXPOSE;
             }
         }
@@ -1027,6 +855,11 @@ static void handle_toplevel_config(void *data, struct xdg_toplevel *toplevel,
     wl->toplevel_width = width;
     wl->toplevel_height = height;
 
+    if (wl->scale_change) {
+        wl_surface_set_buffer_scale(wl->surface, wl->scaling);
+        wl->scale_change = false;
+    }
+
     if (wl->state_change) {
         if (!is_fullscreen && !is_maximized) {
             wl->geometry = wl->window_size;
@@ -1081,301 +914,323 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener = {
     handle_toplevel_close,
 };
 
-static int create_xdg_surface(struct vo_wayland_state *wl)
+static void pres_set_clockid(void *data, struct wp_presentation *pres,
+                           uint32_t clockid)
 {
-    wl->xdg_surface = xdg_wm_base_get_xdg_surface(wl->wm_base, wl->surface);
-    xdg_surface_add_listener(wl->xdg_surface, &xdg_surface_listener, wl);
-
-    wl->xdg_toplevel = xdg_surface_get_toplevel(wl->xdg_surface);
-    xdg_toplevel_add_listener(wl->xdg_toplevel, &xdg_toplevel_listener, wl);
+    struct vo_wayland_state *wl = data;
 
-    if (!wl->xdg_surface || !wl->xdg_toplevel)
-        return 1;
-    return 0;
+    if (clockid == CLOCK_MONOTONIC)
+        wl->presentation = pres;
 }
 
-static void update_app_id(struct vo_wayland_state *wl)
+static const struct wp_presentation_listener pres_listener = {
+    pres_set_clockid,
+};
+
+static void feedback_sync_output(void *data, struct wp_presentation_feedback *fback,
+                               struct wl_output *output)
 {
-    if (!wl->xdg_toplevel)
-        return;
-    if (!wl->vo_opts->appid) {
-        wl->vo_opts->appid = talloc_strdup(wl->vo_opts, "mpv");
-        m_config_cache_write_opt(wl->vo_opts_cache, &wl->vo_opts->appid);
-    }
-    xdg_toplevel_set_app_id(wl->xdg_toplevel, wl->vo_opts->appid);
 }
 
-static void set_border_decorations(struct vo_wayland_state *wl, int state)
+static void feedback_presented(void *data, struct wp_presentation_feedback *fback,
+                              uint32_t tv_sec_hi, uint32_t tv_sec_lo,
+                              uint32_t tv_nsec, uint32_t refresh_nsec,
+                              uint32_t seq_hi, uint32_t seq_lo,
+                              uint32_t flags)
 {
-    if (!wl->xdg_toplevel_decoration) {
-        wl->vo_opts->border = false;
-        m_config_cache_write_opt(wl->vo_opts_cache,
-                                 &wl->vo_opts->border);
-        return;
-    }
+    struct vo_wayland_state *wl = data;
+    sync_shift(wl);
 
-    enum zxdg_toplevel_decoration_v1_mode mode;
-    if (state) {
-        MP_VERBOSE(wl, "Enabling server decorations\n");
-        mode = ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE;
-    } else {
-        MP_VERBOSE(wl, "Disabling server decorations\n");
-        mode = ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE;
+    if (fback)
+        wp_presentation_feedback_destroy(fback);
+
+    wl->refresh_interval = (int64_t)refresh_nsec / 1000;
+
+    // Very similar to oml_sync_control, in this case we assume that every
+    // time the compositor receives feedback, a buffer swap has been already
+    // been performed.
+    //
+    // Notes:
+    //  - tv_sec_lo + tv_sec_hi is the equivalent of oml's ust
+    //  - seq_lo + seq_hi is the equivalent of oml's msc
+    //  - these values are updated everytime the compositor receives feedback.
+
+    int index = last_available_sync(wl);
+    if (index < 0) {
+        queue_new_sync(wl);
+        index = 0;
     }
-    zxdg_toplevel_decoration_v1_set_mode(wl->xdg_toplevel_decoration, mode);
+    int64_t sec = (uint64_t) tv_sec_lo + ((uint64_t) tv_sec_hi << 32);
+    wl->sync[index].ust = sec * 1000000LL + (uint64_t) tv_nsec / 1000;
+    wl->sync[index].msc = (uint64_t) seq_lo + ((uint64_t) seq_hi << 32);
+    wl->sync[index].filled = true;
 }
 
-int vo_wayland_init(struct vo *vo)
+static void feedback_discarded(void *data, struct wp_presentation_feedback *fback)
 {
-    vo->wl = talloc_zero(NULL, struct vo_wayland_state);
-    struct vo_wayland_state *wl = vo->wl;
+}
 
-    *wl = (struct vo_wayland_state) {
-        .display = wl_display_connect(NULL),
-        .vo = vo,
-        .log = mp_log_new(wl, vo->log, "wayland"),
-        .scaling = 1,
-        .wakeup_pipe = {-1, -1},
-        .dnd_fd = -1,
-        .cursor_visible = true,
-        .vo_opts_cache = m_config_cache_alloc(wl, vo->global, &vo_sub_opts),
-    };
-    wl->vo_opts = wl->vo_opts_cache->opts;
+static const struct wp_presentation_feedback_listener feedback_listener = {
+    feedback_sync_output,
+    feedback_presented,
+    feedback_discarded,
+};
 
-    wl_list_init(&wl->output_list);
+static const struct wl_callback_listener frame_listener;
 
-    if (!wl->display)
-        return false;
+static void frame_callback(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct vo_wayland_state *wl = data;
 
-    if (create_input(wl))
-        return false;
+    if (callback)
+        wl_callback_destroy(callback);
 
-    wl->registry = wl_display_get_registry(wl->display);
-    wl_registry_add_listener(wl->registry, &registry_listener, wl);
+    wl->frame_callback = wl_surface_frame(wl->surface);
+    wl_callback_add_listener(wl->frame_callback, &frame_listener, wl);
 
-    /* Do a roundtrip to run the registry */
-    wl_display_roundtrip(wl->display);
+    if (wl->presentation) {
+        wl->feedback = wp_presentation_feedback(wl->presentation, wl->surface);
+        wp_presentation_feedback_add_listener(wl->feedback, &feedback_listener, wl);
+    }
 
-    if (!wl->wm_base) {
-        MP_FATAL(wl, "Compositor doesn't support the required %s protocol!\n",
-                 xdg_wm_base_interface.name);
-        return false;
+    wl->frame_wait = false;
+}
+
+static const struct wl_callback_listener frame_listener = {
+    frame_callback,
+};
+
+static void registry_handle_add(void *data, struct wl_registry *reg, uint32_t id,
+                                const char *interface, uint32_t ver)
+{
+    int found = 1;
+    struct vo_wayland_state *wl = data;
+
+    if (!strcmp(interface, wl_compositor_interface.name) && (ver >= 3) && found++) {
+        wl->compositor = wl_registry_bind(reg, id, &wl_compositor_interface, 3);
+        wl->surface = wl_compositor_create_surface(wl->compositor);
+        wl->cursor_surface = wl_compositor_create_surface(wl->compositor);
+        wl_surface_add_listener(wl->surface, &surface_listener, wl);
     }
 
-    if (!wl_list_length(&wl->output_list)) {
-        MP_FATAL(wl, "No outputs found or compositor doesn't support %s (ver. 2)\n",
-                 wl_output_interface.name);
-        return false;
+    if (!strcmp(interface, wl_data_device_manager_interface.name) && (ver >= 3) && found++) {
+        wl->dnd_devman = wl_registry_bind(reg, id, &wl_data_device_manager_interface, 3);
     }
 
-    /* Can't be initialized during registry due to multi-protocol dependence */
-    if (create_xdg_surface(wl))
-        return false;
-    update_app_id(wl);
+    if (!strcmp(interface, wl_output_interface.name) && (ver >= 2) && found++) {
+        struct vo_wayland_output *output = talloc_zero(wl, struct vo_wayland_output);
 
-    const char *xdg_current_desktop = getenv("XDG_CURRENT_DESKTOP");
-    if (xdg_current_desktop != NULL && strstr(xdg_current_desktop, "GNOME"))
-        MP_WARN(wl, "GNOME's wayland compositor lacks support for the idle inhibit protocol. This means the screen can blank during playback.\n");
+        output->wl     = wl;
+        output->id     = id;
+        output->scale  = 1;
+        output->output = wl_registry_bind(reg, id, &wl_output_interface, 2);
 
-    if (wl->dnd_devman && wl->seat) {
-        wl->dnd_ddev = wl_data_device_manager_get_data_device(wl->dnd_devman, wl->seat);
-        wl_data_device_add_listener(wl->dnd_ddev, &data_device_listener, wl);
-    } else if (!wl->dnd_devman) {
-        MP_VERBOSE(wl, "Compositor doesn't support the %s (ver. 3) protocol!\n",
-                   wl_data_device_manager_interface.name);
+        wl_output_add_listener(output->output, &output_listener, output);
+        wl_list_insert(&wl->output_list, &output->link);
     }
 
-    if (wl->presentation) {
-        wl->sync = talloc_zero_array(wl, struct vo_wayland_sync, 1);
-        struct vo_wayland_sync sync = {0, 0, 0, 0};
-        wl->sync[0] = sync;
-        wl->sync_size += 1;
-    } else {
-        MP_VERBOSE(wl, "Compositor doesn't support the %s protocol!\n",
-                   wp_presentation_interface.name);
+    if (!strcmp(interface, wl_seat_interface.name) && found++) {
+        wl->seat = wl_registry_bind(reg, id, &wl_seat_interface, 1);
+        wl_seat_add_listener(wl->seat, &seat_listener, wl);
     }
 
-    if (wl->xdg_decoration_manager) {
-        wl->xdg_toplevel_decoration = zxdg_decoration_manager_v1_get_toplevel_decoration(wl->xdg_decoration_manager, wl->xdg_toplevel);
-        set_border_decorations(wl, wl->vo_opts->border);
-    } else {
-        wl->vo_opts->border = false;
-        m_config_cache_write_opt(wl->vo_opts_cache,
-                                 &wl->vo_opts->border);
-        MP_VERBOSE(wl, "Compositor doesn't support the %s protocol!\n",
-                   zxdg_decoration_manager_v1_interface.name);
+    if (!strcmp(interface, wl_shm_interface.name) && found++) {
+        wl->shm = wl_registry_bind(reg, id, &wl_shm_interface, 1);
     }
 
-    if (!wl->idle_inhibit_manager)
-        MP_VERBOSE(wl, "Compositor doesn't support the %s protocol!\n",
-                   zwp_idle_inhibit_manager_v1_interface.name);
+    if (!strcmp(interface, wp_presentation_interface.name) && found++) {
+        wl->presentation = wl_registry_bind(reg, id, &wp_presentation_interface, 1);
+        wp_presentation_add_listener(wl->presentation, &pres_listener, wl);
+    }
 
-    wl->opts = mp_get_config_group(wl, wl->vo->global, &wayland_conf);
-    wl->display_fd = wl_display_get_fd(wl->display);
-    mp_make_wakeup_pipe(wl->wakeup_pipe);
+    if (!strcmp(interface, xdg_wm_base_interface.name) && found++) {
+        ver = MPMIN(ver, 2); /* We can use either 1 or 2 */
+        wl->wm_base = wl_registry_bind(reg, id, &xdg_wm_base_interface, ver);
+        xdg_wm_base_add_listener(wl->wm_base, &xdg_wm_base_listener, wl);
+    }
 
-    return true;
-}
+    if (!strcmp(interface, zxdg_decoration_manager_v1_interface.name) && found++) {
+        wl->xdg_decoration_manager = wl_registry_bind(reg, id, &zxdg_decoration_manager_v1_interface, 1);
+    }
 
-void vo_wayland_uninit(struct vo *vo)
-{
-    struct vo_wayland_state *wl = vo->wl;
-    if (!wl)
-        return;
-
-    mp_input_put_key(wl->vo->input_ctx, MP_INPUT_RELEASE_ALL);
-
-    if (wl->current_output && wl->current_output->output)
-        wl_output_destroy(wl->current_output->output);
-
-    if (wl->cursor_theme)
-        wl_cursor_theme_destroy(wl->cursor_theme);
-
-    if (wl->cursor_surface)
-        wl_surface_destroy(wl->cursor_surface);
-
-    if (wl->xkb_context)
-        xkb_context_unref(wl->xkb_context);
-
-    if (wl->xkb_state)
-        xkb_state_unref(wl->xkb_state);
-
-    if (wl->xkb_keymap)
-        xkb_keymap_unref(wl->xkb_keymap);
-
-    if (wl->idle_inhibitor)
-        zwp_idle_inhibitor_v1_destroy(wl->idle_inhibitor);
-
-    if (wl->idle_inhibit_manager)
-        zwp_idle_inhibit_manager_v1_destroy(wl->idle_inhibit_manager);
-
-    if (wl->wm_base)
-        xdg_wm_base_destroy(wl->wm_base);
-
-    if (wl->shm)
-        wl_shm_destroy(wl->shm);
-
-    if (wl->dnd_ddev)
-        wl_data_device_destroy(wl->dnd_ddev);
+    if (!strcmp(interface, zwp_idle_inhibit_manager_v1_interface.name) && found++) {
+        wl->idle_inhibit_manager = wl_registry_bind(reg, id, &zwp_idle_inhibit_manager_v1_interface, 1);
+    }
 
-    if (wl->dnd_devman)
-        wl_data_device_manager_destroy(wl->dnd_devman);
+    if (found > 1)
+        MP_VERBOSE(wl, "Registered for protocol %s\n", interface);
+}
 
-    if (wl->dnd_offer)
-        wl_data_offer_destroy(wl->dnd_offer);
+static void registry_handle_remove(void *data, struct wl_registry *reg, uint32_t id)
+{
+    struct vo_wayland_state *wl = data;
+    struct vo_wayland_output *output, *tmp;
+    wl_list_for_each_safe(output, tmp, &wl->output_list, link) {
+        if (output->id == id) {
+            remove_output(output);
+            return;
+        }
+    }
+}
 
-    if (wl->xdg_toplevel_decoration)
-        zxdg_toplevel_decoration_v1_destroy(wl->xdg_toplevel_decoration);
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_add,
+    registry_handle_remove,
+};
 
-    if (wl->xdg_decoration_manager)
-        zxdg_decoration_manager_v1_destroy(wl->xdg_decoration_manager);
+/* Static functions */
+static void check_dnd_fd(struct vo_wayland_state *wl)
+{
+    if (wl->dnd_fd == -1)
+        return;
 
-    if (wl->xdg_toplevel)
-        xdg_toplevel_destroy(wl->xdg_toplevel);
+    struct pollfd fdp = { wl->dnd_fd, POLLIN | POLLERR | POLLHUP, 0 };
+    if (poll(&fdp, 1, 0) <= 0)
+        return;
 
-    if (wl->xdg_surface)
-        xdg_surface_destroy(wl->xdg_surface);
+    if (fdp.revents & POLLIN) {
+        ptrdiff_t offset = 0;
+        size_t data_read = 0;
+        const size_t chunk_size = 1;
+        uint8_t *buffer = ta_zalloc_size(wl, chunk_size);
+        if (!buffer)
+            goto end;
 
-    if (wl->compositor)
-        wl_compositor_destroy(wl->compositor);
+        while ((data_read = read(wl->dnd_fd, buffer + offset, chunk_size)) > 0) {
+            offset += data_read;
+            buffer = ta_realloc_size(wl, buffer, offset + chunk_size);
+            memset(buffer + offset, 0, chunk_size);
+            if (!buffer)
+                goto end;
+        }
 
-    if (wl->surface)
-        wl_surface_destroy(wl->surface);
+        MP_VERBOSE(wl, "Read %td bytes from the DND fd\n", offset);
 
-    if (wl->frame_callback)
-        wl_callback_destroy(wl->frame_callback);
+        struct bstr file_list = bstr0(buffer);
+        mp_event_drop_mime_data(wl->vo->input_ctx, wl->dnd_mime_type,
+                                file_list, wl->dnd_action);
+        talloc_free(buffer);
+end:
+        talloc_free(wl->dnd_mime_type);
+        wl->dnd_mime_type = NULL;
+        wl->dnd_mime_score = 0;
+    }
 
-    if (wl->presentation)
-        wp_presentation_destroy(wl->presentation);
+    if (fdp.revents & (POLLIN | POLLERR | POLLHUP)) {
+        close(wl->dnd_fd);
+        wl->dnd_fd = -1;
+    }
+}
 
-    if (wl->feedback)
-        wp_presentation_feedback_destroy(wl->feedback);
+static int check_for_resize(struct vo_wayland_state *wl, wl_fixed_t x_w, wl_fixed_t y_w,
+                            int edge_pixels, enum xdg_toplevel_resize_edge *edge)
+{
+    if (wl->touch_entries || wl->vo_opts->fullscreen || wl->vo_opts->window_maximized)
+        return 0;
 
-    if (wl->pointer)
-        wl_pointer_destroy(wl->pointer);
+    int pos[2] = { wl_fixed_to_double(x_w), wl_fixed_to_double(y_w) };
+    int left_edge   = pos[0] < edge_pixels;
+    int top_edge    = pos[1] < edge_pixels;
+    int right_edge  = pos[0] > (mp_rect_w(wl->geometry) - edge_pixels);
+    int bottom_edge = pos[1] > (mp_rect_h(wl->geometry) - edge_pixels);
 
-    if (wl->keyboard)
-        wl_keyboard_destroy(wl->keyboard);
+    if (left_edge) {
+        *edge = XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
+        if (top_edge)
+            *edge = XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
+        else if (bottom_edge)
+            *edge = XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
+    } else if (right_edge) {
+        *edge = XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
+        if (top_edge)
+            *edge = XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
+        else if (bottom_edge)
+            *edge = XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
+    } else if (top_edge) {
+        *edge = XDG_TOPLEVEL_RESIZE_EDGE_TOP;
+    } else if (bottom_edge) {
+        *edge = XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
+    } else {
+        *edge = 0;
+        return 0;
+    }
 
-    if (wl->seat)
-        wl_seat_destroy(wl->seat);
+    return 1;
+}
 
-    if (wl->registry)
-        wl_registry_destroy(wl->registry);
+static bool create_input(struct vo_wayland_state *wl)
+{
+    wl->xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
 
-    if (wl->display) {
-        close(wl_display_get_fd(wl->display));
-        wl_display_disconnect(wl->display);
+    if (!wl->xkb_context) {
+        MP_ERR(wl, "failed to initialize input: check xkbcommon\n");
+        return 1;
     }
 
-    struct vo_wayland_output *output, *tmp;
-    wl_list_for_each_safe(output, tmp, &wl->output_list, link)
-        remove_output(output);
-
-    talloc_free(wl->dnd_mime_type);
-
-    for (int n = 0; n < 2; n++)
-        close(wl->wakeup_pipe[n]);
-    talloc_free(wl);
-    vo->wl = NULL;
+    return 0;
 }
 
-static bool find_output(struct vo_wayland_state *wl, int index)
+static int create_xdg_surface(struct vo_wayland_state *wl)
 {
-    int screen_id = 0;
-    struct vo_wayland_output *output = NULL;
-    struct vo_wayland_output *fallback_output = NULL;
-    wl_list_for_each(output, &wl->output_list, link) {
-        if (screen_id == 0)
-            fallback_output = output;
-        if (index == screen_id++)
-            wl->current_output = output;
-    }
-    if (!wl->current_output) {
-        if (!fallback_output) {
-            MP_ERR(wl, "Screen index %i not found/unavailable!\n", index);
-            return 1;
-        } else {
-            MP_WARN(wl, "Screen index %i not found/unavailable! Falling back to screen 0!\n", index);
-            wl->current_output = fallback_output;
-        }
-    }
+    wl->xdg_surface = xdg_wm_base_get_xdg_surface(wl->wm_base, wl->surface);
+    xdg_surface_add_listener(wl->xdg_surface, &xdg_surface_listener, wl);
+
+    wl->xdg_toplevel = xdg_surface_get_toplevel(wl->xdg_surface);
+    xdg_toplevel_add_listener(wl->xdg_toplevel, &xdg_toplevel_listener, wl);
+
+    if (!wl->xdg_surface || !wl->xdg_toplevel)
+        return 1;
     return 0;
 }
 
-static void toggle_fullscreen(struct vo_wayland_state *wl)
+static void do_minimize(struct vo_wayland_state *wl)
 {
     if (!wl->xdg_toplevel)
         return;
-    wl->state_change = true;
-    if (wl->vo_opts->fullscreen && wl->vo_opts->fsscreen_id < 0) {
-        xdg_toplevel_set_fullscreen(wl->xdg_toplevel, NULL);
-    } else if (wl->vo_opts->fullscreen && wl->vo_opts->fsscreen_id >= 0) {
-        find_output(wl, wl->vo_opts->fsscreen_id);
-        xdg_toplevel_set_fullscreen(wl->xdg_toplevel, wl->current_output->output);
-    } else {
-        xdg_toplevel_unset_fullscreen(wl->xdg_toplevel);
-    }
+    if (wl->vo_opts->window_minimized)
+        xdg_toplevel_set_minimized(wl->xdg_toplevel);
 }
 
-static void toggle_maximized(struct vo_wayland_state *wl)
+static char **get_displays_spanned(struct vo_wayland_state *wl)
 {
-    if (!wl->xdg_toplevel)
-        return;
-    wl->state_change = true;
-    if (wl->vo_opts->window_maximized) {
-        xdg_toplevel_set_maximized(wl->xdg_toplevel);
-    } else {
-        xdg_toplevel_unset_maximized(wl->xdg_toplevel);
+    char **names = NULL;
+    int displays_spanned = 0;
+    struct vo_wayland_output *output;
+    wl_list_for_each(output, &wl->output_list, link) {
+        if (output->has_surface)
+            MP_TARRAY_APPEND(NULL, names, displays_spanned,
+                             talloc_strdup(NULL, output->model));
     }
+    MP_TARRAY_APPEND(NULL, names, displays_spanned, NULL);
+    return names;
 }
 
-static void do_minimize(struct vo_wayland_state *wl)
+static int get_mods(struct vo_wayland_state *wl)
 {
-    if (!wl->xdg_toplevel)
-        return;
-    if (wl->vo_opts->window_minimized)
-        xdg_toplevel_set_minimized(wl->xdg_toplevel);
+    static char* const mod_names[] = {
+        XKB_MOD_NAME_SHIFT,
+        XKB_MOD_NAME_CTRL,
+        XKB_MOD_NAME_ALT,
+        XKB_MOD_NAME_LOGO,
+    };
+
+    static const int mods[] = {
+        MP_KEY_MODIFIER_SHIFT,
+        MP_KEY_MODIFIER_CTRL,
+        MP_KEY_MODIFIER_ALT,
+        MP_KEY_MODIFIER_META,
+    };
+
+    int modifiers = 0;
+
+    for (int n = 0; n < MP_ARRAY_SIZE(mods); n++) {
+        xkb_mod_index_t index = xkb_keymap_mod_get_index(wl->xkb_keymap, mod_names[n]);
+        if (!xkb_state_mod_index_is_consumed(wl->xkb_state, wl->keyboard_code, index)
+            && xkb_state_mod_index_is_active(wl->xkb_state, index,
+                                             XKB_STATE_MODS_DEPRESSED))
+            modifiers |= mods[n];
+    }
+    return modifiers;
 }
 
 static void greatest_common_divisor(struct vo_wayland_state *wl, int a, int b) {
@@ -1397,66 +1252,139 @@ static void greatest_common_divisor(struct vo_wayland_state *wl, int a, int b) {
     }
 }
 
-int vo_wayland_reconfig(struct vo *vo)
+static struct vo_wayland_output *find_output(struct vo_wayland_state *wl)
 {
-    struct vo_wayland_state *wl = vo->wl;
-    bool configure = false;
-
-    MP_VERBOSE(wl, "Reconfiguring!\n");
+    int index = 0;
+    int screen_id = wl->vo_opts->fsscreen_id;
+    char *screen_name = wl->vo_opts->fsscreen_name;
+    struct vo_wayland_output *output = NULL;
+    struct vo_wayland_output *fallback_output = NULL;
+    wl_list_for_each(output, &wl->output_list, link) {
+        if (index == 0)
+            fallback_output = output;
+        if (screen_id == -1 && !screen_name)
+            return output;
+        if (screen_id == -1 && screen_name && !strcmp(screen_name, output->model))
+            return output;
+        if (screen_id == index++)
+            return output;
+    }
+    if (!fallback_output) {
+        MP_ERR(wl, "No screens could be found!\n");
+        return NULL;
+    } else if (wl->vo_opts->fsscreen_id >= 0) {
+        MP_WARN(wl, "Screen index %i not found/unavailable! Falling back to screen 0!\n", screen_id);
+    } else if (wl->vo_opts->fsscreen_name) {
+        MP_WARN(wl, "Screen name %s not found/unavailable! Falling back to screen 0!\n", screen_name);
+    }
+    return fallback_output;
+}
 
-    if (!wl->current_output) {
-        int idx = 0;
-        if (wl->vo_opts->fullscreen && (wl->vo_opts->fsscreen_id >= 0))
-            idx = wl->vo_opts->fsscreen_id;
-        if (find_output(wl, idx))
-            return false;
-        if (!wl->vo_opts->hidpi_window_scale)
-            wl->current_output->scale = 1;
-        wl->scaling = wl->current_output->scale;
-        configure = true;
+static int last_available_sync(struct vo_wayland_state *wl)
+{
+    for (int i = wl->sync_size - 1; i > -1; --i) {
+        if (!wl->sync[i].filled)
+            return i;
     }
+    return -1;
+}
 
-    struct vo_win_geometry geo;
-    struct mp_rect screenrc = wl->current_output->geometry;
-    vo_calc_window_geometry(vo, &screenrc, &geo);
-    vo_apply_window_geometry(vo, &geo);
+static int lookupkey(int key)
+{
+    const char *passthrough_keys = " -+*/<>`~!@#$%^&()_{}:;\"\',.?\\|=[]";
 
-    greatest_common_divisor(wl, vo->dwidth, vo->dheight);
-    wl->reduced_width = vo->dwidth / wl->gcd;
-    wl->reduced_height = vo->dheight / wl->gcd;
+    int mpkey = 0;
+    if ((key >= 'a' && key <= 'z') || (key >= 'A' && key <= 'Z') ||
+        (key >= '0' && key <= '9') ||
+        (key >  0   && key <  256 && strchr(passthrough_keys, key)))
+        mpkey = key;
 
-    wl->vdparams.x0 = 0;
-    wl->vdparams.y0 = 0;
-    wl->vdparams.x1 = vo->dwidth / wl->scaling;
-    wl->vdparams.y1 = vo->dheight / wl->scaling;
-    if (wl->vo_opts->keepaspect && wl->vo_opts->keepaspect_window) {
-        wl->window_size = wl->vdparams;
-    }
+    if (!mpkey)
+        mpkey = lookup_keymap_table(keymap, key);
 
-    if (wl->vo_opts->fullscreen)
-        toggle_fullscreen(wl);
+    return mpkey;
+}
 
-    if (wl->vo_opts->window_maximized)
-        toggle_maximized(wl);
+static void queue_new_sync(struct vo_wayland_state *wl)
+{
+    wl->sync_size += 1;
+    wl->sync = talloc_realloc(wl, wl->sync, struct vo_wayland_sync, wl->sync_size);
+    sync_shift(wl);
+}
 
-    if (wl->vo_opts->window_minimized)
-        do_minimize(wl);
+static void remove_output(struct vo_wayland_output *out)
+{
+    if (!out)
+        return;
 
-    wl_surface_set_buffer_scale(wl->surface, wl->scaling);
-    wl_surface_commit(wl->surface);
+    MP_VERBOSE(out->wl, "Deregistering output %s %s (0x%x)\n", out->make,
+               out->model, out->id);
+    wl_list_remove(&out->link);
+    talloc_free(out->make);
+    talloc_free(out->model);
+    talloc_free(out);
+    return;
+}
 
-    if (configure) {
-        wl->window_size = wl->vdparams;
-        wl->geometry = wl->vdparams;
-        wl_display_roundtrip(wl->display);
+static void set_border_decorations(struct vo_wayland_state *wl, int state)
+{
+    if (!wl->xdg_toplevel_decoration) {
+        wl->vo_opts->border = false;
+        m_config_cache_write_opt(wl->vo_opts_cache,
+                                 &wl->vo_opts->border);
+        return;
     }
 
-    if (!wl->vo_opts->fullscreen && !wl->vo_opts->window_maximized)
-        wl->geometry = wl->window_size;
+    enum zxdg_toplevel_decoration_v1_mode mode;
+    if (state) {
+        MP_VERBOSE(wl, "Enabling server decorations\n");
+        mode = ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE;
+    } else {
+        MP_VERBOSE(wl, "Disabling server decorations\n");
+        mode = ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE;
+    }
+    zxdg_toplevel_decoration_v1_set_mode(wl->xdg_toplevel_decoration, mode);
+}
 
-    wl->pending_vo_events |= VO_EVENT_RESIZE;
+static int set_cursor_visibility(struct vo_wayland_state *wl, bool on)
+{
+    wl->cursor_visible = on;
+    if (on) {
+        if (spawn_cursor(wl))
+            return VO_FALSE;
+        struct wl_cursor_image *img = wl->default_cursor->images[0];
+        struct wl_buffer *buffer = wl_cursor_image_get_buffer(img);
+        if (!buffer)
+            return VO_FALSE;
+        wl_pointer_set_cursor(wl->pointer, wl->pointer_id, wl->cursor_surface,
+                              img->hotspot_x/wl->scaling, img->hotspot_y/wl->scaling);
+        wl_surface_set_buffer_scale(wl->cursor_surface, wl->scaling);
+        wl_surface_attach(wl->cursor_surface, buffer, 0, 0);
+        wl_surface_damage(wl->cursor_surface, 0, 0, img->width, img->height);
+        wl_surface_commit(wl->cursor_surface);
+    } else {
+        wl_pointer_set_cursor(wl->pointer, wl->pointer_id, NULL, 0, 0);
+    }
+    return VO_TRUE;
+}
+
+static void set_geometry(struct vo_wayland_state *wl)
+{
+    struct vo *vo = wl->vo;
+
+    struct vo_win_geometry geo;
+    struct mp_rect screenrc = wl->current_output->geometry;
+    vo_calc_window_geometry(vo, &screenrc, &geo);
+    vo_apply_window_geometry(vo, &geo);
+
+    greatest_common_divisor(wl, vo->dwidth, vo->dheight);
+    wl->reduced_width = vo->dwidth / wl->gcd;
+    wl->reduced_height = vo->dheight / wl->gcd;
 
-    return true;
+    wl->vdparams.x0 = 0;
+    wl->vdparams.y0 = 0;
+    wl->vdparams.x1 = vo->dwidth / wl->scaling;
+    wl->vdparams.y1 = vo->dheight / wl->scaling;
 }
 
 static int set_screensaver_inhibitor(struct vo_wayland_state *wl, int state)
@@ -1477,71 +1405,146 @@ static int set_screensaver_inhibitor(struct vo_wayland_state *wl, int state)
     return VO_TRUE;
 }
 
-static int update_window_title(struct vo_wayland_state *wl, const char *title)
+static void set_surface_scaling(struct vo_wayland_state *wl)
 {
-    if (!wl->xdg_toplevel)
-        return VO_NOTAVAIL;
-    xdg_toplevel_set_title(wl->xdg_toplevel, title);
-    return VO_TRUE;
+    int old_scale = wl->scaling;
+    if (wl->vo_opts->hidpi_window_scale) {
+        wl->scaling = wl->current_output->scale;
+    } else {
+        wl->scaling = 1;
+    }
+
+    double factor = (double)old_scale / wl->scaling;
+    wl->vdparams.x1 *= factor;
+    wl->vdparams.y1 *= factor;
+    wl->window_size.x1 *= factor;
+    wl->window_size.y1 *= factor;
 }
 
-static void check_dnd_fd(struct vo_wayland_state *wl)
+static int spawn_cursor(struct vo_wayland_state *wl)
 {
-    if (wl->dnd_fd == -1)
-        return;
+    /* Reuse if size is identical */
+    if (!wl->pointer || wl->allocated_cursor_scale == wl->scaling)
+        return 0;
+    else if (wl->cursor_theme)
+        wl_cursor_theme_destroy(wl->cursor_theme);
 
-    struct pollfd fdp = { wl->dnd_fd, POLLIN | POLLERR | POLLHUP, 0 };
-    if (poll(&fdp, 1, 0) <= 0)
-        return;
+    const char *size_str = getenv("XCURSOR_SIZE");
+    int size = 32;
+    if (size_str != NULL) {
+        errno = 0;
+        char *end;
+        long size_long = strtol(size_str, &end, 10);
+        if (!*end && !errno && size_long > 0 && size_long <= INT_MAX)
+            size = (int)size_long;
+    }
 
-    if (fdp.revents & POLLIN) {
-        ptrdiff_t offset = 0;
-        size_t data_read = 0;
-        const size_t chunk_size = 1;
-        uint8_t *buffer = ta_zalloc_size(wl, chunk_size);
-        if (!buffer)
-            goto end;
+    wl->cursor_theme = wl_cursor_theme_load(NULL, size*wl->scaling, wl->shm);
+    if (!wl->cursor_theme) {
+        MP_ERR(wl, "Unable to load cursor theme!\n");
+        return 1;
+    }
 
-        while ((data_read = read(wl->dnd_fd, buffer + offset, chunk_size)) > 0) {
-            offset += data_read;
-            buffer = ta_realloc_size(wl, buffer, offset + chunk_size);
-            memset(buffer + offset, 0, chunk_size);
-            if (!buffer)
-                goto end;
-        }
+    wl->default_cursor = wl_cursor_theme_get_cursor(wl->cursor_theme, "left_ptr");
+    if (!wl->default_cursor) {
+        MP_ERR(wl, "Unable to load cursor theme!\n");
+        return 1;
+    }
 
-        MP_VERBOSE(wl, "Read %td bytes from the DND fd\n", offset);
+    wl->allocated_cursor_scale = wl->scaling;
 
-        struct bstr file_list = bstr0(buffer);
-        mp_event_drop_mime_data(wl->vo->input_ctx, wl->dnd_mime_type,
-                                file_list, wl->dnd_action);
-        talloc_free(buffer);
-end:
-        talloc_free(wl->dnd_mime_type);
-        wl->dnd_mime_type = NULL;
-        wl->dnd_mime_score = 0;
+    return 0;
+}
+
+static void sync_shift(struct vo_wayland_state *wl)
+{
+    for (int i = wl->sync_size - 1; i > 0; --i) {
+        wl->sync[i] = wl->sync[i-1];
     }
+    struct vo_wayland_sync sync = {0, 0, 0, 0};
+    wl->sync[0] = sync;
+}
 
-    if (fdp.revents & (POLLIN | POLLERR | POLLHUP)) {
-        close(wl->dnd_fd);
-        wl->dnd_fd = -1;
+static void toggle_fullscreen(struct vo_wayland_state *wl)
+{
+    if (!wl->xdg_toplevel)
+        return;
+    wl->state_change = true;
+    bool specific_screen = wl->vo_opts->fsscreen_id >= 0 || wl->vo_opts->fsscreen_name;
+    if (wl->vo_opts->fullscreen && !specific_screen) {
+        xdg_toplevel_set_fullscreen(wl->xdg_toplevel, NULL);
+    } else if (wl->vo_opts->fullscreen && specific_screen) {
+        struct vo_wayland_output *output = find_output(wl);
+        xdg_toplevel_set_fullscreen(wl->xdg_toplevel, output->output);
+    } else {
+        xdg_toplevel_unset_fullscreen(wl->xdg_toplevel);
     }
 }
 
-static char **get_displays_spanned(struct vo_wayland_state *wl)
+static void toggle_maximized(struct vo_wayland_state *wl)
 {
-    char **names = NULL;
-    int displays_spanned = 0;
-    struct vo_wayland_output *output;
-    wl_list_for_each(output, &wl->output_list, link) {
-        if (output->has_surface)
-            MP_TARRAY_APPEND(NULL, names, displays_spanned,
-                             talloc_strdup(NULL, output->model));
+    if (!wl->xdg_toplevel)
+        return;
+    wl->state_change = true;
+    if (wl->vo_opts->window_maximized) {
+        xdg_toplevel_set_maximized(wl->xdg_toplevel);
+    } else {
+        xdg_toplevel_unset_maximized(wl->xdg_toplevel);
     }
-    MP_TARRAY_APPEND(NULL, names, displays_spanned, NULL);
-    return names;
 }
 
+static void update_app_id(struct vo_wayland_state *wl)
+{
+    if (!wl->xdg_toplevel)
+        return;
+    xdg_toplevel_set_app_id(wl->xdg_toplevel, wl->vo_opts->appid);
+}
+
+static int update_window_title(struct vo_wayland_state *wl, const char *title)
+{
+    if (!wl->xdg_toplevel)
+        return VO_NOTAVAIL;
+    xdg_toplevel_set_title(wl->xdg_toplevel, title);
+    return VO_TRUE;
+}
+
+static void window_move(struct vo_wayland_state *wl, uint32_t serial)
+{
+    if (wl->xdg_toplevel)
+        xdg_toplevel_move(wl->xdg_toplevel, wl->seat, serial);
+}
+
+static void vo_wayland_dispatch_events(struct vo_wayland_state *wl, int nfds, int timeout)
+{
+    struct pollfd fds[2] = {
+        {.fd = wl->display_fd,     .events = POLLIN },
+        {.fd = wl->wakeup_pipe[0], .events = POLLIN },
+    };
+
+    while (wl_display_prepare_read(wl->display) != 0)
+        wl_display_dispatch_pending(wl->display);
+    wl_display_flush(wl->display);
+
+    poll(fds, nfds, timeout);
+
+    if (fds[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {
+        MP_FATAL(wl, "Error occurred on the display fd, closing\n");
+        wl_display_cancel_read(wl->display);
+        close(wl->display_fd);
+        wl->display_fd = -1;
+        mp_input_put_key(wl->vo->input_ctx, MP_KEY_CLOSE_WIN);
+    } else {
+        wl_display_read_events(wl->display);
+    }
+
+    if (fds[0].revents & POLLIN)
+        wl_display_dispatch_pending(wl->display);
+
+    if (fds[1].revents & POLLIN)
+        mp_flush_wakeup_pipe(wl->wakeup_pipe[0]);
+}
+
+/* Non-static */
 int vo_wayland_control(struct vo *vo, int *events, int request, void *arg)
 {
     struct vo_wayland_state *wl = vo->wl;
@@ -1558,16 +1561,34 @@ int vo_wayland_control(struct vo *vo, int *events, int request, void *arg)
     case VOCTRL_VO_OPTS_CHANGED: {
         void *opt;
         while (m_config_cache_get_next_changed(wl->vo_opts_cache, &opt)) {
+            if (opt == &opts->appid)
+                update_app_id(wl);
+            if (opt == &opts->border)
+                set_border_decorations(wl, opts->border);
             if (opt == &opts->fullscreen)
                 toggle_fullscreen(wl);
-            if (opt == &opts->window_minimized)
-                do_minimize(wl);
+            if (opt == &opts->hidpi_window_scale)
+            {
+                set_surface_scaling(wl);
+                if (!wl->vo_opts->fullscreen && !wl->vo_opts->window_maximized) {
+                    wl_surface_set_buffer_scale(wl->surface, wl->scaling);
+                } else {
+                    wl->scale_change = true;
+                }
+            }
             if (opt == &opts->window_maximized)
                 toggle_maximized(wl);
-            if (opt == &opts->border)
-                set_border_decorations(wl, opts->border);
-            if (opt == &opts->appid)
-                update_app_id(wl);
+            if (opt == &opts->window_minimized)
+                do_minimize(wl);
+            if (opt == &opts->geometry || opt == &opts->autofit ||
+                opt == &opts->autofit_smaller || opt == &opts->autofit_larger)
+            {
+                set_geometry(wl);
+                wl->window_size = wl->vdparams;
+                if (!wl->vo_opts->fullscreen && !wl->vo_opts->window_maximized)
+                    wl->geometry = wl->window_size;
+                wl->pending_vo_events |= VO_EVENT_RESIZE;
+            }
         }
         return VO_TRUE;
     }
@@ -1597,25 +1618,179 @@ int vo_wayland_control(struct vo *vo, int *events, int request, void *arg)
         }
         return VO_TRUE;
     }
-    case VOCTRL_GET_DISPLAY_FPS: {
+    case VOCTRL_GET_DISPLAY_FPS: {
+        if (!wl->current_output)
+            return VO_NOTAVAIL;
+        *(double *)arg = wl->current_output->refresh_rate;
+        return VO_TRUE;
+    }
+    case VOCTRL_GET_DISPLAY_RES: {
+        if (!wl->current_output)
+            return VO_NOTAVAIL;
+        ((int *)arg)[0] = wl->current_output->geometry.x1;
+        ((int *)arg)[1] = wl->current_output->geometry.y1;
+        return VO_TRUE;
+    }
+    case VOCTRL_GET_HIDPI_SCALE: {
+        if (!wl->scaling)
+            return VO_NOTAVAIL;
+        *(double *)arg = wl->scaling;
+        return VO_TRUE;
+    }
+    case VOCTRL_UPDATE_WINDOW_TITLE:
+        return update_window_title(wl, (const char *)arg);
+    case VOCTRL_SET_CURSOR_VISIBILITY:
+        if (!wl->pointer)
+            return VO_NOTAVAIL;
+        return set_cursor_visibility(wl, *(bool *)arg);
+    case VOCTRL_KILL_SCREENSAVER:
+        return set_screensaver_inhibitor(wl, true);
+    case VOCTRL_RESTORE_SCREENSAVER:
+        return set_screensaver_inhibitor(wl, false);
+    }
+
+    return VO_NOTIMPL;
+}
+
+int vo_wayland_init(struct vo *vo)
+{
+    vo->wl = talloc_zero(NULL, struct vo_wayland_state);
+    struct vo_wayland_state *wl = vo->wl;
+
+    *wl = (struct vo_wayland_state) {
+        .display = wl_display_connect(NULL),
+        .vo = vo,
+        .log = mp_log_new(wl, vo->log, "wayland"),
+        .scaling = 1,
+        .wakeup_pipe = {-1, -1},
+        .dnd_fd = -1,
+        .cursor_visible = true,
+        .vo_opts_cache = m_config_cache_alloc(wl, vo->global, &vo_sub_opts),
+    };
+    wl->vo_opts = wl->vo_opts_cache->opts;
+
+    wl_list_init(&wl->output_list);
+
+    if (!wl->display)
+        return false;
+
+    if (create_input(wl))
+        return false;
+
+    wl->registry = wl_display_get_registry(wl->display);
+    wl_registry_add_listener(wl->registry, &registry_listener, wl);
+
+    /* Do a roundtrip to run the registry */
+    wl_display_roundtrip(wl->display);
+
+    if (!wl->wm_base) {
+        MP_FATAL(wl, "Compositor doesn't support the required %s protocol!\n",
+                 xdg_wm_base_interface.name);
+        return false;
+    }
+
+    if (!wl_list_length(&wl->output_list)) {
+        MP_FATAL(wl, "No outputs found or compositor doesn't support %s (ver. 2)\n",
+                 wl_output_interface.name);
+        return false;
+    }
+
+    /* Can't be initialized during registry due to multi-protocol dependence */
+    if (create_xdg_surface(wl))
+        return false;
+
+    const char *xdg_current_desktop = getenv("XDG_CURRENT_DESKTOP");
+    if (xdg_current_desktop != NULL && strstr(xdg_current_desktop, "GNOME"))
+        MP_WARN(wl, "GNOME's wayland compositor lacks support for the idle inhibit protocol. This means the screen can blank during playback.\n");
+
+    if (wl->dnd_devman && wl->seat) {
+        wl->dnd_ddev = wl_data_device_manager_get_data_device(wl->dnd_devman, wl->seat);
+        wl_data_device_add_listener(wl->dnd_ddev, &data_device_listener, wl);
+    } else if (!wl->dnd_devman) {
+        MP_VERBOSE(wl, "Compositor doesn't support the %s (ver. 3) protocol!\n",
+                   wl_data_device_manager_interface.name);
+    }
+
+    if (wl->presentation) {
+        wl->sync = talloc_zero_array(wl, struct vo_wayland_sync, 1);
+        struct vo_wayland_sync sync = {0, 0, 0, 0};
+        wl->sync[0] = sync;
+        wl->sync_size += 1;
+    } else {
+        MP_VERBOSE(wl, "Compositor doesn't support the %s protocol!\n",
+                   wp_presentation_interface.name);
+    }
+
+    if (wl->xdg_decoration_manager) {
+        wl->xdg_toplevel_decoration = zxdg_decoration_manager_v1_get_toplevel_decoration(wl->xdg_decoration_manager, wl->xdg_toplevel);
+        set_border_decorations(wl, wl->vo_opts->border);
+    } else {
+        wl->vo_opts->border = false;
+        m_config_cache_write_opt(wl->vo_opts_cache,
+                                 &wl->vo_opts->border);
+        MP_VERBOSE(wl, "Compositor doesn't support the %s protocol!\n",
+                   zxdg_decoration_manager_v1_interface.name);
+    }
+
+    if (!wl->idle_inhibit_manager)
+        MP_VERBOSE(wl, "Compositor doesn't support the %s protocol!\n",
+                   zwp_idle_inhibit_manager_v1_interface.name);
+
+    wl->opts = mp_get_config_group(wl, wl->vo->global, &wayland_conf);
+    wl->display_fd = wl_display_get_fd(wl->display);
+    wl->frame_callback = wl_surface_frame(wl->surface);
+    wl_callback_add_listener(wl->frame_callback, &frame_listener, wl);
+
+    update_app_id(wl);
+    mp_make_wakeup_pipe(wl->wakeup_pipe);
+
+    return true;
+}
+
+int vo_wayland_reconfig(struct vo *vo)
+{
+    struct vo_wayland_state *wl = vo->wl;
+    bool configure = false;
+
+    MP_VERBOSE(wl, "Reconfiguring!\n");
+
+    if (!wl->current_output) {
+        wl->current_output = find_output(wl);
         if (!wl->current_output)
-            return VO_NOTAVAIL;
-        *(double *)arg = wl->current_output->refresh_rate;
-        return VO_TRUE;
+            return false;
+        set_surface_scaling(wl);
+        wl_surface_set_buffer_scale(wl->surface, wl->scaling);
+        wl_surface_commit(wl->surface);
+        configure = true;
     }
-    case VOCTRL_UPDATE_WINDOW_TITLE:
-        return update_window_title(wl, (const char *)arg);
-    case VOCTRL_SET_CURSOR_VISIBILITY:
-        if (!wl->pointer)
-            return VO_NOTAVAIL;
-        return set_cursor_visibility(wl, *(bool *)arg);
-    case VOCTRL_KILL_SCREENSAVER:
-        return set_screensaver_inhibitor(wl, true);
-    case VOCTRL_RESTORE_SCREENSAVER:
-        return set_screensaver_inhibitor(wl, false);
+
+    set_geometry(wl);
+
+    if (wl->vo_opts->keepaspect && wl->vo_opts->keepaspect_window)
+        wl->window_size = wl->vdparams;
+
+    if (!wl->vo_opts->fullscreen && !wl->vo_opts->window_maximized)
+        wl->geometry = wl->window_size;
+
+    if (wl->vo_opts->fullscreen)
+        toggle_fullscreen(wl);
+
+    if (wl->vo_opts->window_maximized)
+        toggle_maximized(wl);
+
+    if (wl->vo_opts->window_minimized)
+        do_minimize(wl);
+
+    if (configure) {
+        wl->window_size = wl->vdparams;
+        wl->geometry = wl->window_size;
+        wl_display_roundtrip(wl->display);
+        wl->pending_vo_events |= VO_EVENT_DPI;
     }
 
-    return VO_NOTIMPL;
+    wl->pending_vo_events |= VO_EVENT_RESIZE;
+
+    return true;
 }
 
 void vo_wayland_set_opaque_region(struct vo_wayland_state *wl, int alpha)
@@ -1632,39 +1807,7 @@ void vo_wayland_set_opaque_region(struct vo_wayland_state *wl, int alpha)
     }
 }
 
-void vo_wayland_sync_clear(struct vo_wayland_state *wl)
-{
-    struct vo_wayland_sync sync = {0, 0, 0, 0};
-    for (int i = 0; i < wl->sync_size; ++i)
-        wl->sync[i] = sync;
-}
-
-void vo_wayland_sync_shift(struct vo_wayland_state *wl)
-{
-    for (int i = wl->sync_size - 1; i > 0; --i) {
-        wl->sync[i] = wl->sync[i-1];
-    }
-    struct vo_wayland_sync sync = {0, 0, 0, 0};
-    wl->sync[0] = sync;
-}
-
-int last_available_sync(struct vo_wayland_state *wl)
-{
-    for (int i = wl->sync_size - 1; i > -1; --i) {
-        if (!wl->sync[i].filled)
-            return i;
-    }
-    return -1;
-}
-
-void queue_new_sync(struct vo_wayland_state *wl)
-{
-    wl->sync_size += 1;
-    wl->sync = talloc_realloc(wl, wl->sync, struct vo_wayland_sync, wl->sync_size);
-    vo_wayland_sync_shift(wl);
-}
-
-void wayland_sync_swap(struct vo_wayland_state *wl)
+void vo_wayland_sync_swap(struct vo_wayland_state *wl)
 {
     int index = wl->sync_size - 1;
 
@@ -1701,56 +1844,161 @@ void wayland_sync_swap(struct vo_wayland_state *wl)
     wl->last_queue_display_time = ust_mp_time + wl->vsync_duration;
 }
 
-void vo_wayland_wakeup(struct vo *vo)
+void vo_wayland_uninit(struct vo *vo)
 {
     struct vo_wayland_state *wl = vo->wl;
-    (void)write(wl->wakeup_pipe[1], &(char){0}, 1);
+    if (!wl)
+        return;
+
+    mp_input_put_key(wl->vo->input_ctx, MP_INPUT_RELEASE_ALL);
+
+    if (wl->compositor)
+        wl_compositor_destroy(wl->compositor);
+
+    if (wl->current_output && wl->current_output->output)
+        wl_output_destroy(wl->current_output->output);
+
+    if (wl->cursor_surface)
+        wl_surface_destroy(wl->cursor_surface);
+
+    if (wl->cursor_theme)
+        wl_cursor_theme_destroy(wl->cursor_theme);
+
+    if (wl->dnd_ddev)
+        wl_data_device_destroy(wl->dnd_ddev);
+
+    if (wl->dnd_devman)
+        wl_data_device_manager_destroy(wl->dnd_devman);
+
+    if (wl->dnd_offer)
+        wl_data_offer_destroy(wl->dnd_offer);
+
+    if (wl->feedback)
+        wp_presentation_feedback_destroy(wl->feedback);
+
+    if (wl->frame_callback)
+        wl_callback_destroy(wl->frame_callback);
+
+    if (wl->idle_inhibitor)
+        zwp_idle_inhibitor_v1_destroy(wl->idle_inhibitor);
+
+    if (wl->idle_inhibit_manager)
+        zwp_idle_inhibit_manager_v1_destroy(wl->idle_inhibit_manager);
+
+    if (wl->keyboard)
+        wl_keyboard_destroy(wl->keyboard);
+
+    if (wl->pointer)
+        wl_pointer_destroy(wl->pointer);
+
+    if (wl->presentation)
+        wp_presentation_destroy(wl->presentation);
+
+    if (wl->registry)
+        wl_registry_destroy(wl->registry);
+
+    if (wl->seat)
+        wl_seat_destroy(wl->seat);
+
+    if (wl->shm)
+        wl_shm_destroy(wl->shm);
+
+    if (wl->surface)
+        wl_surface_destroy(wl->surface);
+
+    if (wl->wm_base)
+        xdg_wm_base_destroy(wl->wm_base);
+
+    if (wl->xdg_decoration_manager)
+        zxdg_decoration_manager_v1_destroy(wl->xdg_decoration_manager);
+
+    if (wl->xdg_toplevel)
+        xdg_toplevel_destroy(wl->xdg_toplevel);
+
+    if (wl->xdg_toplevel_decoration)
+        zxdg_toplevel_decoration_v1_destroy(wl->xdg_toplevel_decoration);
+
+    if (wl->xdg_surface)
+        xdg_surface_destroy(wl->xdg_surface);
+
+    if (wl->xkb_context)
+        xkb_context_unref(wl->xkb_context);
+
+    if (wl->xkb_keymap)
+        xkb_keymap_unref(wl->xkb_keymap);
+
+    if (wl->xkb_state)
+        xkb_state_unref(wl->xkb_state);
+
+    if (wl->display) {
+        close(wl_display_get_fd(wl->display));
+        wl_display_disconnect(wl->display);
+    }
+
+    struct vo_wayland_output *output, *tmp;
+    wl_list_for_each_safe(output, tmp, &wl->output_list, link)
+        remove_output(output);
+
+    talloc_free(wl->dnd_mime_type);
+
+    for (int n = 0; n < 2; n++)
+        close(wl->wakeup_pipe[n]);
+    talloc_free(wl);
+    vo->wl = NULL;
 }
 
 void vo_wayland_wait_frame(struct vo_wayland_state *wl)
 {
-    struct pollfd fds[1] = {
-        {.fd = wl->display_fd,     .events = POLLIN },
-    };
+    int64_t vblank_time = 0;
+    /* We need some vblank interval to use for the timeout in
+     * this function. The order of preference of values to use is:
+     * 1. vsync duration from presentation time
+     * 2. refresh inteval reported by presentation time
+     * 3. refresh rate of the output reported by the compositor
+     * 4. make up crap if vblank_time is still <= 0 (better than nothing) */
+
+    if (wl->presentation)
+        vblank_time = wl->vsync_duration;
+
+    if (vblank_time <= 0 && wl->refresh_interval > 0)
+        vblank_time = wl->refresh_interval;
+
+    if (vblank_time <= 0 && wl->current_output->refresh_rate > 0)
+        vblank_time = 1e6 / wl->current_output->refresh_rate;
+
+    // Ideally you should never reach this point.
+    if (vblank_time <= 0)
+        vblank_time = 1e6 / 60;
 
-    double vblank_time = 1e6 / wl->current_output->refresh_rate;
     int64_t finish_time = mp_time_us() + vblank_time;
 
     while (wl->frame_wait && finish_time > mp_time_us()) {
-
         int poll_time = ceil((double)(finish_time - mp_time_us()) / 1000);
         if (poll_time < 0) {
             poll_time = 0;
         }
+        vo_wayland_dispatch_events(wl, 1, poll_time);
+    }
 
-        while (wl_display_prepare_read(wl->display) != 0)
-            wl_display_dispatch_pending(wl->display);
-        wl_display_flush(wl->display);
-
-        poll(fds, 1, poll_time);
+    /* If the compositor does not have presentation time, we cannot be sure
+     * that this wait is accurate. Do a hacky block with wl_display_roundtrip. */
+    if (!wl->presentation && !wl_display_get_error(wl->display))
+        wl_display_roundtrip(wl->display);
 
-        if (fds[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {
-            wl_display_cancel_read(wl->display);
+    if (wl->frame_wait) {
+        // Only consider consecutive missed callbacks.
+        if (wl->timeout_count > 1) {
+            wl->hidden = true;
+            return;
         } else {
-            wl_display_read_events(wl->display);
+            wl->timeout_count += 1;
+            wl->hidden = false;
+            return;
         }
-
-        wl_display_dispatch_pending(wl->display);
-    }
-
-    if (!wl->hidden && wl->frame_wait) {
-        wl->timeout_count += 1;
-        if (wl->timeout_count > wl->current_output->refresh_rate)
-            wl->hidden = true;
-    }
-
-    if (!wl->frame_wait) {
-        wl->timeout_count = 0;
-        wl->hidden = false;
     }
 
-    if (wl_display_get_error(wl->display) == 0)
-        wl_display_roundtrip(wl->display);
+    wl->timeout_count = 0;
+    wl->hidden = false;
 }
 
 void vo_wayland_wait_events(struct vo *vo, int64_t until_time_us)
@@ -1760,33 +2008,14 @@ void vo_wayland_wait_events(struct vo *vo, int64_t until_time_us)
     if (wl->display_fd == -1)
         return;
 
-    struct pollfd fds[2] = {
-        {.fd = wl->display_fd,     .events = POLLIN },
-        {.fd = wl->wakeup_pipe[0], .events = POLLIN },
-    };
-
     int64_t wait_us = until_time_us - mp_time_us();
     int timeout_ms = MPCLAMP((wait_us + 999) / 1000, 0, 10000);
 
-    while (wl_display_prepare_read(wl->display) != 0)
-        wl_display_dispatch_pending(wl->display);
-    wl_display_flush(wl->display);
-
-    poll(fds, 2, timeout_ms);
-
-    if (fds[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {
-        MP_FATAL(wl, "Error occurred on the display fd, closing\n");
-        wl_display_cancel_read(wl->display);
-        close(wl->display_fd);
-        wl->display_fd = -1;
-        mp_input_put_key(vo->input_ctx, MP_KEY_CLOSE_WIN);
-    } else {
-        wl_display_read_events(wl->display);
-    }
-
-    if (fds[0].revents & POLLIN)
-        wl_display_dispatch_pending(wl->display);
+    vo_wayland_dispatch_events(wl, 2, timeout_ms);
+}
 
-    if (fds[1].revents & POLLIN)
-        mp_flush_wakeup_pipe(wl->wakeup_pipe[0]);
+void vo_wayland_wakeup(struct vo *vo)
+{
+    struct vo_wayland_state *wl = vo->wl;
+    (void)write(wl->wakeup_pipe[1], &(char){0}, 1);
 }
diff --git a/video/out/wayland_common.h b/video/out/wayland_common.h
index 41edcf5..b77bab4 100644
--- a/video/out/wayland_common.h
+++ b/video/out/wayland_common.h
@@ -19,11 +19,8 @@
 #define MPLAYER_WAYLAND_COMMON_H
 
 #include <wayland-client.h>
-#include <wayland-cursor.h>
-#include <xkbcommon/xkbcommon.h>
-
-#include "vo.h"
 #include "input/event.h"
+#include "vo.h"
 
 struct wayland_opts {
     int disable_vsync;
@@ -31,133 +28,113 @@ struct wayland_opts {
     int edge_pixels_touch;
 };
 
-struct vo_wayland_sync {
-    int64_t ust;
-    int64_t msc;
-    int64_t sbc;
-    bool filled;
-};
-
-struct vo_wayland_output {
-    struct vo_wayland_state *wl;
-    uint32_t id;
-    struct wl_output *output;
-    struct mp_rect geometry;
-    int phys_width;
-    int phys_height;
-    int scale;
-    uint32_t flags;
-    double refresh_rate;
-    char *make;
-    char *model;
-    bool has_surface;
-    struct wl_list link;
-};
-
 struct vo_wayland_state {
-    struct mp_log        *log;
-    struct vo            *vo;
-    struct wl_display    *display;
-    struct wl_shm        *shm;
-    struct wl_compositor *compositor;
-    struct wl_registry   *registry;
-    struct wayland_opts  *opts;
-
     struct m_config_cache *vo_opts_cache;
-    struct mp_vo_opts *vo_opts;
-
-    /* State */
+    struct mp_log         *log;
+    struct mp_vo_opts     *vo_opts;
+    struct vo             *vo;
+    struct wayland_opts   *opts;
+    struct wl_callback    *frame_callback;
+    struct wl_compositor  *compositor;
+    struct wl_display     *display;
+    struct wl_registry    *registry;
+    struct wl_shm         *shm;
+    struct wl_surface     *surface;
+
+    /* Geometry */
     struct mp_rect geometry;
-    struct mp_rect window_size;
     struct mp_rect vdparams;
+    struct mp_rect window_size;
+    struct wl_list output_list;
+    struct vo_wayland_output *current_output;
     int gcd;
-    int reduced_width;
     int reduced_height;
-    bool frame_wait;
-    bool state_change;
-    bool toplevel_configured;
+    int reduced_width;
+    int toplevel_width;
+    int toplevel_height;
+
+    /* State */
     bool activated;
     bool has_keyboard_input;
     bool focused;
+    bool frame_wait;
     bool hidden;
-    int timeout_count;
-    int wakeup_pipe[2];
-    int pending_vo_events;
-    int mouse_x;
-    int mouse_y;
+    bool scale_change;
+    bool state_change;
+    bool toplevel_configured;
+    int display_fd;
     int mouse_unscaled_x;
     int mouse_unscaled_y;
+    int mouse_x;
+    int mouse_y;
+    int pending_vo_events;
     int scaling;
+    int timeout_count;
     int touch_entries;
-    int toplevel_width;
-    int toplevel_height;
-    uint32_t pointer_id;
-    int display_fd;
-    struct wl_callback       *frame_callback;
-    struct wl_list            output_list;
-    struct vo_wayland_output *current_output;
+    int wakeup_pipe[2];
+
+    /* idle-inhibit */
+    struct zwp_idle_inhibit_manager_v1 *idle_inhibit_manager;
+    struct zwp_idle_inhibitor_v1 *idle_inhibitor;
+
+    /* xdg-decoration */
+    struct zxdg_decoration_manager_v1 *xdg_decoration_manager;
+    struct zxdg_toplevel_decoration_v1 *xdg_toplevel_decoration;
 
-    /* Shell */
-    struct wl_surface       *surface;
+    /* xdg-shell */
     struct xdg_wm_base      *wm_base;
-    struct xdg_toplevel     *xdg_toplevel;
     struct xdg_surface      *xdg_surface;
+    struct xdg_toplevel     *xdg_toplevel;
+
+    /* presentation-time */
     struct wp_presentation  *presentation;
     struct wp_presentation_feedback *feedback;
-    struct zxdg_decoration_manager_v1 *xdg_decoration_manager;
-    struct zxdg_toplevel_decoration_v1 *xdg_toplevel_decoration;
-    struct zwp_idle_inhibit_manager_v1 *idle_inhibit_manager;
-    struct zwp_idle_inhibitor_v1 *idle_inhibitor;
-
-    /* Presentation Feedback */
     struct vo_wayland_sync *sync;
     int sync_size;
     int64_t last_ust;
     int64_t last_msc;
     int64_t last_skipped_vsyncs;
     int64_t last_queue_display_time;
+    int64_t refresh_interval;
     int64_t vsync_duration;
 
     /* Input */
-    uint32_t keyboard_code;
-    struct wl_seat     *seat;
+    struct wl_keyboard *keyboard;
     struct wl_pointer  *pointer;
+    struct wl_seat     *seat;
     struct wl_touch    *touch;
-    struct wl_keyboard *keyboard;
     struct xkb_context *xkb_context;
     struct xkb_keymap  *xkb_keymap;
     struct xkb_state   *xkb_state;
+    uint32_t keyboard_code;
 
     /* DND */
-    struct wl_data_device_manager *dnd_devman;
     struct wl_data_device *dnd_ddev;
+    struct wl_data_device_manager *dnd_devman;
     struct wl_data_offer *dnd_offer;
     enum mp_dnd_action dnd_action;
     char *dnd_mime_type;
-    int dnd_mime_score;
     int dnd_fd;
+    int dnd_mime_score;
 
     /* Cursor */
     struct wl_cursor_theme *cursor_theme;
     struct wl_cursor       *default_cursor;
     struct wl_surface      *cursor_surface;
-    int                     allocated_cursor_scale;
     bool                    cursor_visible;
+    int                     allocated_cursor_scale;
+    uint32_t                pointer_id;
 };
 
+int vo_wayland_control(struct vo *vo, int *events, int request, void *arg);
 int vo_wayland_init(struct vo *vo);
 int vo_wayland_reconfig(struct vo *vo);
-int vo_wayland_control(struct vo *vo, int *events, int request, void *arg);
-int last_available_sync(struct vo_wayland_state *wl);
-void vo_wayland_check_events(struct vo *vo);
+
+void vo_wayland_set_opaque_region(struct vo_wayland_state *wl, int alpha);
+void vo_wayland_sync_swap(struct vo_wayland_state *wl);
 void vo_wayland_uninit(struct vo *vo);
-void vo_wayland_wakeup(struct vo *vo);
 void vo_wayland_wait_events(struct vo *vo, int64_t until_time_us);
 void vo_wayland_wait_frame(struct vo_wayland_state *wl);
-void vo_wayland_set_opaque_region(struct vo_wayland_state *wl, int alpha);
-void vo_wayland_sync_clear(struct vo_wayland_state *wl);
-void wayland_sync_swap(struct vo_wayland_state *wl);
-void vo_wayland_sync_shift(struct vo_wayland_state *wl);
-void queue_new_sync(struct vo_wayland_state *wl);
+void vo_wayland_wakeup(struct vo *vo);
 
 #endif /* MPLAYER_WAYLAND_COMMON_H */
diff --git a/video/out/x11_common.c b/video/out/x11_common.c
index 92b3539..12d2648 100644
--- a/video/out/x11_common.c
+++ b/video/out/x11_common.c
@@ -467,7 +467,8 @@ static void vo_x11_update_screeninfo(struct vo *vo)
     struct mp_vo_opts *opts = x11->opts;
     bool all_screens = opts->fullscreen && opts->fsscreen_id == -2;
     x11->screenrc = (struct mp_rect){.x1 = x11->ws_width, .y1 = x11->ws_height};
-    if (opts->screen_id >= -1 && XineramaIsActive(x11->display) && !all_screens)
+    if ((opts->screen_id >= -1 || opts->screen_name) && XineramaIsActive(x11->display) &&
+         !all_screens)
     {
         int screen = opts->fullscreen ? opts->fsscreen_id : opts->screen_id;
         XineramaScreenInfo *screens;
@@ -476,6 +477,23 @@ static void vo_x11_update_screeninfo(struct vo *vo)
         if (opts->fullscreen && opts->fsscreen_id == -1)
             screen = opts->screen_id;
 
+        if (screen == -1 && (opts->fsscreen_name || opts->screen_name)) {
+            char *screen_name = opts->fullscreen ? opts->fsscreen_name : opts->screen_name;
+            if (screen_name) {
+                bool screen_found = false;
+                for (int n = 0; n < x11->num_displays; n++) {
+                    char *display_name = x11->displays[n].name;
+                    if (!strcmp(display_name, screen_name)) {
+                        screen = n;
+                        screen_found = true;
+                        break;
+                    }
+                }
+                if (!screen_found)
+                    MP_WARN(x11, "Screen name %s not found!\n", screen_name);
+            }
+        }
+
         screens = XineramaQueryScreens(x11->display, &num_screens);
         if (screen >= num_screens)
             screen = num_screens - 1;
@@ -1019,6 +1037,11 @@ static void vo_x11_check_net_wm_state_change(struct vo *vo)
             XFree(elems);
         }
 
+        if (opts->window_maximized && !is_maximized && x11->pending_geometry_change) {
+            vo_x11_config_vo_window(vo);
+            x11->pending_geometry_change = false;
+        }
+
         opts->window_minimized = is_minimized;
         m_config_cache_write_opt(x11->opts_cache, &opts->window_minimized);
         opts->window_maximized = is_maximized;
@@ -1820,6 +1843,17 @@ static void vo_x11_minimize(struct vo *vo)
     }
 }
 
+static void vo_x11_set_geometry(struct vo *vo)
+{
+    struct vo_x11_state *x11 = vo->x11;
+
+    if (x11->opts->window_maximized) {
+        x11->pending_geometry_change = true;
+    } else {
+        vo_x11_config_vo_window(vo);
+    }
+}
+
 int vo_x11_control(struct vo *vo, int *events, int request, void *arg)
 {
     struct vo_x11_state *x11 = vo->x11;
@@ -1853,6 +1887,11 @@ int vo_x11_control(struct vo *vo, int *events, int request, void *arg)
                 vo_x11_minimize(vo);
             if (opt == &opts->window_maximized)
                 vo_x11_maximize(vo);
+            if (opt == &opts->geometry || opt == &opts->autofit ||
+                opt == &opts->autofit_smaller || opt == &opts->autofit_larger)
+            {
+                vo_x11_set_geometry(vo);
+            }
         }
         return VO_TRUE;
     }
@@ -1943,6 +1982,13 @@ int vo_x11_control(struct vo *vo, int *events, int request, void *arg)
         *(double *)arg = fps;
         return VO_TRUE;
     }
+    case VOCTRL_GET_DISPLAY_RES: {
+        if (!x11->window || x11->parent)
+            return VO_NOTAVAIL;
+        ((int *)arg)[0] = x11->screenrc.x1;
+        ((int *)arg)[1] = x11->screenrc.y1;
+        return VO_TRUE;
+    }
     case VOCTRL_GET_HIDPI_SCALE:
         *(double *)arg = x11->dpi_scale;
         return VO_TRUE;
diff --git a/video/out/x11_common.h b/video/out/x11_common.h
index 774a76a..45c8d04 100644
--- a/video/out/x11_common.h
+++ b/video/out/x11_common.h
@@ -111,6 +111,10 @@ struct vo_x11_state {
     bool size_changed_during_fs;
     bool pos_changed_during_fs;
 
+    /* The geometry/autofit option was changed while the window was maximized.
+     * Wait until the state changes to resize. */
+    bool pending_geometry_change;
+
     XComposeStatus compose_status;
 
     /* XShm stuff */
diff --git a/video/zimg.c b/video/zimg.c
index a73293c..e29d7c4 100644
--- a/video/zimg.c
+++ b/video/zimg.c
@@ -123,6 +123,7 @@ static void mp_zimg_update_from_cmdline(struct mp_zimg_context *ctx)
 static zimg_chroma_location_e mp_to_z_chroma(enum mp_chroma_location cl)
 {
     switch (cl) {
+    case MP_CHROMA_TOPLEFT:     return ZIMG_CHROMA_TOP_LEFT;
     case MP_CHROMA_LEFT:        return ZIMG_CHROMA_LEFT;
     case MP_CHROMA_CENTER:      return ZIMG_CHROMA_CENTER;
     default:                    return ZIMG_CHROMA_LEFT;
diff --git a/waftools/checks/custom.py b/waftools/checks/custom.py
index 36c1d85..9645469 100644
--- a/waftools/checks/custom.py
+++ b/waftools/checks/custom.py
@@ -114,17 +114,19 @@ def check_cocoa(ctx, dependency_identifier):
 
     return res
 
-def check_swift(ctx, dependency_identifier):
-    minVer = StrictVersion("3.0.2")
-    if ctx.env.SWIFT_VERSION:
-        if StrictVersion(ctx.env.SWIFT_VERSION) >= minVer:
-            ctx.add_optional_message(dependency_identifier,
-                                     'version found: ' + str(ctx.env.SWIFT_VERSION))
-            return True
-    ctx.add_optional_message(dependency_identifier,
-                             "'swift >= " + str(minVer) + "' not found, found " +
-                             str(ctx.env.SWIFT_VERSION or None))
-    return False
+def check_swift(version):
+    def fn(ctx, dependency_identifier):
+        minVer = StrictVersion(version)
+        if ctx.env.SWIFT_VERSION:
+            if StrictVersion(ctx.env.SWIFT_VERSION) >= minVer:
+                ctx.add_optional_message(dependency_identifier,
+                                         'version found: ' + str(ctx.env.SWIFT_VERSION))
+                return True
+        ctx.add_optional_message(dependency_identifier,
+                                 "'swift >= " + str(minVer) + "' not found, found " +
+                                 str(ctx.env.SWIFT_VERSION or None))
+        return False
+    return fn
 
 def check_egl_provider(minVersion=None, name='egl', check=None):
     def fn(ctx, dependency_identifier, **kw):
diff --git a/wscript b/wscript
index b81f120..1a5ff5a 100644
--- a/wscript
+++ b/wscript
@@ -116,6 +116,10 @@ build_options = [
         'desc': 'inline assembly (currently without effect)',
         'default': 'enable',
         'func': check_true,
+    }, {
+        'name': '--vector',
+        'desc': 'GCC vector instructions',
+        'func': check_statement([], 'float v __attribute__((vector_size(32)))'),
     }, {
         'name': '--clang-database',
         'desc': 'generate a clang compilation database',
@@ -182,7 +186,7 @@ main_dependencies = [
         'name': '--swift',
         'desc': 'macOS Swift build tools',
         'deps': 'os-darwin',
-        'func': compose_checks(check_swift, check_macos_sdk('10.10')),
+        'func': compose_checks(check_swift('4.1'), check_macos_sdk('10.10')),
     }, {
         'name': '--uwp',
         'desc': 'Universal Windows Platform',
@@ -323,8 +327,8 @@ iconv support use --disable-iconv.",
     }, {
         'name': '--zlib',
         'desc': 'zlib',
-        'func': check_libs(['z'],
-                    check_statement('zlib.h', 'inflate(0, Z_NO_FLUSH)')),
+        'func': any_check(check_pkg_config('zlib'),
+                          check_libs(['z'], check_statement('zlib.h', 'inflate(0, Z_NO_FLUSH)'))),
         'req': True,
         'fmsg': 'Unable to find development files for zlib.'
     }, {
@@ -421,6 +425,11 @@ audio_output_features = [
         'desc': 'SDL2 audio output',
         'deps': 'sdl2',
         'func': check_true,
+    }, {
+        'name': '--oss-audio',
+        'desc': 'OSSv4 audio output',
+        'func': check_statement(['sys/soundcard.h'], 'int x = SNDCTL_DSP_SETPLAYVOL'),
+        'deps': 'posix && gpl',
     }, {
         'name': '--pulse',
         'desc': 'PulseAudio audio output',
@@ -725,7 +734,7 @@ video_output_features = [
     }, {
         'name': '--libplacebo',
         'desc': 'libplacebo support',
-        'func': check_pkg_config('libplacebo >= 1.18.0'),
+        'func': check_pkg_config('libplacebo >= 2.72.0'),
     }, {
         'name': '--vulkan',
         'desc':  'Vulkan context support',
@@ -958,6 +967,9 @@ def configure(ctx):
         while re.match('\$\{([^}]+)\}', ctx.env[varname]):
             ctx.env[varname] = Utils.subst_vars(ctx.env[varname], ctx.env)
 
+    if ctx.options.LUA_VER:
+        ctx.options.enable_lua = True
+
     ctx.parse_dependencies(build_options)
     ctx.parse_dependencies(main_dependencies)
     ctx.parse_dependencies(libav_dependencies)
@@ -965,9 +977,6 @@ def configure(ctx):
     ctx.parse_dependencies(video_output_features)
     ctx.parse_dependencies(hwaccel_features)
 
-    if ctx.options.LUA_VER:
-        ctx.options.enable_lua = True
-
     if ctx.options.SWIFT_FLAGS:
         ctx.env.SWIFT_FLAGS.extend(split(ctx.options.SWIFT_FLAGS))
 
diff --git a/wscript_build.py b/wscript_build.py
index 14c254e..fbec500 100644
--- a/wscript_build.py
+++ b/wscript_build.py
@@ -244,6 +244,7 @@ def build(ctx):
         ( "audio/out/ao_null.c" ),
         ( "audio/out/ao_openal.c",               "openal" ),
         ( "audio/out/ao_opensles.c",             "opensles" ),
+        ( "audio/out/ao_oss.c",                  "oss-audio" ),
         ( "audio/out/ao_pcm.c" ),
         ( "audio/out/ao_pulse.c",                "pulse" ),
         ( "audio/out/ao_sdl.c",                  "sdl2-audio" ),
@@ -505,6 +506,7 @@ def build(ctx):
         ( "video/out/vo_x11.c" ,                 "x11" ),
         ( "video/out/vo_xv.c",                   "xv" ),
         ( "video/out/vulkan/context.c",          "vulkan" ),
+        ( "video/out/vulkan/context_display.c",  "vulkan" ),
         ( "video/out/vulkan/context_android.c",  "vulkan && android" ),
         ( "video/out/vulkan/context_wayland.c",  "vulkan && wayland" ),
         ( "video/out/vulkan/context_win.c",      "vulkan && win32-desktop" ),
-- 
2.32.0

