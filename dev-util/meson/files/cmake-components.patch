From 23fb1b19648804dc43ebebe9a5094cda912b7844 Mon Sep 17 00:00:00 2001
From: Daniel Mensinger <daniel@mensinger-ka.de>
Date: Sat, 1 Feb 2020 18:02:19 +0100
Subject: [PATCH] cmake: Add find_package COMPONETS support

---
 docs/markdown/Dependencies.md                 |  4 +++
 docs/markdown/Reference-manual.md             |  3 +-
 docs/markdown/snippets/cmake_comps.md         |  4 +++
 mesonbuild/dependencies/base.py               | 29 +++++++++++++++----
 mesonbuild/dependencies/data/CMakeLists.txt   |  2 +-
 mesonbuild/dependencies/dev.py                |  2 +-
 mesonbuild/interpreter.py                     |  2 ++
 .../cmake/FindSomethingLikeZLIB.cmake         |  4 +++
 .../linuxlike/13 cmake dependency/meson.build |  6 ++--
 9 files changed, 45 insertions(+), 11 deletions(-)
 create mode 100644 docs/markdown/snippets/cmake_comps.md

diff --git a/docs/markdown/Dependencies.md b/docs/markdown/Dependencies.md
index 8cffba44eb..69374488d8 100644
--- a/docs/markdown/Dependencies.md
+++ b/docs/markdown/Dependencies.md
@@ -173,6 +173,10 @@ it automatically.
     cmake_dep = dependency('ZLIB', method : 'cmake', modules : ['ZLIB::ZLIB'])
 ```
 
+Support for adding additional `COMPONENTS` for the CMake `find_package` lookup
+is provided with the `components` kwarg (*introduced in 0.54.0*). All specified
+componets will be passed directly to `find_package(COMPONENTS)`.
+
 It is also possible to reuse existing `Find<name>.cmake` files with the
 `cmake_module_path` property. Using this property is equivalent to setting the
 `CMAKE_MODULE_PATH` variable in CMake. The path(s) given to `cmake_module_path`
diff --git a/docs/markdown/Reference-manual.md b/docs/markdown/Reference-manual.md
index 475b711f34..e937b26fe7 100644
--- a/docs/markdown/Reference-manual.md
+++ b/docs/markdown/Reference-manual.md
@@ -479,7 +479,8 @@ arguments:
 - other
 [library-specific](Dependencies.md#dependencies-with-custom-lookup-functionality)
 keywords may also be accepted (e.g. `modules` specifies submodules to use for
-dependencies such as Qt5 or Boost. )
+dependencies such as Qt5 or Boost. `components` allows the user to manually
+add CMake `COMPONENTS` for the `find_package` lookup)
 - `disabler` if `true` and the dependency couldn't be found, return a
   [disabler object](#disabler-object) instead of a not-found dependency.
   *Since 0.49.0*
diff --git a/docs/markdown/snippets/cmake_comps.md b/docs/markdown/snippets/cmake_comps.md
new file mode 100644
index 0000000000..83b8f2cce4
--- /dev/null
+++ b/docs/markdown/snippets/cmake_comps.md
@@ -0,0 +1,4 @@
+## CMake find_package COMPONENTS support
+
+It is now possible to pass components to the CMake dependency backend via the
+new `components` kwarg in the `dependency` function.
diff --git a/mesonbuild/dependencies/base.py b/mesonbuild/dependencies/base.py
index 6f8181d4d2..640c306f22 100644
--- a/mesonbuild/dependencies/base.py
+++ b/mesonbuild/dependencies/base.py
@@ -995,13 +995,23 @@ def _main_cmake_file(self) -> str:
     def _extra_cmake_opts(self) -> T.List[str]:
         return []
 
-    def _map_module_list(self, modules: T.List[T.Tuple[str, bool]]) -> T.List[T.Tuple[str, bool]]:
+    def _map_module_list(self, modules: T.List[T.Tuple[str, bool]], components: T.List[T.Tuple[str, bool]]) -> T.List[T.Tuple[str, bool]]:
         # Map the input module list to something else
         # This function will only be executed AFTER the initial CMake
         # interpreter pass has completed. Thus variables defined in the
         # CMakeLists.txt can be accessed here.
+        #
+        # Both the modules and components inputs contain the original lists.
         return modules
 
+    def _map_component_list(self, modules: T.List[T.Tuple[str, bool]], components: T.List[T.Tuple[str, bool]]) -> T.List[T.Tuple[str, bool]]:
+        # Map the input components list to something else. This
+        # function will be executed BEFORE the initial CMake interpreter
+        # pass. Thus variables from the CMakeLists.txt can NOT be accessed.
+        #
+        # Both the modules and components inputs contain the original lists.
+        return components
+
     def _original_module_name(self, module: str) -> str:
         # Reverse the module mapping done by _map_module_list for
         # one module
@@ -1065,6 +1075,7 @@ def __init__(self, name: str, environment: Environment, kwargs, language: T.Opti
         if self.cmakeinfo is None:
             raise self._gen_exception('Unable to obtain CMake system information')
 
+        components = [(x, True) for x in stringlistify(extract_as_list(kwargs, 'components'))]
         modules = [(x, True) for x in stringlistify(extract_as_list(kwargs, 'modules'))]
         modules += [(x, False) for x in stringlistify(extract_as_list(kwargs, 'optional_modules'))]
         cm_path = stringlistify(extract_as_list(kwargs, 'cmake_module_path'))
@@ -1086,7 +1097,7 @@ def __init__(self, name: str, environment: Environment, kwargs, language: T.Opti
         if not self._preliminary_find_check(name, cm_path, pref_path, environment.machines[self.for_machine]):
             mlog.debug('Preliminary CMake check failed. Aborting.')
             return
-        self._detect_dep(name, modules, cm_args)
+        self._detect_dep(name, modules, components, cm_args)
 
     def __repr__(self):
         s = '<{0} {1}: {2} {3}>'
@@ -1264,7 +1275,7 @@ def search_lib_dirs(path: str) -> bool:
 
         return False
 
-    def _detect_dep(self, name: str, modules: T.List[T.Tuple[str, bool]], args: T.List[str]):
+    def _detect_dep(self, name: str, modules: T.List[T.Tuple[str, bool]], components: T.List[T.Tuple[str, bool]], args: T.List[str]):
         # Detect a dependency with CMake using the '--find-package' mode
         # and the trace output (stderr)
         #
@@ -1282,13 +1293,21 @@ def _detect_dep(self, name: str, modules: T.List[T.Tuple[str, bool]], args: T.Li
             gen_list += [CMakeDependency.class_working_generator]
         gen_list += CMakeDependency.class_cmake_generators
 
+        # Map the components
+        comp_mapped = self._map_component_list(modules, components)
+
         for i in gen_list:
             mlog.debug('Try CMake generator: {}'.format(i if len(i) > 0 else 'auto'))
 
             # Prepare options
-            cmake_opts = ['-DNAME={}'.format(name), '-DARCHS={}'.format(';'.join(self.cmakeinfo['archs']))] + args + ['.']
+            cmake_opts = []
+            cmake_opts += ['-DNAME={}'.format(name)]
+            cmake_opts += ['-DARCHS={}'.format(';'.join(self.cmakeinfo['archs']))]
+            cmake_opts += ['-DCOMPS={}'.format(';'.join([x[0] for x in comp_mapped]))]
+            cmake_opts += args
             cmake_opts += self.traceparser.trace_args()
             cmake_opts += self._extra_cmake_opts()
+            cmake_opts += ['.']
             if len(i) > 0:
                 cmake_opts = ['-G', i] + cmake_opts
 
@@ -1334,7 +1353,7 @@ def _detect_dep(self, name: str, modules: T.List[T.Tuple[str, bool]], args: T.Li
 
         # Post-process module list. Used in derived classes to modify the
         # module list (append prepend a string, etc.).
-        modules = self._map_module_list(modules)
+        modules = self._map_module_list(modules, components)
         autodetected_module_list = False
 
         # Try guessing a CMake target if none is provided
diff --git a/mesonbuild/dependencies/data/CMakeLists.txt b/mesonbuild/dependencies/data/CMakeLists.txt
index b52a69a854..26c067d562 100644
--- a/mesonbuild/dependencies/data/CMakeLists.txt
+++ b/mesonbuild/dependencies/data/CMakeLists.txt
@@ -9,7 +9,7 @@ set(_packageName "${NAME}")
 string(TOUPPER "${_packageName}" PACKAGE_NAME)
 
 while(TRUE)
-  find_package("${NAME}" QUIET)
+  find_package("${NAME}" QUIET COMPONENTS ${COMPS})
 
   # ARCHS has to be set via the CMD interface
   if(${_packageName}_FOUND OR ${PACKAGE_NAME}_FOUND OR "${ARCHS}" STREQUAL "")
diff --git a/mesonbuild/dependencies/dev.py b/mesonbuild/dependencies/dev.py
index 534684b5da..72dda628c8 100644
--- a/mesonbuild/dependencies/dev.py
+++ b/mesonbuild/dependencies/dev.py
@@ -418,7 +418,7 @@ def _main_cmake_file(self) -> str:
     def _extra_cmake_opts(self) -> T.List[str]:
         return ['-DLLVM_MESON_MODULES={}'.format(';'.join(self.llvm_modules + self.llvm_opt_modules))]
 
-    def _map_module_list(self, modules: T.List[T.Tuple[str, bool]]) -> T.List[T.Tuple[str, bool]]:
+    def _map_module_list(self, modules: T.List[T.Tuple[str, bool]], components: T.List[T.Tuple[str, bool]]) -> T.List[T.Tuple[str, bool]]:
         res = []
         for mod, required in modules:
             cm_targets = self.traceparser.get_cmake_var('MESON_LLVM_TARGETS_{}'.format(mod))
diff --git a/mesonbuild/interpreter.py b/mesonbuild/interpreter.py
index c29ed89fc0..cbfeab89f8 100644
--- a/mesonbuild/interpreter.py
+++ b/mesonbuild/interpreter.py
@@ -2120,6 +2120,7 @@ def _get_native() -> str:
                                    'main',
                                    'method',
                                    'modules',
+                                   'components',
                                    'cmake_module_path',
                                    'optional_modules',
                                    'native',
@@ -3281,6 +3282,7 @@ def _handle_featurenew_dependencies(self, name):
         elif name == 'openmp':
             FeatureNew('OpenMP Dependency', '0.46.0').use(self.subproject)
 
+    @FeatureNewKwargs('dependency', '0.54.0', ['components'])
     @FeatureNewKwargs('dependency', '0.52.0', ['include_type'])
     @FeatureNewKwargs('dependency', '0.50.0', ['not_found_message', 'cmake_module_path', 'cmake_args'])
     @FeatureNewKwargs('dependency', '0.49.0', ['disabler'])
diff --git a/test cases/linuxlike/13 cmake dependency/cmake/FindSomethingLikeZLIB.cmake b/test cases/linuxlike/13 cmake dependency/cmake/FindSomethingLikeZLIB.cmake
index 4f12706ed4..d19f7e8c0b 100644
--- a/test cases/linuxlike/13 cmake dependency/cmake/FindSomethingLikeZLIB.cmake	
+++ b/test cases/linuxlike/13 cmake dependency/cmake/FindSomethingLikeZLIB.cmake	
@@ -38,6 +38,10 @@ if(NOT C_CODE_RAN)
   message(FATAL_ERROR "Running C source code failed")
 endif()
 
+if(NOT SomethingLikeZLIB_FIND_COMPONENTS STREQUAL "required_comp")
+  message(FATAL_ERROR "Component 'required_comp' was not specified")
+endif()
+
 find_dependency(Threads)
 
 if(ZLIB_FOUND OR ZLIB_Found)
diff --git a/test cases/linuxlike/13 cmake dependency/meson.build b/test cases/linuxlike/13 cmake dependency/meson.build
index a76b32789f..79acc83c4d 100644
--- a/test cases/linuxlike/13 cmake dependency/meson.build	
+++ b/test cases/linuxlike/13 cmake dependency/meson.build	
@@ -44,9 +44,9 @@ depPrefEnv = dependency('cmMesonTestDep', required : true, method : 'cmake')
 
 # Try to find a dependency with a custom CMake module
 
-depm1 = dependency('SomethingLikeZLIB', required : true, method : 'cmake', cmake_module_path : 'cmake')
-depm2 = dependency('SomethingLikeZLIB', required : true, method : 'cmake', cmake_module_path : ['cmake'])
-depm3 = dependency('SomethingLikeZLIB', required : true, cmake_module_path : 'cmake')
+depm1 = dependency('SomethingLikeZLIB', required : true, components : 'required_comp',   method : 'cmake', cmake_module_path : 'cmake')
+depm2 = dependency('SomethingLikeZLIB', required : true, components : 'required_comp',   method : 'cmake', cmake_module_path : ['cmake'])
+depm3 = dependency('SomethingLikeZLIB', required : true, components : ['required_comp'], cmake_module_path : 'cmake')
 
 # Test some edge cases with spaces, etc.
 
